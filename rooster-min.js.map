{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/EntityInfo.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/getEntityElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isHTMLElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEditFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isHTMLTableCellElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isHTMLTableElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/htmlToDom.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/darkMode/normalizeContentColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CorePastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/FirefoxTypeAfterLink.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/Undo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/calculateDefaultFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentToggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/toggleTagCore.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/CustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/getEntities.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/tryTriggerEntityEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/createEntityWrapper.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isRtl.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/adjustNodeInsertPosition.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isDocumentFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/typeUtils/isHTMLOListElement.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/adjustBrowserBehavior.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/createEditorCore.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/undo/UndoSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/editWithUndo.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreAPI/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/mapPluginEvents.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/darkMode/convertContentToDarkMode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/eventApi/cacheGetElementAtCursor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentSetIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/insertLineBeforeStructuredNodeFeature.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/noCycleCursorMove.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Entity.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/EntityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Entity/insertEntity.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","getRangeFromSelectionPath","splitWithFragment","node","nodeType","tagName","toUpperCase","cacheGetContentSearcher","clearContentSearcherCache","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","getLeafSibling","rootNode","startNode","isNext","skipTags","ignoreSpace","result","getSibling","getChild","curNode","shouldContinue","indexOf","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","findHeadTailLeafNode","containerBlockNode","isTail","sibling","getBlockContext","headNode","tailNode","nodes","collection","slice","createRange","arg1","arg2","arg3","arg4","start","end","isNodePosition","Array","isArray","getPositionFromPath","getFocusablePosition","setStart","setEnd","arg","path","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","appendChild","innerHTML","insertBefore","temp","root","selector","closest","matches","msMatchesSelector","parentElement","wrapper","test","createElement","parent","parentBlock","inlineElement","nodeChain","push","currentNode","tag","resolveInlineElement","node1","node2","compareDocumentPosition","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","FONT_SIZES","TAGS_TO_UNWRAP","TAGS_TO_STOP_UNWRAP","ATTRIBUTES_TO_PRESERVE","getElementBasedFormatState","getStyleBasedFormatState","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","ENTITY_ID_REGEX","getAllEntityIds","e","id","ALLOWED_CSS_CLASSES","type","isReadonly","originalId","knownIds","ENTITY_INFO_NAME","existingIdOrType","match","exec","baseId","substr","newId","num","parseInt","createEntityId","entityInfo","isEntity","forEach","deserialzeEntityInfo","className","contentNode","collapse","ref","isStart","canSplitParent","startIndex","endIndex","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","textContent","getEndPosition","isTextualInlineElement","pos","styler","CRLF","CRLFSPACE","shouldSkipNode","replace","child","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","querySelectorAll","checkPosition","targets","some","target","forEachCallback","scope","elements","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","removeChild","getElementAtCursor","getEntitySelector","collapseToSingleElement","equals","blockElement","HTML_VOID_ELEMENTS","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","textNode","returnFirstPart","firstPart","secondPart","newNode","isPartial","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","getListTypeFromNode","region","nodeBefore","nodeAfter","snapshots","step","newIndex","currentIndex","isCtrlOrMetaPressed","isMac","event","metaKey","ctrlKey","eventDataCache","existingList","isChrome","parentLINode","currentRange","currentSelectionPath","getSelectionPath","listParent","nextElementSibling","insertAdjacentElement","wrappedContents","wrap","toArray","wrappedRange","wrappedSelectionPath","deleteNode","newRange","childElementCount","newList","autoLink","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","isIE","mergeInNewLineWhenBackspaceOnFirstChar","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","autoBullet","tabInTable","upDownInTable","isSafari","insertLineBeforeStructuredNodeFeature","defaultShortcut","unlinkWhenBackspaceAfterLink","noCycleCursorMove","smartOrderedList","smartOrderedListStyles","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","html","getFirstLastBlockElement","isFirst","getLeafNode","userAgent","appVersion","isIE11OrGreater","isFirefox","isEdge","isWebKit","isWin","isIEOrEdge","navigator","areAllPrevousNodesEmpty","targetNode","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","writeBack","moveChildren","cell","recalcSpans","applyFormat","format","borderCollapse","backgroundColor","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","splice","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getFirstOrLastNode","isLast","getNode","listStack","createDocumentFragment","setIndentation","indentation","findListItems","outdent","indent","changeListType","needChangeType","getListType","appendItem","newListNode","nodeTag","mergeVList","list","originalLength","mergeOrphanNodesAfter","isOrphanItem","canMerge","mergeItems","listStartPos","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","fullSelectionEnd","fullSelectionStart","blocks","regionRange","regionStart","regionEnd","traverser","block","getPositionPath","unshift","isPreviousText","removedSize","totalSize","INHERITABLE_PROPERTIES","win","defaultFragmentTrimmer","doc","sourceHtml","body","lastIndexOf","before","after","substring","preserveFragmentOnly","fragmentHandler","DOMParser","parseFromString","cloneObject","assign","existingObj","isEmptyBlockUnderTR","color","isDarkMode","darkModeColor","lightModeColor","dataset","ogsb","fontName","fontFamily","fontSize","lineHeight","ogsc","onExtract","isCut","selectionRange","clipboardEvent","copyFragment","cloneContents","containerDiv","contentEditable","clipboardData","setData","innerText","deleteContents","preventDefault","getName","initialize","eventDisposer","addDomEventHandler","copy","cut","dispose","isDataAttributeSettable","newStyle","allChildElements","getElementsByTagName","ogac","ogab","onPaste","extractClipboardEvent","undefined","getCustomData","createTempDivForIE","pasteDiv","runAsync","paste","fromHtml","disposer","types","image","text","rawHtml","snapshotBeforePaste","imageDataUri","originalFormat","FileReader","onload","onerror","readAsDataURL","disableRestoreSelectionOnFocus","inIme","onNativeEvent","onFocus","cachedPosition","cachedFormatState","restorePendingFormatState","clear","restoreSavedRange","onBlur","saveSelectionRange","onScroll","rawEvent","scrollContainer","getScrollContainer","compositionstart","compositionend","drop","addEventListener","removeEventListener","onPluginEvent","eventType","getCurrentPosition","isInIME","featureMap","autoCompleteSnapshot","autoCompleteChangeSource","addFeature","shouldHandleEvent","handleEvent","setContent","contentChanged","currentFeature","findFeature","feature","array","performAutoComplete","changeSource","snapshot","data","features","hasFunctionKey","ctrlOrMeta","altKey","which","allowFunctionKeys","getInlineElementBefore","LinkInlineElement","getContentSearcherOfCursor","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","onKeyPress","ensureTypeInElement","getBlockElementAtNode","shouldSetNodeStyles","isNodeEmpty","wasNodeJustCreatedByKeyboardEvent","updateCursor","replaceSelection","insertOnNewLine","getDefaultFormat","findClosestElementAncestor","tryNormalizeTyping","isNode","preserveSnapshots","maxBufferSize","canUndo","canRedo","onKeyDown","clearRedoForInput","isRestoring","undoSnapshots","hasNewContent","undo","restoreSnapshot","redo","getSnapshotsManager","canMove","getContent","addSnapshot","delta","evt","lastKeyPress","clearRedo","isCtrlKey","isAltKey","isMetaKey","DARK_MODE_DEFAULT_FORMAT","baseFormat","inDarkMode","backgroundColors","textColors","textColor","bold","italic","underline","currentStyles","hasFocus","core","activeElement","contentDiv","getSelectedRegions","listType","vList","createVListFromRegion","UNWRAPPABLE_NODES","DEFAULT_STYLER","_","wrapFunction","unwrapFunction","unwrap","queryElements","startBlock","endBlock","collapseNodes","getAndSetNodeId","customData","getAttribute","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","entity","isBlock","serializeEntityInfo","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","concat","options","defaultFormat","Editor","getDefaultContentEditFeatures","featureSet","getFilteredFeatures","addContentEditFeature","allFeatures","IndentWhenTab","OutdentWhenShiftTab","OutdentWhenBackOn1stEmptyLine","OutdentWhenEnterOnEmptyLine","MergeInNewLine","UnquoteWhenBackOnEmpty1stLine","UnquoteWhenEnterOnEmptyLine","TabInTable","UpDownInTable","InsertLineBeforeStructuredNodeFeature","AutoBullet","AutoLink","UnlinkWhenBackspaceAfterLink","DefaultShortcut","NoCycleCursorMove","getSmartOrderedList","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","getFirstBlockElement","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","getWordBefore","word","traverse","inlineBefore","inlineAfter","getSubStringBefore","getRangeFromText","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","elementStyle","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","workaroundForEdge","headerValues","getData","getAsString","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","originalUrl","normalizedUrl","adjustSteps","nodeToInsert","anchor","a","safeRemove","querySelector","normalizedPosition","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","listNode","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","div","handler","orderListStyles","wrapIfNotBlockNode","pop","nextLevel","listStyleType","checkFirst","checkLast","tryIncludeSiblingNode","getRootListNode","ancestor","includeSiblingLists","createVListFromItemNode","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","regions","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","regionTypeData","normalizeRect","clientRect","left","right","top","bottom","rect","getBoundingClientRect","rects","getClientRects","span","content","selectionPath","JSON","stringify","pathComment","parse","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","attributeCallbacks","allowedTags","getAllowedTags","additionalAllowedTags","allowedAttributes","getAllowedAttributes","additionalAllowAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","allowPreserveWhiteSpace","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentElementOrStyle","convertCssOnly","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","j","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","allowElement","insidePRE","thisStyle","processAttributes","processCss","next","styleNode","getAttributeNode","pair","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","ALLOWED_HTML_TAGS","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","removeValue","removeWidthForLiAndDiv","unique","self","additionalTags","additionalAttributes","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","TRAILING_PUNCTUATION_REGEX","cacheGetLinkData","cacheGetEventData","link","matchLink","searcher","trailingPunctuation","str","linkData","href","replaceWithNode","removeLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","canCollapse","tagsToStopUnwrap","tagsToUnwrap","attributesToPreserve","groups","stopUnwrapSelector","group","first","clearNodeFormat","allChildrenAreBlock","previousValue","returnBlockElement","isBlockElement","clearAttribute","styleArray","STYLES_TO_REMOVE","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","title","listTag","cacheGetElementAtCursor","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","enableExperimentFeatures","plugin","eventDisposers","additionalEditFeatures","omitContentEditableAttributeChanges","isContentEditable","userSelect","msUserSelect","webkitUserSelect","contenteditableChanged","corePlugins","typeInContainer","getFocusedPosition","isDisposed","option","darkModeOptions","getDarkModeOptions","darkModeTransform","convertContentToDarkMode","onExternalContentTransform","api","replaceNode","existingNode","getInlineElementAtNode","scopeOrCallback","Function","isEmpty","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","getHtmlWithSelectionPath","triggerContentChangedEvent","setHtmlWithSelectionPath","convertFunction","insertContent","allNodes","pasteAsText","applyCurrentFormat","createPasteFragment","isRange","selectRange","getSelection","cachedSelectionRange","sel","focusNode","focusOffset","getCursorRect","getPositionRect","isPositionAtBeginning","isPositionAtBeginningOf","getRegionsFromRange","nameOrMap","eventName","attachDomEvent","x","broadcast","triggerEvent","pluginEvent","editWithUndo","domEvent","getBodyTraverser","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","setDarkModeState","nextDarkMode","currentContent","calculateDefaultFormat","changedToDarkMode","useExperimentFeatures","COMMANDS","createCoreApiMap","initValue","mouseUp","firefoxTypeAfterLink","copyPlugin","pastePlugin","allPlugins","buildPluginList","eventHandlerPlugins","willHandleEventExclusively","currentUndoSnapshot","coreApiOverride","defaultApi","createSnapshots","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearProceedingSnapshots","pluginEventType","beforeDispatch","onEvent","stopPropagation","processStyles","applyCurrentStyle","pasteOption","fragment","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","img","maxWidth","src","attrs","meta","head","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","isNested","tryGetFromCache","selection","rangeCount","getRangeAt","ogTextColorNode","ogBackgroundColorNode","isBegin","refNode","isVoidHtmlElement","insertedNode","rangeToRestore","cloneRange","adjustNodeInsertPosition","nodeForCursor","skipSameRange","needAddRange","removeAllRanges","addRange","handledExclusively","EVENT_MAPPING","keypress","keydown","keyup","mousedown","skipRootElement","childElements","isHTMLElement","isDocumentFragment","insertImageWithSrc","imageFile","reader","getTableCellWidth","columns","cellSpacing","cellPadding","vtable","VTable","textOrRange","backupRange","alignment","align","textAlign","direction","collapseNodesInRegion","quote","isNodeInRegion","getSelectedBlockElementsInRegion","blockGroups","borderColor","paddingLeft","codeBlock","level","wrapped","header","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","toggleBullet","toggleNumbering","changeFontSize","cacheGetCommand","shiftKey","cmd","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","cacheGetStructuredElement","rtl","isRtl","cacheGetTableCell","firstTd","isUp","targetTd","hasShiftKey","anchorNode","anchorOffset","newContainer","newPos","setBaseAndExtent","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","toggleListAndPreventDefault","listInfo","cacheGetListElement","listElement","br","textBeforeCursor","rangeToDelete","styleList","isHTMLOListElement","ol","parentOl","listStyle","QUOTE_TAG","STRUCTURED_TAGS","cacheGetQuoteChild","splitQuote","childOfQuote","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","replacements","updateReplacements","newReplacements","longestReplacementLength","replacement","replacementEndCharacters","endChars","Set","lastChar","add","toLocaleUpperCase","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","getTooltipCallback","onLinkClick","onMouse","tryGetHref","mouseover","mouseout","srcElement","button","open","BEGIN_TAG","END_TAG","EXTRACT_HTML_REGEX","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","pageX","startPageY","pageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","cursor","stopEvent","widthChange","heightChange","newWidth","isWest","newHeight","isNorth","ratio","height","resizeDiv","removeResizeDivIfAny","previous","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","blur","currentImg","showResizeHandle","extractHtml","createResizeDiv","selectImageAfterUnSelect","referenceNode","createComment","pointerEvents","comment","preserved","wacListElements","el","margin","isWordOnlineWithList","chainSanitizerCallback","pasteOriginal","pasteText","pasteAndMergeFormat","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","newHtml","trMatch","tableMatch","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","lists","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","textStyle","inStyles","nvpair","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","startElement","section","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","append","firstElementChild","insertListItem","parentContainer","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isCharacterValue","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","y","bufferZone","keyboardEvent","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","inlineElementBefore","inlineElementAfter","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","onMouseOver","calcAndShowHandle","onMouseDown","initialPageX","attachMouseEvents","getResizeHandle","borderWidth","cancelEvent","onMouseMove","adjustHandle","detachMouseEvents","setTableColumnWidth","onMouseOverDisposer","clickIntoCurrentTd","handle","offsetLeft","offsetWidth","offsetHeight","getPosition","offsetParent","scrollLeft","offsetTop","scrollTop","WATERMARK_REGEX","watermark","handleWatermark","showHideWatermark","spellcheckInitialValue","hideWatermark","isWatermarkShowing","removeWartermarkFromHtml","ignoreCachedState","showWatermark","watermarkNode","handleContextMenuEvent","entityElement","handleCutEvent","checkRemoveEntityForRange","contextmenu","knownEntityElements","ClickOnEntityFeature","EscapeFromEntityFeature","EnterBeforeReadonlyEntityFeature","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","clickingPoint","workaroundSelectionIssueForIE","entityElements","resetAll","editableEntityElements","isFullyCovered","workaroundButton","onblur","cacheGetReadonlyEntityElement","cacheGetNeighborEntityElement","collapseOnly","checkForSameLine","lookForPrev","entityNode","existingEntity"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 100);\n","export { default as NodeBlockElement } from './blockElements/NodeBlockElement';\r\nexport { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\nexport { default as StartEndBlockElement } from './blockElements/StartEndBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isRtl } from './utils/isRtl';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as adjustNodeInsertPosition } from './utils/adjustNodeInsertPosition';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as toArray } from './utils/toArray';\r\n\r\nexport { default as VTable, VCell } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange, getRangeFromSelectionPath } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as htmlToDom, splitWithFragment } from './htmlSanitizer/htmlToDom';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as isDocumentFragment } from './typeUtils/isDocumentFragment';\r\nexport { default as isHTMLElement } from './typeUtils/isHTMLElement';\r\nexport { default as isHTMLOListElement } from './typeUtils/isHTMLOListElement';\r\nexport { default as isHTMLTableCellElement } from './typeUtils/isHTMLTableCellElement';\r\nexport { default as isHTMLTableElement } from './typeUtils/isHTMLTableElement';\r\nexport { default as isNode } from './typeUtils/isNode';\r\nexport { default as isRange } from './typeUtils/isRange';\r\nexport { default as safeInstanceOf } from './typeUtils/safeInstanceOf';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","// Interfaces\r\nexport {\r\n    ContentEditFeature,\r\n    GenericContentEditFeature,\r\n    Keys,\r\n} from './interfaces/ContentEditFeature';\r\nexport { default as CustomData, CustomDataMap } from './interfaces/CustomData';\r\nexport {\r\n    default as EditorCore,\r\n    AttachDomEvent,\r\n    CorePlugins,\r\n    CoreApiMap,\r\n    CreatePasteFragment,\r\n    EditWithUndo,\r\n    Focus,\r\n    GetCustomData,\r\n    GetSelectionRange,\r\n    GetStyleBasedFormatState,\r\n    HasFocus,\r\n    InsertNode,\r\n    Select,\r\n    SelectRange,\r\n    TriggerEvent,\r\n} from './interfaces/EditorCore';\r\nexport { default as EditorOptions } from './interfaces/EditorOptions';\r\nexport { default as EditorPlugin } from './interfaces/EditorPlugin';\r\nexport { default as UndoService } from './interfaces/UndoService';\r\nexport { default as UndoSnapshotsService } from './interfaces/UndoSnapshotsService';\r\n\r\n// Classes\r\nexport { default as Editor } from './editor/Editor';\r\nexport { default as Undo } from './undo/Undo';\r\n\r\n// Core Plugins\r\nexport { default as EditPlugin } from './corePlugins/EditPlugin';\r\nexport { default as MouseUpPlugin } from './corePlugins/MouseUpPlugin';\r\nexport { default as DOMEventPlugin } from './corePlugins/DOMEventPlugin';\r\nexport { default as TypeInContainerPlugin } from './corePlugins/TypeInContainerPlugin';\r\nexport { default as FirefoxTypeAfterLink } from './corePlugins/FirefoxTypeAfterLink';\r\nexport { default as CopyPlugin } from './corePlugins/CopyPlugin';\r\nexport { default as CorePastePlugin } from './corePlugins/CorePastePlugin';\r\n\r\n// Event APIs\r\nexport { default as cacheGetEventData } from './eventApi/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './eventApi/clearEventDataCache';\r\nexport {\r\n    cacheGetContentSearcher,\r\n    clearContentSearcherCache,\r\n} from './eventApi/cacheGetContentSearcher';\r\nexport { default as cacheGetElementAtCursor } from './eventApi/cacheGetElementAtCursor';\r\nexport { default as isModifierKey } from './eventApi/isModifierKey';\r\nexport { default as isCharacterValue } from './eventApi/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './eventApi/isCtrlOrMetaPressed';\r\n","import isRange from '../typeUtils/isRange';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (isRange(contained)) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return !!(treatSameNodeAsContain || container != contained) && container.contains(contained);\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\n\n// NOTE: Type TargetWindow is an auto-generated type.\n// Run node ./tools/generateTargetWindow.js to generate it.\n\n/**\n * Try get window from the given node or range\n * @param source Source node or range\n */\nexport function getTargetWindow(source: Node | Range): TargetWindow {\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\n    const document =\n        node &&\n        (node.ownerDocument ||\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\n                ? <Document>node\n                : null));\n\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\n    const targetWindow = document && ((document.defaultView || window) as any);\n    return targetWindow as TargetWindow;\n}\n\n/**\n * Check if the given object is instance of the target type\n * @param obj Object to check\n * @param typeName Target type name\n */\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\n    obj: Node | Range,\n    typeName: T\n): obj is TargetWindow[T] {\n    const targetWindow = getTargetWindow(obj);\n    const targetType = targetWindow && (targetWindow[typeName] as any);\n    const mainWindow = (window as any) as TargetWindow;\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\n    return (\n        (mainWindowType && obj instanceof mainWindowType) ||\n        (targetType && obj instanceof targetType)\n    );\n}\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","/**\n * Convert a named node map to an array\n * @param collection The map to convert\n */\nexport default function toArray(collection: NamedNodeMap): Attr[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\n\n/**\n * Convert a collection to an array\n * @param collection The collection to convert\n */\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\n\n/**\n * Convert an array to an array.\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\n * but the declaration is an array. e.g. ClipboardData.types\n * @param array The array to convert\n */\nexport default function toArray<T>(array: readonly T[]): T[];\n\nexport default function toArray(collection: any): any[] {\n    return [].slice.call(collection);\n}\n","import isNode from '../typeUtils/isNode';\r\nimport isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, PositionType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (isNode(arg1)) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = isNode(arg3) ? new Position(arg3, arg4) : null;\r\n        } else if (isNode(arg2) || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n\r\n/**\r\n * @deprecated Use createRange instead\r\n * Get range from the given selection path\r\n * @param rootNode Root node of the selection path\r\n * @param path The selection path which contains start and end position path\r\n */\r\nexport function getRangeFromSelectionPath(rootNode: HTMLElement, path: SelectionPath) {\r\n    return createRange(rootNode, path.start, path.end);\r\n}\r\n","import { ChangeSource, DocumentCommand, PluginEventType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: Editor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport isHTMLElement from '../typeUtils/isHTMLElement';\r\nimport isNode from '../typeUtils/isNode';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : isNode(nodes) ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!isHTMLElement(wrapper)) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport isNode from '../typeUtils/isNode';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = isNode(parent) ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport {\r\n    default as clearBlockFormat,\r\n    TAGS_TO_UNWRAP,\r\n    TAGS_TO_STOP_UNWRAP,\r\n    ATTRIBUTES_TO_PRESERVE,\r\n} from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport {\r\n    default as getFormatState,\r\n    getElementBasedFormatState,\r\n    getStyleBasedFormatState,\r\n} from './format/getFormatState';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\n// @deprecated the function getPendableFormatState will still be available from\r\n// roosterjs-editor-dom package, keep export it here just for compatibility\r\nexport { getPendableFormatState } from 'roosterjs-editor-dom';\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: Editor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import getEntities from './getEntities';\nimport { Editor } from 'roosterjs-editor-core';\n\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\nconst ENTITY_INFO_NAME = '_Entity';\nconst ENTITY_TYPE_PREFIX = '_EType_';\nconst ENTITY_ID_PREFIX = '_EId_';\nconst ENTITY_READONLY_PREFIX = '_EReadonly_';\n\nconst ENTITY_CSS_REGEX = '^' + ENTITY_INFO_NAME + '$';\nconst ENTITY_ID_CSS_REGEX = '^' + ENTITY_ID_PREFIX;\nconst ENTITY_TYPE_CSS_REGEX = '^' + ENTITY_TYPE_PREFIX;\nconst ENTITY_READONLY_CSS_REGEX = '^' + ENTITY_READONLY_PREFIX;\n\nexport const ALLOWED_CSS_CLASSES = [\n    ENTITY_CSS_REGEX,\n    ENTITY_ID_CSS_REGEX,\n    ENTITY_TYPE_CSS_REGEX,\n    ENTITY_READONLY_CSS_REGEX,\n];\n\n/**\n * @internal Serialize entity info into a CSS class list string\n * @param editor The editor which contains the entity\n * @param type Type of the entity\n * @param isReadonly Whether the entity is readonly\n * @param originalId (Optional) Existing id of the entity. If this id already exists in the editor, it will be replaced\n * by a new one\n * @param knownIds (Optional) All known entity ids inside this editor. This is a performance optimization when this function\n * will be called multiple times\n */\nexport function serializeEntityInfo(\n    editor: Editor,\n    type: string,\n    isReadonly: boolean,\n    originalId?: string,\n    knownIds: string[] = getAllEntityIds(editor)\n): string {\n    const id = createEntityId(originalId || type, knownIds);\n    return `${ENTITY_INFO_NAME} ${ENTITY_TYPE_PREFIX}${type} ${ENTITY_ID_PREFIX}${id} ${ENTITY_READONLY_PREFIX}${\n        isReadonly ? '1' : '0'\n    }`;\n}\n\n/**\n * @internal Deserialze entity info string to entity info (type, id, isReadonly)\n * @param entityInfo The entity info string generated from serializeEntityInfo()\n */\nexport function deserialzeEntityInfo(\n    entityInfo: string\n): {\n    type: string;\n    id: string;\n    isReadonly: boolean;\n} {\n    let isEntity = false;\n    let type: string;\n    let id = '';\n    let isReadonly = false;\n\n    if (entityInfo) {\n        entityInfo.split(' ').forEach(name => {\n            if (name == ENTITY_INFO_NAME) {\n                isEntity = true;\n            } else if (name.indexOf(ENTITY_TYPE_PREFIX) == 0) {\n                type = name.substr(ENTITY_TYPE_PREFIX.length);\n            } else if (name.indexOf(ENTITY_ID_PREFIX) == 0) {\n                id = name.substr(ENTITY_ID_PREFIX.length);\n            } else if (name.indexOf(ENTITY_READONLY_PREFIX) == 0) {\n                isReadonly = name.substr(ENTITY_READONLY_PREFIX.length) == '1';\n            }\n        });\n    }\n\n    return isEntity && type\n        ? {\n              type,\n              id,\n              isReadonly,\n          }\n        : null;\n}\n\n/**\n * @internal Get all known entity ids from an editor\n * @param editor The editor to get entity ids from\n */\nexport function getAllEntityIds(editor: Editor): string[] {\n    return getEntities(editor).map(e => e.id);\n}\n\n/**\n * @internal Get a selector string for specified entity type and id\n * @param type (Optional) Type of entity\n * @param id (Optional) Id of entity\n */\nexport function getEntitySelector(type?: string, id?: string): string {\n    const typeSelector = type ? `.${ENTITY_TYPE_PREFIX}${type}` : '';\n    const idSelector = id ? `.${ENTITY_ID_PREFIX}${id}` : '';\n    return '.' + ENTITY_INFO_NAME + typeSelector + idSelector;\n}\n\nfunction createEntityId(existingIdOrType: string, knownIds: string[]) {\n    const match = ENTITY_ID_REGEX.exec(existingIdOrType);\n    const baseId = match\n        ? existingIdOrType.substr(0, existingIdOrType.length - match[0].length)\n        : existingIdOrType;\n    let newId = '';\n\n    for (let num = (match && parseInt(match[1])) || 0; ; num++) {\n        newId = `${baseId}_${num}`;\n\n        if (knownIds.indexOf(newId) < 0) {\n            knownIds.push(newId);\n            break;\n        }\n    }\n\n    return newId;\n}\n","import { deserialzeEntityInfo } from './EntityInfo';\nimport { Entity } from 'roosterjs-editor-types';\n\n/**\n * Get Entity object from an entity root element\n * @param element The entity root element. If this element is not an entity root element,\n * it will return null\n */\nexport default function getEntityFromElement(element: HTMLElement): Entity {\n    const entityInfo = deserialzeEntityInfo(element?.className);\n\n    return entityInfo\n        ? {\n              contentNode: element,\n              ...entityInfo,\n          }\n        : null;\n}\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\nfunction collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is Node\n * @param obj The object to check\n */\nexport default function isNode(obj: any): obj is Node {\n    return safeInstanceOf(obj as Node, 'Node');\n}\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): ContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: HTMLElement,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import { Editor } from 'roosterjs-editor-core';\nimport { getEntitySelector } from './EntityInfo';\n\n/**\n * Get the entity element from a child (or the element itself) of an entity.\n * If the given node is not part of an entity, it will return null\n * @param editor The editor to get entity from\n * @param node The child node\n */\nexport default function getEntityElement(editor: Editor, node: Node): HTMLElement {\n    return (node && editor.getElementAtCursor(getEntitySelector(), node)) || null;\n}\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is Range\n * @param obj The object to check\n */\nexport default function isRange(obj: any): obj is Range {\n    return safeInstanceOf(obj as Node, 'Range');\n}\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLElement\n * @param obj The object to check\n */\nexport default function isHTMLElement(obj: any): obj is HTMLElement {\n    return safeInstanceOf(obj as Node, 'HTMLElement');\n}\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import getTagOfNode from '../utils/getTagOfNode';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\n * @param listElement the element to get list type from\n */\nexport default function getListTypeFromNode(\n    listElement: HTMLOListElement | HTMLUListElement\n): ListType.Ordered | ListType.Unordered;\n\n/**\n * Get list type from a DOM node. It is possible to return ListType.None\n * @param node the node to get list type from\n */\nexport default function getListTypeFromNode(node: Node): ListType;\n\nexport default function getListTypeFromNode(node: Node): ListType {\n    switch (getTagOfNode(node)) {\n        case 'OL':\n            return ListType.Ordered;\n        case 'UL':\n            return ListType.Unordered;\n        default:\n            return ListType.None;\n    }\n}\n\n/**\n * @internal\n * Check if the given DOM node is a list element (OL or UL)\n * @param node The node to check\n */\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\n    return getListTypeFromNode(node) != ListType.None;\n}\n","import contains from '../utils/contains';\nimport { DocumentPosition, Region } from 'roosterjs-editor-types';\n\n/**\n * Check if a given node is contained by the given region\n * @param region The region to check from\n * @param node The node or block element to check\n */\nexport default function isNodeInRegion(region: Region, node: Node): boolean {\n    return !!(\n        region &&\n        contains(region.rootNode, node) &&\n        (!region.nodeBefore ||\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\n        (!region.nodeAfter ||\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\n    );\n}\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\n\n/**\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\n * @param event A Keyboard event or Mouse event object\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\n */\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\n    ? event => event.metaKey\n    : event => event.ctrlKey;\nexport default isCtrlOrMetaPressed;\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Gets the cached event data by cache key from event object if there is already one.\r\n * Otherwise, call getter function to create one, and cache it.\r\n * @param event The event object\r\n * @param key Cache key string, need to be unique\r\n * @param getter Getter function to get the object when it is not in cache yet\r\n */\r\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\r\n    let result =\r\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\r\n            ? <T>event.eventDataCache[key]\r\n            : getter();\r\n    if (event) {\r\n        event.eventDataCache = event.eventDataCache || {};\r\n        event.eventDataCache[key] = result;\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    createRange,\r\n    getSelectionPath,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport type ValidProcessListDocumentCommands =\r\n    | DocumentCommand.Outdent\r\n    | DocumentCommand.Indent\r\n    | DocumentCommand.InsertOrderedList\r\n    | DocumentCommand.InsertUnorderedList;\r\n\r\n/**\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(\r\n    editor: Editor,\r\n    command: ValidProcessListDocumentCommands\r\n): Node {\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    if (Browser.isChrome && command !== DocumentCommand.Indent) {\r\n        // Chrome has a bug where certain information about elements are deleted when outdent or enter on empty line occurs.\r\n        // We need to clone our current LI node so we can replace the new LI node with it post outdent / enter.\r\n        const parentLINode = editor.getElementAtCursor('LI');\r\n        // We must first be in an LI node to do something to fix this.\r\n        if (parentLINode) {\r\n            // We also don't want to try to handle the multi select outdent case at this time.\r\n            // These are already pretty stable in Chromium.\r\n            const currentRange = editor.getSelectionRange();\r\n            const currentSelectionPath = getSelectionPath(parentLINode, currentRange);\r\n            if (\r\n                currentRange &&\r\n                (currentRange.collapsed ||\r\n                    (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&\r\n                        editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode))\r\n            ) {\r\n                // Handle the case for toggling between the two list types as a special case.\r\n                // We'll let the browser handle this for now.\r\n                if (\r\n                    (existingList.tagName === 'OL' &&\r\n                        command === DocumentCommand.InsertUnorderedList) ||\r\n                    (existingList.tagName === 'UL' && command === DocumentCommand.InsertOrderedList)\r\n                ) {\r\n                    editor.getDocument().execCommand(command, false, null);\r\n                } else {\r\n                    // Get the next highest list element.\r\n                    // In well formed HTML, this should just be the existing list's parent container.\r\n                    const listParent = existingList.parentElement;\r\n                    if (listParent.tagName == 'OL' || listParent.tagName == 'UL') {\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n                        existingList.insertAdjacentElement('afterend', parentLINode);\r\n                        editor.select(\r\n                            createRange(\r\n                                parentLINode,\r\n                                currentSelectionPath.start,\r\n                                currentSelectionPath.end\r\n                            )\r\n                        );\r\n                    } else {\r\n                        // In this case, we're going out to the parent root.\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n\r\n                        const wrappedContents = wrap(toArray(parentLINode.childNodes));\r\n                        const wrappedRange = createRange(\r\n                            wrappedContents,\r\n                            currentSelectionPath.start,\r\n                            currentSelectionPath.end\r\n                        );\r\n                        const wrappedSelectionPath = getSelectionPath(\r\n                            wrappedContents,\r\n                            wrappedRange\r\n                        );\r\n\r\n                        existingList.insertAdjacentElement('afterend', wrappedContents);\r\n                        editor.deleteNode(parentLINode);\r\n                        let newRange = createRange(\r\n                            wrappedContents,\r\n                            wrappedSelectionPath.start,\r\n                            wrappedSelectionPath.end\r\n                        );\r\n                        editor.select(newRange);\r\n                    }\r\n\r\n                    if (existingList.childElementCount == 0) {\r\n                        editor.deleteNode(existingList);\r\n                    }\r\n                }\r\n            } else {\r\n                editor.getDocument().execCommand(command, false, null);\r\n            }\r\n        } else {\r\n            editor.getDocument().execCommand(command, false, null);\r\n        }\r\n    } else {\r\n        editor.getDocument().execCommand(command, false, null);\r\n    }\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n    return newList;\r\n}\r\n","export * from './ContentEdit';\r\nexport * from './CustomReplace';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\nexport * from './Entity';\r\n","import { Browser } from 'roosterjs-editor-dom';\n\n/**\n * Feature set for ContentEdit plugin.\n * Call getDefaultContentEditFeatures() to get default feature set.\n */\nexport default interface ContentEditFeatures {\n    /**\n     * When press Tab in a list, indent current list item\n     * @default true\n     */\n    indentWhenTab: boolean;\n\n    /**\n     * When press Shift+Tab in a list, outdent current list item\n     * @default true\n     */\n    outdentWhenShiftTab: boolean;\n\n    /**\n     * When press BaskSpace on empty line which is the first item of a list, outdent current list item\n     * @default true\n     */\n    outdentWhenBackspaceOnEmptyFirstLine: boolean;\n\n    /**\n     * When press Enter on empty line in a list, outdent current list item\n     * @default true for IE, false for other browsers since they have already had the behavior\n     */\n    outdentWhenEnterOnEmptyLine: boolean;\n\n    /**\n     * When press Backspace on first char in a list, make current item a new line of previous list item\n     * @default false\n     */\n    mergeInNewLineWhenBackspaceOnFirstChar: boolean;\n\n    /**\n     * When press BAckspace on empty line which is the first line of a blockquote, unquote current line\n     * @default true\n     */\n    unquoteWhenBackspaceOnEmptyFirstLine: boolean;\n\n    /**\n     * When press Enter on empty line in a blockquote, unquote current line\n     * @default true\n     */\n    unquoteWhenEnterOnEmptyLine: boolean;\n\n    /**\n     * When press space after an asterik or number in an empty line, toggle bullet/numbering\n     * @default true\n     */\n    autoBullet: boolean;\n\n    /**\n     * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell\n     * @default true\n     */\n    tabInTable: boolean;\n\n    /**\n     * When press Up or Down in table cell, jump to the table cell above/below\n     * @default true for Chrome and safari, false for other browsers since they arleady have correct behavior\n     */\n    upDownInTable: boolean;\n\n    /**\n     * When press Enter at the beginning of first structured element (table, list) and there isn't line before the position\n     * we create a new line before so that user got a chance to enter content before the table or list\n     * @default false\n     */\n    insertLineBeforeStructuredNodeFeature: boolean;\n\n    /**\n     * When press Space or Enter after a hyperlink-like string, convert the string to a hyperlink\n     * @default true\n     */\n    autoLink: boolean;\n\n    /**\n     * Respond to default common keyboard short, i.e. Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+Z, Ctrl+Y\n     * @default true\n     */\n    defaultShortcut: boolean;\n\n    /**\n     * Unlink when backspace right after a hyperlink\n     * @default false\n     */\n    unlinkWhenBackspaceAfterLink: boolean;\n\n    /**\n     * Chrome may make the cursor move the then end of document if press Ctrl+Left at the beginning of document\n     * Let's disable this behaivor\n     */\n    noCycleCursorMove: boolean;\n\n    /**\n     * When generate ordered list, the list bullet will variare according its nesting level, in a loop of '1', 'a', 'i'\n     * @default false\n     */\n    smartOrderedList: boolean;\n\n    /**\n     * A style list for smart ordered list. This value is only effective when smartOrderedList is true\n     * @default ['lower-alpha', 'lower-roman', 'decimal']\n     */\n    smartOrderedListStyles: string[];\n\n    /**\n     * When typing text surrounded by '*', the symbols will be removed and the text will be bolded.\n     * @default true\n     */\n    markdownBold: boolean;\n\n    /**\n     * When typing text surrounded by '_', the symbols will be removed and the text will be italicized.\n     * @default true\n     */\n    markdownItalic: boolean;\n\n    /**\n     * When typing text surrounded by '~', the symbols will be removed and the text will be striked through.\n     * @default true\n     */\n    markdownStrikethru: boolean;\n\n    /**\n     * When typing text surrounded by '`', the symbols will be removed and the text will be wrapped in a code tag.\n     * @default true\n     */\n    markdownInlineCode: boolean;\n}\n\n/**\n * Get default feature set of ContentEdit plugin\n */\nexport function getDefaultContentEditFeatures(): ContentEditFeatures {\n    return {\n        autoLink: true,\n        indentWhenTab: true,\n        outdentWhenShiftTab: true,\n        outdentWhenBackspaceOnEmptyFirstLine: true,\n        outdentWhenEnterOnEmptyLine: Browser.isIE || Browser.isChrome,\n        mergeInNewLineWhenBackspaceOnFirstChar: false,\n        unquoteWhenBackspaceOnEmptyFirstLine: true,\n        unquoteWhenEnterOnEmptyLine: true,\n        autoBullet: true,\n        tabInTable: true,\n        upDownInTable: Browser.isChrome || Browser.isSafari,\n        insertLineBeforeStructuredNodeFeature: false,\n        defaultShortcut: true,\n        unlinkWhenBackspaceAfterLink: false,\n        noCycleCursorMove: Browser.isChrome,\n        smartOrderedList: false,\n        smartOrderedListStyles: ['lower-alpha', 'lower-roman', 'decimal'],\n        markdownBold: true,\n        markdownItalic: true,\n        markdownStrikethru: true,\n        markdownInlineCode: true,\n    };\n}\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n\r\n/**\r\n * Get the first BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getFirstBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n */\r\nexport function getLastBlockElement(rootNode: Node): BlockElement {\r\n    return getFirstLastBlockElement(rootNode, false /*isFirst*/);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import isHTMLTableCellElement from '../typeUtils/isHTMLTableCellElement';\r\nimport isHTMLTableElement from '../typeUtils/isHTMLTableElement';\r\nimport { TableFormat, TableOperation } from 'roosterjs-editor-types';\r\nimport { toArray } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Represent a virtual cell of a virtual table\r\n */\r\nexport interface VCell {\r\n    /**\r\n     * The table cell object. The value will be null if this is an expanded virtual cell\r\n     */\r\n    td?: HTMLTableCellElement;\r\n\r\n    /**\r\n     * Whether this cell is spanned from left\r\n     */\r\n    spanLeft?: boolean;\r\n\r\n    /**\r\n     * Whether this cell is spanned from above\r\n     */\r\n    spanAbove?: boolean;\r\n}\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = isHTMLTableElement(node) ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = isHTMLTableElement(node) ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (isHTMLTableCellElement(newNode)) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLTableCellElement\n * @param obj The object to check\n */\nexport default function isHTMLTableCellElement(obj: any): obj is HTMLTableCellElement {\n    return safeInstanceOf(obj as Node, 'HTMLTableCellElement');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLTableElement\n * @param obj The object to check\n */\nexport default function isHTMLTableElement(obj: any): obj is HTMLTableElement {\n    return safeInstanceOf(obj as Node, 'HTMLTableElement');\n}\n","import changeElementTag from '../utils/changeElementTag';\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport isNodeEmpty from '../utils/isNodeEmpty';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport splitParentNode from '../utils/splitParentNode';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport VListItem from './VListItem';\nimport wrap from '../utils/wrap';\nimport {\n    Indentation,\n    ListType,\n    NodePosition,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * Represent a bullet or a numbering list\n *\n * @example\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\n * e.g. We have a list like this\n * ```html\n * <ol>\n *   <li>item 1</li>\n *   <li>item 2</li>\n *   <ul>\n *     <li>item 2.1</li>\n *     <li>item 2.2</li>\n *   <ul>\n * </ol>\n * ```\n *\n * A VList of this list will be like this:\n * ```javascript\n * {\n *   rootList: (OL node),\n *   items: [{\n *       node: (LI node with 'item 1'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2'),\n *       listTypes: [null, OL],\n *     }, {\n *       node: (LI node with 'item 2.1),\n *       listTypes: [null, OL, UL],\n *     }, {\n *       node: (LI node with 'item 2.2'),\n *       listTypes: [null, OL, UL],\n *     }\n *   ]\n * }\n * ```\n *\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\n * the writeBack() function will handle everything related to DOM change\n */\nexport default class VList {\n    private items: VListItem[] = [];\n\n    /**\n     * Create a new instance of VList class\n     * @param rootList The root list element, can be either OL or UL tag\n     */\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\n        if (!rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\n        // otherwise further action may mass thing up.\n        //\n        // There are two kinds of normalization to perform.\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\n        // e.g.:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>item 2</div>\n        // </ol>\n        // ```\n        // After this step, it should become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>item 2</div>\n        //   <li>\n        // </ol>\n        // ```\n        moveChildNodesToLi(this.rootList);\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\n\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\n        // step 1, it is possible that we move some LI node into another one. e.g:\n        // ```HTML\n        // <ol>\n        //   <li>item 1</li>\n        //   <div>\n        //     item 1.1\n        //     <li>item 3</li>\n        //   </div>\n        // </ol>\n        // ```\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\n        // ```html\n        // <ol>\n        //   <li>item 1\n        //     <div>\n        //       item 1.1\n        //       <li>item 2</li>\n        //     </div>\n        //   <li>\n        // </ol>\n        // ```\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\n        // ```html\n        // <ol>\n        //   <li>item1\n        //     <div>item 1.1</div>\n        //   </li>\n        //   <li><div>item2</div></li>\n        // </ol>\n        // ```\n        queryElements(this.rootList, 'li', moveLiToList);\n\n        this.populateItems(this.rootList);\n    }\n\n    /**\n     * Check if this list contains the given node\n     * @param node The node to check\n     */\n    contains(node: Node) {\n        // We don't check if the node is contained by this.rootList here, because after some operation,\n        // it is possible a node is logically contained by this list but the container list item hasn't\n        // been put under this.rootList in DOM tree yet.\n        return this.items.some(item => item.contains(node));\n    }\n\n    /**\n     * Get the first or last node of this list\n     * @param isLast true to get last node, false to get first node\n     */\n    getFirstOrLastNode(isLast: boolean): Node {\n        const item = this.items[isLast ? this.items.length - 1 : 0];\n        return item?.getNode();\n    }\n\n    /**\n     * Write the result back into DOM tree\n     * After that, this VList becomes unavailable because we set this.rootList to null\n     */\n    writeBack() {\n        if (!this.rootList) {\n            throw new Error('rootList must not be null');\n        }\n\n        const listStack: Node[] = [this.rootList.ownerDocument.createDocumentFragment()];\n\n        this.items.forEach(item => item.writeBack(listStack));\n        this.rootList.parentNode.replaceChild(listStack[0], this.rootList);\n\n        // Set rootList to null to avoid this to be called again for the same VList, because\n        // after change the rootList may not be available any more (e.g. outdent all items).\n        this.rootList = null;\n    }\n\n    /**\n     * Set indentation of the given range of this list\n     * @param start Start position to operate from\n     * @param end End positon to operate to\n     * @param indentation Indent or outdent\n     */\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation) {\n        this.findListItems(start, end, item =>\n            indentation == Indentation.Decrease ? item.outdent() : item.indent()\n        );\n    }\n\n    /**\n     * Change list type of the given range of this list.\n     * If some of the items are not real list item yet, this will make them to be list item with given type\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\n     * @param start Start position to operate from\n     * @param end End position to operate to\n     * @param targetType Target list type\n     */\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\n        let needChangeType = false;\n\n        this.findListItems(start, end, item => {\n            needChangeType = needChangeType || item.getListType() != targetType;\n        });\n        this.findListItems(start, end, item =>\n            needChangeType ? item.changeListType(targetType) : item.outdent()\n        );\n    }\n\n    /**\n     * Append a new item to this VList\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\n     * @param type Type of this list item, can be ListType.None\n     */\n    appendItem(node: Node, type: ListType) {\n        let newListNode = node;\n        const nodeTag = getTagOfNode(node);\n\n        if (nodeTag != 'LI' && nodeTag != 'TABLE') {\n            newListNode = changeElementTag(<HTMLElement>node, 'LI');\n        } else if (nodeTag == 'TABLE') {\n            newListNode = wrap(node, 'li');\n        }\n\n        this.items.push(\n            type == ListType.None ? new VListItem(newListNode) : new VListItem(newListNode, type)\n        );\n    }\n\n    /**\n     * Merge the given VList into current VList.\n     * - All list items will be removed from the given VList and added into this list.\n     * - The root node of the given VList will be removed from DOM tree\n     * - If there are orphan items in the given VList, they will be merged into the last item\n     *   of this list if any.\n     * @param list The vList to merge from\n     */\n    mergeVList(list: VList) {\n        if (list && list != this) {\n            const originalLength = this.items.length;\n            list.items.forEach(item => this.items.push(item));\n            list.items.splice(0, list.items.length);\n\n            this.mergeOrphanNodesAfter(originalLength - 1);\n            list.rootList.parentNode?.removeChild(list.rootList);\n        }\n    }\n\n    private mergeOrphanNodesAfter(startIndex: number) {\n        const item = this.items[startIndex];\n\n        if (item && !item.isOrphanItem()) {\n            for (let i = startIndex + 1; i <= this.items.length; i++) {\n                if (!item || !item.canMerge(this.items[i])) {\n                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));\n                    break;\n                }\n            }\n        }\n    }\n\n    private findListItems(\n        start: NodePosition,\n        end: NodePosition,\n        callback?: (item: VListItem) => any\n    ): VListItem[] {\n        if (this.items.length == 0) {\n            return [];\n        }\n\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\n        const listEndPos = new Position(\n            this.items[this.items.length - 1].getNode(),\n            PositionType.End\n        );\n\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\n\n        this.items.forEach((item, index) => {\n            startIndex = item.contains(start.node) ? index : startIndex;\n            endIndex = item.contains(end.node) ? index : endIndex;\n        });\n\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\n\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\n\n        if (callback) {\n            result.forEach(callback);\n            this.mergeOrphanNodesAfter(endIndex);\n        }\n\n        return result;\n    }\n\n    private populateItems(\n        list: HTMLOListElement | HTMLUListElement,\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\n    ) {\n        const type = getListTypeFromNode(list);\n\n        for (let item = list.firstChild; !!item; item = item.nextSibling) {\n            const newListTypes = [...listTypes, type];\n\n            if (isListElement(item)) {\n                this.populateItems(item as HTMLOListElement | HTMLUListElement, newListTypes);\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\n                this.items.push(new VListItem(item, ...newListTypes));\n            }\n        }\n    }\n}\n\n//Normalization\n\n// Step 1: Move all non-LI direct children under list into LI\n// e.g.\n// From: <ul><li>line 1</li>line 2</ul>\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\n    let currentItem: HTMLLIElement = null;\n\n    toArray(list.childNodes).forEach(child => {\n        if (getTagOfNode(child) == 'LI') {\n            currentItem = child as HTMLLIElement;\n        } else if (isListElement(child)) {\n            currentItem = null;\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\n        }\n    });\n}\n\n// Step 2: Move nested LI up to under list directly\n// e.g.\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\nfunction moveLiToList(li: HTMLLIElement) {\n    while (!isListElement(li.parentNode)) {\n        splitParentNode(li, true /*splitBefore*/);\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\n\n        if (furtherNodes.length > 0) {\n            if (!isBlockElement(furtherNodes[0])) {\n                furtherNodes = [wrap(furtherNodes)];\n            }\n            furtherNodes.forEach(node => li.appendChild(node));\n        }\n\n        unwrap(li.parentNode);\n    }\n}\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\nimport createRange from '../selection/createRange';\nimport Position from '../selection/Position';\nimport { BlockElement, Region } from 'roosterjs-editor-types';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\n\n/**\n * Get all block elements covered by the selection under this region\n */\nexport default function getSelectedBlockElementsInRegion(region: Region): BlockElement[] {\n    if (!region) {\n        return [];\n    }\n\n    const {\n        nodeBefore,\n        nodeAfter,\n        rootNode,\n        skipTags,\n        fullSelectionEnd,\n        fullSelectionStart,\n    } = region;\n    const startNode = nodeBefore\n        ? getNextLeafSibling(region.rootNode, nodeBefore, region.skipTags)\n        : rootNode.firstChild;\n    const endNode = nodeAfter\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\n        : rootNode.lastChild;\n    const blocks: BlockElement[] = [];\n\n    if (startNode && endNode) {\n        const regionRange = createRange(startNode, endNode);\n        const regionStart = Position.getStart(regionRange).normalize();\n        const regionEnd = Position.getEnd(regionRange).normalize();\n\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\n            const start = fullSelectionStart.isAfter(regionStart)\n                ? fullSelectionStart\n                : regionStart;\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\n\n            const range = createRange(start, end);\n            const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\n\n            for (\n                let block = traverser?.currentBlockElement;\n                !!block;\n                block = traverser.getNextBlockElement()\n            ) {\n                blocks.push(block);\n            }\n        }\n    }\n\n    return blocks;\n}\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: HTMLElement, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: HTMLElement): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\n\n// Inheritable CSS properties\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\nconst INHERITABLE_PROPERTIES = (\n    'border-spacing,caption-side,color,' +\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\n    'widows,word-spacing'\n).split(',');\n\n/**\n * Get inheritable CSS style values from the given element\n * @param element The element to get style from\n */\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\n    let styles = win && win.getComputedStyle(element);\n    let result: StringMap = {};\n    INHERITABLE_PROPERTIES.forEach(\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\n    );\n    return result;\n}\n","const START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\n\n/**\n * Build DOM tree from the given HTML string\n * @param html Source HTML string\n * @param preserveFragmentOnly If there is fragment markup (&lt;!--StartFragment--&gt; and &lt;!--EndFragment--&gt;),\n * only preserve content between these markups\n * @param fragmentHandler An optional callback to do customized fragment handling\n */\nexport default function htmlToDom(\n    html: string,\n    preserveFragmentOnly: boolean,\n    fragmentHandler?: (doc: HTMLDocument, sourceHtml: string) => void\n): HTMLDocument {\n    let parser = new DOMParser();\n    let doc = parser.parseFromString(html || '', 'text/html');\n\n    if (doc && doc.body && doc.body.firstChild) {\n        // 1. Filter out html code outside of Fragment tags if need\n        if (preserveFragmentOnly) {\n            (fragmentHandler || defaultFragmentTrimmer)(doc, html);\n        }\n\n        return doc;\n    } else {\n        return null;\n    }\n}\n\nfunction defaultFragmentTrimmer(doc: HTMLDocument, sourceHtml: string) {\n    let [html] = splitWithFragment(sourceHtml);\n    doc.body.innerHTML = html;\n}\n\n/**\n * Split the HTML string using its fragment info\n * @param html Source html string\n * @returns [String within fragment, String before fragment, String after fragment]\n */\nexport function splitWithFragment(html: string): [string, string, string] {\n    let startIndex = html.indexOf(START_FRAGMENT);\n    let endIndex = html.lastIndexOf(END_FRAGMENT);\n    if (startIndex >= 0 && endIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n        let before = html.substr(0, startIndex);\n        let after = html.substr(endIndex + END_FRAGMENT.length);\n        html = html.substring(startIndex + START_FRAGMENT.length, endIndex);\n        return [html, before, after];\n    } else {\n        return [html, null, null];\n    }\n}\n","function nativeClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    return Object.assign(existingObj || {}, source);\n}\n\nfunction customClone<T>(\n    source: Record<string, T>,\n    existingObj?: Record<string, T>\n): Record<string, T> {\n    let result: Record<string, T> = existingObj || {};\n    if (source) {\n        for (let key of Object.keys(source)) {\n            result[key] = source[key];\n        }\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nexport const cloneObject = Object.assign ? nativeClone : customClone;\n","import { BlockElement, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, StartEndBlockElement } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocked(\r\n    editor: Editor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        block instanceof StartEndBlockElement &&\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsb = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: Editor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: Editor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: Editor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset.ogsc = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import normalizeContentColor from '../darkMode/normalizeContentColor';\r\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n// TODO: Rename to DarkmodePlugin in next major release\r\n/**\r\n * Copy plugin, hijacks copy events to normalize the content to the clipboard.\r\n */\r\nexport default class CopyPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private eventDisposer: () => void;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Copy';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.eventDisposer = editor.addDomEventHandler({\r\n            copy: this.onExtract(false),\r\n            cut: this.onExtract(true),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.eventDisposer();\r\n        this.eventDisposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onExtract = (isCut: boolean) => (event: Event) => {\r\n        // if it's dark mode...\r\n        if (this.editor && this.editor.isDarkMode()) {\r\n            // get whatever the current selection range is\r\n            const selectionRange = this.editor.getSelectionRange();\r\n            if (selectionRange && !selectionRange.collapsed) {\r\n                const clipboardEvent = event as ClipboardEvent;\r\n                const copyFragment = this.editor.getSelectionRange().cloneContents();\r\n\r\n                const containerDiv = this.editor.getDocument().createElement('div');\r\n\r\n                // Leverage script execution policy on CEDs to try and prevent XSS\r\n                containerDiv.contentEditable = 'true';\r\n                containerDiv.appendChild(copyFragment);\r\n\r\n                // revert just this selected range to light mode colors\r\n                normalizeContentColor(containerDiv);\r\n\r\n                // put it on the clipboard\r\n                clipboardEvent.clipboardData.setData('text/html', containerDiv.innerHTML);\r\n                clipboardEvent.clipboardData.setData('text/plain', containerDiv.innerText);\r\n\r\n                // if it's cut, delete the contents\r\n                if (isCut) {\r\n                    this.editor.getSelectionRange().deleteContents();\r\n                }\r\n\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    };\r\n}\r\n","import { toArray } from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport default function normalizeContentColor(root: HTMLElement) {\n    const allChildElements = root.getElementsByTagName('*');\n    toArray(allChildElements).forEach(e => {\n        const element = e as HTMLElement;\n        if (element.dataset) {\n            // Reset color styles based on the content of the ogsc/ogsb data element.\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\n            element.style.color = isDataAttributeSettable(element.dataset.ogsc)\n                ? element.dataset.ogsc\n                : '';\n            element.style.backgroundColor = isDataAttributeSettable(element.dataset.ogsb)\n                ? element.dataset.ogsb\n                : '';\n\n            // Some elements might have set attribute colors. We need to reset these as well.\n            if (isDataAttributeSettable(element.dataset.ogac)) {\n                element.setAttribute('color', element.dataset.ogac);\n            } else {\n                element.removeAttribute('color');\n            }\n\n            if (isDataAttributeSettable(element.dataset.ogab)) {\n                element.setAttribute('bgcolor', element.dataset.ogab);\n            } else {\n                element.removeAttribute('bgcolor');\n            }\n\n            // Clean up any remaining data attributes.\n            if (element.dataset.ogsc) {\n                delete element.dataset.ogsc;\n            }\n\n            if (element.dataset.ogsb) {\n                delete element.dataset.ogsb;\n            }\n\n            if (element.dataset.ogac) {\n                delete element.dataset.ogac;\n            }\n\n            if (element.dataset.ogab) {\n                delete element.dataset.ogab;\n            }\n        }\n    });\n}\n\nfunction isDataAttributeSettable(newStyle: string) {\n    return newStyle && newStyle != 'undefined' && newStyle != 'null';\n}\n","import Editor from '../editor/Editor';\nimport EditorPlugin from '../interfaces/EditorPlugin';\nimport { ClipboardData, ClipboardItems, ContentPosition } from 'roosterjs-editor-types';\nimport { extractClipboardEvent, fromHtml } from 'roosterjs-editor-dom';\n\nconst CONTAINER_HTML =\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\n\n/**\n * Core paste plugin for handling onPaste event and extract the pasted content\n */\nexport default class CorePastePlugin implements EditorPlugin {\n    private editor: Editor;\n    private disposer: () => void;\n\n    getName() {\n        return 'CorePaste';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler('paste', this.onPaste);\n    }\n\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    private onPaste = (event: Event) => {\n        extractClipboardEvent(event as ClipboardEvent, items => {\n            if (items.html === undefined) {\n                // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\n                // This is mostly for IE\n                const originalSelectionRange = this.editor.getSelectionRange();\n                const tempDiv = this.editor.getCustomData(\n                    'PasteDiv',\n                    this.createTempDivForIE,\n                    pasteDiv => pasteDiv.parentNode.removeChild(pasteDiv)\n                );\n                tempDiv.style.display = '';\n                tempDiv.focus();\n\n                this.editor.runAsync(() => {\n                    // restore original selection range in editor\n                    this.editor.select(originalSelectionRange);\n                    items.html = tempDiv.innerHTML;\n                    tempDiv.style.display = 'none';\n                    tempDiv.innerHTML = '';\n                    this.paste(items);\n                });\n            } else {\n                this.paste(items);\n            }\n        });\n    };\n\n    private paste(items: ClipboardItems) {\n        const clipboardData: ClipboardData = {\n            types: items.types,\n            image: items.image,\n            text: items.text,\n            rawHtml: items.html,\n\n            // Will be set later\n            snapshotBeforePaste: null,\n            imageDataUri: null,\n\n            // TODO: deprecated properties\n            html: null,\n            originalFormat: null,\n        };\n\n        if (clipboardData.image) {\n            const reader = new FileReader();\n            reader.onload = () => {\n                clipboardData.imageDataUri = reader.result as string;\n                this.editor.paste(clipboardData);\n            };\n            reader.onerror = () => {\n                clipboardData.image = null;\n                this.editor.paste(clipboardData);\n            };\n            reader.readAsDataURL(clipboardData.image);\n        } else {\n            this.editor.paste(clipboardData);\n        }\n    }\n\n    private createTempDivForIE = () => {\n        const pasteDiv = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\n        this.editor.insertNode(pasteDiv, {\n            position: ContentPosition.Outside,\n        });\n        return pasteDiv;\n    };\n}\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport {\r\n    Browser,\r\n    getPendableFormatState,\r\n    Position,\r\n    PendableFormatNames,\r\n    PendableFormatCommandMap,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    PluginEventType,\r\n    NodePosition,\r\n    PendableFormatState,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * DOMEventPlugin handles customized DOM events, including:\r\n * 1. IME state management\r\n * 2. Selection management\r\n * 3. Cut and Drop management\r\n * 4. Pending format state management\r\n * 5. Scroll container and scroll event management\r\n */\r\nexport default class DOMEventPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private inIme = false;\r\n    private disposer: () => void;\r\n    private cachedPosition: NodePosition;\r\n    private cachedFormatState: PendableFormatState;\r\n\r\n    constructor(private disableRestoreSelectionOnFocus: boolean) {}\r\n\r\n    getName() {\r\n        return 'DOMEvent';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n\r\n        this.disposer = editor.addDomEventHandler({\r\n            // 1. IME state management\r\n            compositionstart: () => (this.inIme = true),\r\n            compositionend: (rawEvent: CompositionEvent) => {\r\n                this.inIme = false;\r\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\r\n                    rawEvent,\r\n                });\r\n            },\r\n\r\n            // 2. Cut and drop management\r\n            drop: this.onNativeEvent,\r\n            cut: this.onNativeEvent,\r\n\r\n            // 3. Selection mangement\r\n            focus: this.onFocus,\r\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\r\n        });\r\n\r\n        this.editor.getScrollContainer().addEventListener('scroll', this.onScroll);\r\n    }\r\n\r\n    dispose() {\r\n        this.editor.getScrollContainer().removeEventListener('scroll', this.onScroll);\r\n\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.PendingFormatStateChanged:\r\n                // Got PendingFormatStateChagned event, cache current position and pending format\r\n                this.cachedPosition = this.getCurrentPosition();\r\n                this.cachedFormatState = event.formatState;\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.ContentChanged:\r\n                // If content or position is changed (by keyboard, mouse, or code),\r\n                // check if current position is still the same with the cached one (if exist),\r\n                // and clear cached format if position is changed since it is out-of-date now\r\n                if (\r\n                    this.cachedPosition &&\r\n                    !this.cachedPosition.equalTo(this.getCurrentPosition())\r\n                ) {\r\n                    this.clear();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore cached pending format state (if exist) to current selection\r\n     */\r\n    public restorePendingFormatState() {\r\n        if (this.cachedFormatState) {\r\n            let formatState = getPendableFormatState(this.editor.getDocument());\r\n            (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\r\n                if (this.cachedFormatState[key] != formatState[key]) {\r\n                    this.editor\r\n                        .getDocument()\r\n                        .execCommand(PendableFormatCommandMap[key], false, null);\r\n                }\r\n            });\r\n            this.cachedPosition = this.getCurrentPosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME() {\r\n        return this.inIme;\r\n    }\r\n\r\n    private onNativeEvent = (e: UIEvent) => {\r\n        this.editor.runAsync(() => {\r\n            this.editor.addUndoSnapshot(\r\n                () => {},\r\n                e.type == 'cut' ? ChangeSource.Cut : ChangeSource.Drop\r\n            );\r\n        });\r\n    };\r\n\r\n    private onFocus = () => {\r\n        if (this.disableRestoreSelectionOnFocus) {\r\n            if (this.cachedPosition && this.cachedFormatState) {\r\n                let range = this.editor.getSelectionRange();\r\n                if (\r\n                    range.collapsed &&\r\n                    Position.getStart(range).normalize().equalTo(this.cachedPosition)\r\n                ) {\r\n                    this.restorePendingFormatState();\r\n                } else {\r\n                    this.clear();\r\n                }\r\n            }\r\n        } else {\r\n            this.editor.restoreSavedRange();\r\n        }\r\n    };\r\n\r\n    private onBlur = () => {\r\n        this.editor.saveSelectionRange();\r\n    };\r\n\r\n    private onScroll = (e: UIEvent) => {\r\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\r\n            rawEvent: e,\r\n            scrollContainer: this.editor.getScrollContainer(),\r\n        });\r\n    };\r\n\r\n    private clear() {\r\n        this.cachedPosition = null;\r\n        this.cachedFormatState = null;\r\n    }\r\n\r\n    private getCurrentPosition() {\r\n        let range = this.editor.getSelectionRange();\r\n        return range && Position.getStart(range).normalize();\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport isCtrlOrMetaPressed from '../eventApi/isCtrlOrMetaPressed';\r\nimport { GenericContentEditFeature, Keys } from '../interfaces/ContentEditFeature';\r\nimport {\r\n    ChangeSource,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Edit Component helps handle Content edit features\r\n */\r\nexport default class EditPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n    private featureMap: { [key: number]: GenericContentEditFeature<PluginEvent>[] } = {};\r\n\r\n    private autoCompleteSnapshot: string = null;\r\n    private autoCompleteChangeSource: string = null;\r\n\r\n    getName() {\r\n        return 'Edit';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n        this.addFeature({\r\n            keys: [Keys.BACKSPACE],\r\n            shouldHandleEvent: () => this.autoCompleteSnapshot !== null,\r\n            handleEvent: (event: PluginKeyboardEvent, editor: Editor) => {\r\n                event.rawEvent.preventDefault();\r\n                editor.setContent(this.autoCompleteSnapshot, false /*triggerContentChangedEvent*/);\r\n            },\r\n        });\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        let contentChanged = false;\r\n        let currentFeature = this.findFeature(event);\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                contentChanged = this.autoCompleteChangeSource != event.source;\r\n                break;\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.KeyDown:\r\n                contentChanged = true;\r\n                break;\r\n        }\r\n\r\n        if (currentFeature) {\r\n            currentFeature.handleEvent(event, this.editor);\r\n        }\r\n\r\n        if (contentChanged) {\r\n            this.autoCompleteSnapshot = null;\r\n            this.autoCompleteChangeSource = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature\r\n     * @param feature The feature to add\r\n     */\r\n    addFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature.keys.forEach(key => {\r\n            let array = this.featureMap[key] || [];\r\n            array.push(feature);\r\n            this.featureMap[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.editor.addUndoSnapshot((start, end, snapshot) => {\r\n            let data = callback();\r\n            this.autoCompleteSnapshot = snapshot;\r\n            this.autoCompleteChangeSource = changeSource;\r\n            return data;\r\n        }, changeSource);\r\n    }\r\n\r\n    private findFeature(event: PluginEvent) {\r\n        let hasFunctionKey = false;\r\n        let features: GenericContentEditFeature<PluginEvent>[];\r\n        let ctrlOrMeta = false;\r\n\r\n        if (event.eventType == PluginEventType.KeyDown) {\r\n            let rawEvent = event.rawEvent;\r\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\r\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\r\n            features = this.featureMap[rawEvent.which];\r\n        } else if (event.eventType == PluginEventType.ContentChanged) {\r\n            features = this.featureMap[Keys.CONTENTCHANGED];\r\n        }\r\n        return (\r\n            features &&\r\n            features.filter(\r\n                feature =>\r\n                    (feature.allowFunctionKeys || !hasFunctionKey) &&\r\n                    feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\r\n            )[0]\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { Browser, LinkInlineElement, Position } from 'roosterjs-editor-dom';\r\nimport { cacheGetContentSearcher } from '../eventApi/cacheGetContentSearcher';\r\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * FirefoxTypeAfterLink Component helps handle typing event when cursor is right after a link.\r\n * When typing/pasting after a link, browser may put the new charactor inside link.\r\n * This plugin overrides this behavior to always insert outside of link.\r\n *\r\n * TODO: Rename this file in next major release since it is not only applied to Firefox now\r\n */\r\nexport default class FirefoxTypeAfterLink implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'FirefoxTypeAfterLink';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\r\n            event.eventType == PluginEventType.BeforePaste\r\n        ) {\r\n            let range = this.editor.getSelectionRange();\r\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\r\n                let searcher = cacheGetContentSearcher(event, this.editor);\r\n                let inlineElement = searcher.getInlineElementBefore();\r\n                if (inlineElement instanceof LinkInlineElement) {\r\n                    this.editor.select(\r\n                        new Position(inlineElement.getContainerNode(), PositionType.After)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport clearEventDataCache from './clearEventDataCache';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\nconst CONTENTSEARCHER_KEY = 'CONTENTSEARCHER';\r\n\r\n/**\r\n * Try get existing PositionContentSearcher from an event. If there isn't one, create a new one from editor.\r\n * @param event The plugin event, it stores the event cached data for looking up.\r\n * If passed as null, we will create a new PositionContentSearcher\r\n * @param editor The editor instance\r\n * @returns The PositionContentSearcher object\r\n */\r\nexport function cacheGetContentSearcher(\r\n    event: PluginEvent,\r\n    editor: Editor\r\n): PositionContentSearcher {\r\n    return cacheGetEventData(event, CONTENTSEARCHER_KEY, () => editor.getContentSearcherOfCursor());\r\n}\r\n\r\n/**\r\n * Clear the PositionContentSearcher in a plugin event.\r\n * This is called when the content is changed\r\n * @param event The plugin event\r\n */\r\nexport function clearContentSearcherCache(event: PluginEvent) {\r\n    clearEventDataCache(event, CONTENTSEARCHER_KEY);\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear a cached object by its key from an event object\r\n * @param event The event object\r\n * @param key The cache key\r\n */\r\nexport default function clearEventDataCache(event: PluginEvent, key: string): void {\r\n    if (event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)) {\r\n        delete event.eventDataCache[key];\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * MouseUp Component helps handle mouse up event\r\n * this can trigger mouse up event after mousedown happens in editor\r\n * even mouse up is happening outside editor\r\n */\r\nexport default class MouseUpPlugin implements EditorPlugin {\r\n    private mouseUpEventListerAdded: boolean;\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'MouseUp';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.removeMouseUpEventListener();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\r\n            this.editor\r\n                .getDocument()\r\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\r\n            this.mouseUpEventListerAdded = true;\r\n        }\r\n    }\r\n\r\n    private removeMouseUpEventListener() {\r\n        if (this.mouseUpEventListerAdded) {\r\n            this.mouseUpEventListerAdded = false;\r\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private onMouseUp = (rawEvent: MouseEvent) => {\r\n        if (this.editor) {\r\n            this.removeMouseUpEventListener();\r\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\r\n                rawEvent,\r\n            });\r\n        }\r\n    };\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport {\r\n    applyFormat,\r\n    Browser,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    isNode,\r\n    isNodeEmpty,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ContentPosition,\r\n    NodePosition,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    PluginEvent,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Typing Component helps to ensure typing is always happening under a DOM container\r\n */\r\nexport default class TypeInContainerPlugin implements EditorPlugin {\r\n    private editor: Editor;\r\n\r\n    getName() {\r\n        return 'TypeInContainer';\r\n    }\r\n\r\n    initialize(editor: Editor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyPress) {\r\n            this.onKeyPress(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure we are typing in an HTML Element inside editor, and apply default format if current block is empty\r\n     * @param node Current node\r\n     * @param event (optional) The keyboard event that we are ensuring is typing in an element.\r\n     * @returns A new position to select\r\n     */\r\n    ensureTypeInElement(position: NodePosition, event?: PluginKeyboardEvent): NodePosition {\r\n        let result = position.normalize();\r\n        let block = this.editor.getBlockElementAtNode(result.node);\r\n        let formatNode: HTMLElement;\r\n\r\n        if (block) {\r\n            formatNode = block.collapseToSingleElement();\r\n\r\n            // if the block is empty, apply default format\r\n            // Otherwise, leave it as it is as we don't want to change the style for existing data\r\n            // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\r\n            const shouldSetNodeStyles =\r\n                isNodeEmpty(formatNode) ||\r\n                (event && this.wasNodeJustCreatedByKeyboardEvent(event, formatNode));\r\n            formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\r\n        } else {\r\n            // Only reason we don't get the selection block is that we have an empty content div\r\n            // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\r\n            // The fix is to add a DIV wrapping, apply default format and move cursor over\r\n            formatNode = fromHtml(\r\n                Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\r\n                this.editor.getDocument()\r\n            )[0] as HTMLElement;\r\n            this.editor.insertNode(formatNode, {\r\n                position: ContentPosition.End,\r\n                updateCursor: false,\r\n                replaceSelection: false,\r\n                insertOnNewLine: false,\r\n            });\r\n\r\n            // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\r\n            result = new Position(formatNode.firstChild, PositionType.Begin);\r\n        }\r\n\r\n        if (formatNode) {\r\n            applyFormat(formatNode, this.editor.getDefaultFormat(), this.editor.isDarkMode());\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private onKeyPress(event: PluginKeyboardEvent) {\r\n        // If normalization was not possible before the keypress,\r\n        // check again after the keyboard event has been processed by browser native behaviour.\r\n        //\r\n        // This handles the case where the keyboard event that first inserts content happens when\r\n        // there is already content under the selection (e.g. Ctrl+a -> type new content).\r\n        //\r\n        // Only scheudle when the range is not collapsed to catch this edge case.\r\n        let range = this.editor.getSelectionRange();\r\n\r\n        if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\r\n            return;\r\n        }\r\n\r\n        if (range.collapsed) {\r\n            this.tryNormalizeTyping(event, range);\r\n        } else if (!range.collapsed) {\r\n            this.editor.runAsync(() => {\r\n                this.tryNormalizeTyping(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When typing goes directly under content div, many things can go wrong\r\n     * We fix it by wrapping it with a div and reposition cursor within the div\r\n     */\r\n    private tryNormalizeTyping(event: PluginKeyboardEvent, range?: Range) {\r\n        let position = this.ensureTypeInElement(\r\n            Position.getStart(range || this.editor.getSelectionRange()),\r\n            event\r\n        );\r\n        this.editor.select(position);\r\n    }\r\n\r\n    private wasNodeJustCreatedByKeyboardEvent(event: PluginKeyboardEvent, formatNode: HTMLElement) {\r\n        return (\r\n            isNode(event.rawEvent.target) &&\r\n            event.rawEvent.target.contains(formatNode) &&\r\n            event.rawEvent.key === formatNode.innerText\r\n        );\r\n    }\r\n}\r\n","import Editor from '../editor/Editor';\r\nimport isCtrlOrMetaPressed from '../eventApi/isCtrlOrMetaPressed';\r\nimport UndoService from '../interfaces/UndoService';\r\nimport UndoSnapshots from './UndoSnapshots';\r\nimport UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_DELETE = 46;\r\nconst KEY_SPACE = 32;\r\nconst KEY_ENTER = 13;\r\nconst KEY_PAGEUP = 33;\r\nconst KEY_DOWN = 40;\r\n\r\n/**\r\n * Provides snapshot based undo service for Editor\r\n */\r\nexport default class Undo implements UndoService {\r\n    private editor: Editor;\r\n    private isRestoring: boolean;\r\n    private hasNewContent: boolean;\r\n    private lastKeyPress: number;\r\n\r\n    protected undoSnapshots: UndoSnapshotsService;\r\n\r\n    /**\r\n     * Create an instance of Undo\r\n     * @param preserveSnapshots True to preserve the snapshots after dispose, this allows\r\n     * this object to be reused when editor is disposed and created again\r\n     * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB\r\n     */\r\n    constructor(private preserveSnapshots?: boolean, private maxBufferSize: number = 1e7) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Undo';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: Editor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n\r\n        if (!this.preserveSnapshots) {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        // if editor is in IME, don't do anything\r\n        if (this.editor.isInIME()) {\r\n            return;\r\n        }\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.EditorReady:\r\n                if (!this.preserveSnapshots || (!this.canUndo() && !this.canRedo())) {\r\n                    // Only add initial snapshot when we don't need to preserve snapshots or there is no existing snapshot\r\n                    // Otherwise preserved undo/redo state may be ruined\r\n                    this.addUndoSnapshot();\r\n                }\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.onKeyDown(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyPress:\r\n                this.onKeyPress(event.rawEvent);\r\n                break;\r\n            case PluginEventType.CompositionEnd:\r\n                this.clearRedoForInput();\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                if (!this.isRestoring) {\r\n                    this.clearRedoForInput();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all existing undo snapshots\r\n     */\r\n    public clear() {\r\n        this.undoSnapshots = null;\r\n        this.hasNewContent = false;\r\n    }\r\n\r\n    /**\r\n     * Restore an undo snapshot to editor\r\n     */\r\n    public undo(): void {\r\n        if (this.hasNewContent) {\r\n            this.addUndoSnapshot();\r\n        }\r\n\r\n        this.restoreSnapshot(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Restore a redo snapshot to editor\r\n     */\r\n    public redo(): void {\r\n        this.restoreSnapshot(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for undo\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.hasNewContent || this.getSnapshotsManager().canMove(-1 /*previousSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Whether there is a snapshot for redo\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.getSnapshotsManager().canMove(1 /*nextSnapshot*/);\r\n    }\r\n\r\n    /**\r\n     * Add an undo snapshot\r\n     */\r\n    public addUndoSnapshot(): string {\r\n        let snapshot = this.editor.getContent(\r\n            false /*triggerExtractContentEvent*/,\r\n            true /* includeSelectionMarker */\r\n        );\r\n        this.getSnapshotsManager().addSnapshot(snapshot);\r\n        this.hasNewContent = false;\r\n        return snapshot;\r\n    }\r\n\r\n    protected getSnapshotsManager(): UndoSnapshotsService {\r\n        if (!this.undoSnapshots) {\r\n            this.undoSnapshots = new UndoSnapshots(this.maxBufferSize);\r\n        }\r\n        return this.undoSnapshots;\r\n    }\r\n\r\n    private restoreSnapshot(delta: number) {\r\n        let snapshot = this.getSnapshotsManager().move(delta);\r\n\r\n        if (snapshot != null) {\r\n            try {\r\n                this.isRestoring = true;\r\n                this.editor.setContent(snapshot);\r\n            } finally {\r\n                this.isRestoring = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDown(evt: KeyboardEvent): void {\r\n        // Handle backspace/delete when there is a selection to take a snapshot\r\n        // since we want the state prior to deletion restorable\r\n        if (evt.which == KEY_BACKSPACE || evt.which == KEY_DELETE) {\r\n            let selectionRange = this.editor.getSelectionRange();\r\n\r\n            // Add snapshot when\r\n            // 1. Something has been selected (not collapsed), or\r\n            // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\r\n            // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\r\n            if (\r\n                selectionRange &&\r\n                (!selectionRange.collapsed ||\r\n                    this.lastKeyPress != evt.which ||\r\n                    isCtrlOrMetaPressed(evt))\r\n            ) {\r\n                this.addUndoSnapshot();\r\n            }\r\n\r\n            // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\r\n            this.hasNewContent = true;\r\n            this.lastKeyPress = evt.which;\r\n        } else if (evt.which >= KEY_PAGEUP && evt.which <= KEY_DOWN) {\r\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\r\n            if (this.hasNewContent) {\r\n                this.addUndoSnapshot();\r\n            }\r\n            this.lastKeyPress = 0;\r\n        }\r\n    }\r\n\r\n    private onKeyPress(evt: KeyboardEvent): void {\r\n        if (evt.metaKey) {\r\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\r\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\r\n            return;\r\n        }\r\n\r\n        let range = this.editor.getSelectionRange();\r\n        if (\r\n            (range && !range.collapsed) ||\r\n            (evt.which == KEY_SPACE && this.lastKeyPress != KEY_SPACE) ||\r\n            evt.which == KEY_ENTER\r\n        ) {\r\n            this.addUndoSnapshot();\r\n            if (evt.which == KEY_ENTER) {\r\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\r\n                // we restore the snapshot before ENTER\r\n                this.hasNewContent = true;\r\n            }\r\n        } else {\r\n            this.clearRedoForInput();\r\n        }\r\n\r\n        this.lastKeyPress = evt.which;\r\n    }\r\n\r\n    private clearRedoForInput() {\r\n        this.getSnapshotsManager().clearRedo();\r\n        this.lastKeyPress = 0;\r\n        this.hasNewContent = true;\r\n    }\r\n}\r\n","import isModifierKey from './isModifierKey';\r\n\r\n/**\r\n * Returns true when the event was fired from a key that produces a character value, otherwise false\r\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n * So if we missed some case here it is still acceptable.\r\n * @param event The keyboard event object\r\n */\r\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\r\n    return !isModifierKey(event) && event.key && event.key.length == 1;\r\n}\r\n","const CTRL_CHARCODE = 'Control';\r\nconst ALT_CHARCODE = 'Alt';\r\nconst META_CHARCODE = 'Meta';\r\n\r\n/**\r\n * Returns true when the event was fired from a modifier key, otherwise false\r\n * @param event The keyboard event object\r\n */\r\nexport default function isModifierKey(event: KeyboardEvent): boolean {\r\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\r\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\r\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\r\n\r\n    return isCtrlKey || isAltKey || isMetaKey;\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\nimport { getComputedStyles } from 'roosterjs-editor-dom';\r\n\r\nconst DARK_MODE_DEFAULT_FORMAT = {\r\n    backgroundColors: {\r\n        darkModeColor: 'rgb(51,51,51)',\r\n        lightModeColor: 'rgb(255,255,255)',\r\n    },\r\n    textColors: {\r\n        darkModeColor: 'rgb(255,255,255)',\r\n        lightModeColor: 'rgb(0,0,0)',\r\n    },\r\n};\r\n\r\nexport function calculateDefaultFormat(\r\n    node: Node,\r\n    baseFormat: DefaultFormat,\r\n    inDarkMode: boolean\r\n): DefaultFormat {\r\n    if (inDarkMode) {\r\n        if (!baseFormat.backgroundColors) {\r\n            baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\r\n        }\r\n        if (!baseFormat.textColors) {\r\n            baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\r\n        }\r\n    }\r\n\r\n    if (baseFormat && Object.keys(baseFormat).length === 0) {\r\n        return {};\r\n    }\r\n\r\n    baseFormat = baseFormat || <DefaultFormat>{};\r\n    let {\r\n        fontFamily,\r\n        fontSize,\r\n        textColor,\r\n        textColors,\r\n        backgroundColor,\r\n        backgroundColors,\r\n        bold,\r\n        italic,\r\n        underline,\r\n    } = baseFormat;\r\n    let currentStyles =\r\n        fontFamily && fontSize && (textColor || textColors) ? null : getComputedStyles(node);\r\n    return {\r\n        fontFamily: fontFamily || currentStyles[0],\r\n        fontSize: fontSize || currentStyles[1],\r\n        get textColor() {\r\n            return textColors\r\n                ? inDarkMode\r\n                    ? textColors.darkModeColor\r\n                    : textColors.lightModeColor\r\n                : textColor || currentStyles[2];\r\n        },\r\n        textColors: textColors,\r\n        get backgroundColor() {\r\n            return backgroundColors\r\n                ? inDarkMode\r\n                    ? backgroundColors.darkModeColor\r\n                    : backgroundColors.lightModeColor\r\n                : backgroundColor || '';\r\n        },\r\n        backgroundColors: backgroundColors,\r\n        bold: bold,\r\n        italic: italic,\r\n        underline: underline,\r\n    };\r\n}\r\n","import EditorCore, { HasFocus } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Check if the editor has focus now\r\n * @param core The EditorCore object\r\n * @returns True if the editor has focus, otherwise false\r\n */\r\nexport const hasFocus: HasFocus = (core: EditorCore) => {\r\n    let activeElement = core.document.activeElement;\r\n    return (\r\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\r\n    );\r\n};\r\n","import { ChangeSource, NodePosition, Region } from 'roosterjs-editor-types';\nimport { Editor } from 'roosterjs-editor-core';\n\n/**\n * @internal\n * Split selection into regions, and perform a block-wise formatting action for each region.\n */\nexport default function blockFormat(\n    editor: Editor,\n    callback: (region: Region, start: NodePosition, end: NodePosition) => void\n) {\n    editor.focus();\n    editor.addUndoSnapshot((start, end) => {\n        const regions = editor.getSelectedRegions();\n        regions.forEach(region => callback(region, start, end));\n        editor.select(start, end);\n    }, ChangeSource.Format);\n}\n","import blockFormat from '../utils/blockFormat';\nimport { createVListFromRegion } from 'roosterjs-editor-dom';\nimport { Editor } from 'roosterjs-editor-core';\nimport { ListType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n */\nexport default function experimentToggleListType(editor: Editor, listType: ListType) {\n    blockFormat(editor, (region, start, end) => {\n        const vList = createVListFromRegion(region, true /*includeSiblingLists*/);\n        if (vList) {\n            vList.changeListType(start, end, listType);\n            vList.writeBack();\n        }\n    });\n}\n","import { ChangeSource, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    Browser,\r\n    fromHtml,\r\n    getTagOfNode,\r\n    Position,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst ZERO_WIDTH_SPACE = '&#8203;';\r\nconst UNWRAPPABLE_NODES = 'LI,THEAD,TBODY,TR,TD,TH'.split(',');\r\nconst DEFAULT_STYLER = (_: HTMLElement) => {};\r\n\r\n/**\r\n * Toggle a tag at selection, if selection already contains elements of such tag,\r\n * the elements will be untagge and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param tag The tag name\r\n * @param styler (Optional) The styler for setting the style for the blockquote element\r\n * @param wrapFunction (Optional) The wrap function\r\n * @param unwrapFunction (Optional) The unwrap function\r\n */\r\nexport default function toggleTagCore<T extends keyof HTMLElementTagNameMap>(\r\n    editor: Editor,\r\n    tag: T,\r\n    styler?: (element: HTMLElement) => void,\r\n    wrapFunction: (nodes: Node[]) => HTMLElement = nodes => wrap(nodes, tag),\r\n    unwrapFunction: (node: Node) => Node = unwrap\r\n): void {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let result: HTMLElement;\r\n        let range = editor.getSelectionRange();\r\n        if (\r\n            range &&\r\n            editor.queryElements(tag, QueryScope.OnSelection, unwrapFunction).length == 0\r\n        ) {\r\n            let startNode = Position.getStart(range).normalize().node;\r\n            let startBlock = editor.getBlockElementAtNode(startNode);\r\n            let endNode = Position.getEnd(range).normalize().node;\r\n            let endBlock = editor.getBlockElementAtNode(endNode);\r\n            let nodes =\r\n                startBlock && endBlock\r\n                    ? editor.collapseNodes(\r\n                          startBlock.getStartNode(),\r\n                          endBlock.getEndNode(),\r\n                          true /*canSplitParent*/\r\n                      )\r\n                    : [];\r\n\r\n            if (nodes.length == 0) {\r\n                // Selection is collapsed and blockElement is null, we need to create an empty div.\r\n                // In case of IE and Edge, we insert ZWS to put cursor in the div, otherwise insert BR node.\r\n                nodes = fromHtml(\r\n                    `<DIV>${Browser.isIEOrEdge ? ZERO_WIDTH_SPACE : '<BR>'}</DIV>`,\r\n                    editor.getDocument()\r\n                );\r\n                editor.insertNode(nodes[0]);\r\n                editor.select(nodes[0], PositionType.Begin);\r\n            } else if (nodes.length == 1) {\r\n                let tag = getTagOfNode(nodes[0]);\r\n                if (tag == 'BR') {\r\n                    nodes = [wrap(nodes[0])];\r\n                } else if (tag == 'LI' || tag == 'TD') {\r\n                    nodes = toArray(nodes[0].childNodes);\r\n                }\r\n            } else {\r\n                while (\r\n                    nodes[0] &&\r\n                    editor.contains(nodes[0].parentNode) &&\r\n                    nodes.some(node => UNWRAPPABLE_NODES.indexOf(getTagOfNode(node)) >= 0)\r\n                ) {\r\n                    nodes = [splitBalancedNodeRange(nodes)];\r\n                }\r\n            }\r\n\r\n            result = wrapFunction(nodes);\r\n            (styler || DEFAULT_STYLER)(result);\r\n        }\r\n\r\n        if (!editor.select(start, end) && result) {\r\n            editor.select(result);\r\n        }\r\n\r\n        return result;\r\n    }, ChangeSource.Format);\r\n}\r\n","import { NodeType } from 'roosterjs-editor-types';\n\n/** NodeId attribute */\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\n\n/**\n * @internal\n * Custom data for dom elements\n */\nexport default interface CustomData {\n    /** The dict storing custom data, key is element Id, value is dictionary */\n    dict: { [key: string]: { [key: string]: number } };\n\n    /** Next node Id to use */\n    nextNodeId: number;\n}\n\n/**\n * @internal\n * Create an empty CustomData\n */\nexport function createCustomData(): CustomData {\n    return {\n        dict: {},\n        nextNodeId: 1,\n    };\n}\n\n/**\n * @internal\n * Sets the specified object data\n */\nexport function setObject(customData: CustomData, element: Node, key: string, value: any) {\n    // Get the id for the element\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(customData, element as HTMLElement);\n        if (id != '') {\n            // Get the values for the element\n            if (!customData.dict[id]) {\n                // First time dictionary creation\n                customData.dict[id] = {};\n            }\n            customData.dict[id][key] = value;\n        }\n    }\n}\n\n/**\n * @internal\n * Reads the specified object data\n */\nexport function getObject(customData: CustomData, element: Node, key: string): any {\n    if (element.nodeType == NodeType.Element) {\n        let id = getAndSetNodeId(customData, element as HTMLElement);\n        if (id != '') {\n            return customData.dict[id] && customData.dict[id][key];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Get the unique id for the specified node...\n */\nfunction getAndSetNodeId(customData: CustomData, element: HTMLElement): string {\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\n    if (!id) {\n        id = customData.nextNodeId.toString();\n        customData.nextNodeId++;\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\n    }\n    return id;\n}\n","import ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Holds the ids for the lists already seen for a specified level\n */\nexport default interface LevelLists {\n    /**\n     * The metadata for the lists seen at  this level\n     * key: word list id, value: list metadata\n     */\n    listsMetadata: { [key: string]: ListMetadata };\n\n    /** Unique id of the list currently at this level */\n    currentUniqueListId: number;\n}\n\n/**\n * @internal\n * create an empty LevelLists\n */\nexport function createLevelLists(): LevelLists {\n    return {\n        listsMetadata: {},\n        currentUniqueListId: -1,\n    };\n}\n","/**\n * @internal\n */\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_UNORDERED_LIST_SELECTOR =\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\n\n/**\n * @internal\n */\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\n\n/**\n * @internal\n */\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\n\n/**\n * @internal\n */\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\n\n/**\n * @internal\n */\nexport const ORDERED_LIST_TAG_NAME = 'OL';\n\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\n\n/**\n * @internal\n */\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\n","import getEntityFromElement from './getEntityFromElement';\nimport { Editor } from 'roosterjs-editor-core';\nimport { Entity } from 'roosterjs-editor-types';\nimport { getEntitySelector } from './EntityInfo';\n\n/**\n * Get all entities with given entity type and id from an editor\n * @param editor The editor to get entity from\n * @param type (Optional) Type of the entity. If not specified, it will return all entities from this editor\n * @param id (Optional) Id of the entity. If not specified, it will return all entities of the given type\n */\nexport default function getEntities(editor: Editor, type?: string, id?: string): Entity[] {\n    const selector = getEntitySelector(type, id);\n    const nodes = editor.queryElements(selector);\n    const allEntities = nodes.map(node => getEntityFromElement(node));\n\n    return allEntities.filter(e => !!e);\n}\n","import getEntityFromElement from './getEntityFromElement';\nimport { Editor } from 'roosterjs-editor-core';\nimport { EntityOperation, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Try to trigger an EntityOperation event with a given element. An event will only be\n * triggered when the specified is an element root element.\n * @param editor The editor which contains the entity\n * @param element The root element of the entity\n * @param operation Operation of the EntityOperation event\n * @param rawEvent (Optional) Original UI event which causes this event\n */\nexport default function tryTriggerEntityEvent(\n    editor: Editor,\n    element: HTMLElement,\n    operation: EntityOperation,\n    rawEvent?: UIEvent\n) {\n    const entity = element && getEntityFromElement(element);\n\n    if (entity) {\n        if (operation == EntityOperation.NewEntity && entity.isReadonly) {\n            element.contentEditable = 'false';\n        }\n\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\n            operation,\n            rawEvent,\n            entity,\n        });\n    }\n}\n","import { Editor } from 'roosterjs-editor-core';\nimport { serializeEntityInfo } from './EntityInfo';\nimport { wrap } from 'roosterjs-editor-dom';\n\n/**\n * Wrap a node and become an entity element\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n */\nexport default function createEntityWrapper(\n    editor: Editor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean\n): HTMLElement {\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\n    wrapper.className = serializeEntityInfo(editor, type, isReadonly);\n\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\n    // there will be some weird behavior when move cursor around the entity node.\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\n    // in IE that there will be a resize border around the inline-block element. We made some\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\n    // will just work fine.\n    if (!isBlock && isReadonly) {\n        wrapper.style.display = 'inline-block';\n    }\n\n    return wrapper;\n}\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit, HyperLink, Paste } from 'roosterjs-editor-plugins';\r\nimport { Editor, EditorOptions, EditorPlugin } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): Editor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export * from './plugins/ContentEdit/index';\n","export { default as ContentEdit } from './ContentEdit';\nexport {\n    default as ContentEditFeatures,\n    getDefaultContentEditFeatures,\n} from './ContentEditFeatures';\n","import ContentEditFeatures, { getDefaultContentEditFeatures } from './ContentEditFeatures';\nimport { AutoLink, UnlinkWhenBackspaceAfterLink } from './features/autoLinkFeatures';\nimport { DefaultShortcut } from './features/shortcutFeatures';\nimport { Editor, EditorPlugin, GenericContentEditFeature } from 'roosterjs-editor-core';\nimport { InsertLineBeforeStructuredNodeFeature } from './features/insertLineBeforeStructuredNodeFeature';\nimport { NoCycleCursorMove } from './features/noCycleCursorMove';\nimport { PluginEvent } from 'roosterjs-editor-types';\nimport { TabInTable, UpDownInTable } from './features/tableFeatures';\nimport {\n    MarkdownBold,\n    MarkdownItalic,\n    MarkdownStrikethru,\n    MarkdownInlineCode,\n} from './features/markdownFeatures';\n\nimport {\n    AutoBullet,\n    IndentWhenTab,\n    OutdentWhenShiftTab,\n    MergeInNewLine,\n    OutdentWhenBackOn1stEmptyLine,\n    OutdentWhenEnterOnEmptyLine,\n    getSmartOrderedList,\n} from './features/listFeatures';\nimport {\n    UnquoteWhenBackOnEmpty1stLine,\n    UnquoteWhenEnterOnEmptyLine,\n} from './features/quoteFeatures';\n\n/**\n * An editor plugin to handle content edit event.\n * The following cases are included:\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\n * 2. Enter, Backspace on empty list item\n * 3. Enter, Backspace on empty blockquote line\n * 4. Auto bullet/numbering\n * 5. Auto link\n * 6. Tab in table\n * 7. Up/Down in table\n * 8. Manage list style\n */\nexport default class ContentEdit implements EditorPlugin {\n    private editor: Editor;\n\n    /**\n     * Create instance of ContentEdit plugin\n     * @param features An optional feature set to determine which features the plugin should provide\n     */\n    constructor(private featureSet?: ContentEditFeatures) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ContentEdit';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: Editor): void {\n        this.editor = editor;\n        this.getFilteredFeatures().forEach(feature => this.editor.addContentEditFeature(feature));\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    private getFilteredFeatures(): GenericContentEditFeature<PluginEvent>[] {\n        let featureSet = this.featureSet || getDefaultContentEditFeatures();\n        let allFeatures: {\n            [key in keyof Partial<ContentEditFeatures>]: GenericContentEditFeature<PluginEvent>;\n        } = {\n            indentWhenTab: IndentWhenTab,\n            outdentWhenShiftTab: OutdentWhenShiftTab,\n            outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\n            outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\n            mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\n            unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\n            unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\n            tabInTable: TabInTable,\n            upDownInTable: UpDownInTable,\n            insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\n            autoBullet: AutoBullet,\n            autoLink: AutoLink,\n            unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\n            defaultShortcut: DefaultShortcut,\n            noCycleCursorMove: NoCycleCursorMove,\n            smartOrderedList: getSmartOrderedList(featureSet.smartOrderedListStyles),\n            markdownBold: MarkdownBold,\n            markdownItalic: MarkdownItalic,\n            markdownStrikethru: MarkdownStrikethru,\n            markdownInlineCode: MarkdownInlineCode,\n        };\n        let keys = Object.keys(allFeatures) as (keyof ContentEditFeatures)[];\n        return keys.filter(key => featureSet[key]).map(key => allFeatures[key]);\n    }\n}\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstBlockElement } from '../blockElements/getFirstLastBlockElement';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstBlockElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport isRange from '../typeUtils/isRange';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = isRange(position) ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport { InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: ContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            if (textColors && isDarkMode) {\r\n                element.dataset.ogsc = textColors.lightModeColor;\r\n            }\r\n            elementStyle.color = textColor;\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset.ogsb = backgroundColors.lightModeColor;\r\n            }\r\n            elementStyle.backgroundColor = backgroundColor;\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport { ClipboardItems } from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardItems) => void\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardItems = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        html: undefined,\r\n    };\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n        let items = event.clipboardData.items;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            if (item.type && item.type.indexOf('text/html') == 0) {\r\n                item.getAsString(html => {\r\n                    result.html = Browser.isEdge ? workaroundForEdge(html) : html;\r\n                    callback(result);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        // No HTML content found, set html to null\r\n        result.html = null;\r\n    }\r\n\r\n    callback(result);\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { getComputedStyle } from './getComputedStyles';\n\n/**\n * Check if the given element is using right-to-left layout\n * @param element An HTML element to check\n * @returns True if the given element is using right-to-left layout, otherwise false\n */\nexport default function isRtl(element: HTMLElement): boolean {\n    return getComputedStyle(element, 'direction') == 'rtl';\n}\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import changeElementTag from './changeElementTag';\r\nimport contains from './contains';\r\nimport createRange from '../selection/createRange';\r\nimport findClosestElementAncestor from './findClosestElementAncestor';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport isNodeEmpty from './isNodeEmpty';\r\nimport isPositionAtBeginningOf from '../selection/isPositionAtBeginningOf';\r\nimport isVoidHtmlElement from './isVoidHtmlElement';\r\nimport Position from '../selection/Position';\r\nimport queryElements from './queryElements';\r\nimport splitTextNode from './splitTextNode';\r\nimport toArray from './toArray';\r\nimport unwrap from './unwrap';\r\nimport VTable from '../table/VTable';\r\nimport wrap from './wrap';\r\nimport { NodePosition, NodeType, PositionType, QueryScope } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst adjustSteps: ((\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\r\n\r\n/**\r\n * Adjust the given position and return a better position (if any) or the given position\r\n * which will be the best one for inserting the given node.\r\n * @param root Root node of the scope\r\n * @param nodeToInsert The node about to be inserted\r\n * @param position The original position to insert the node\r\n */\r\nexport default function adjustNodeInsertPosition(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    adjustSteps.forEach(handler => {\r\n        position = handler(root, nodeToInsert, position);\r\n    });\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleHyperLink(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let blockElement = getBlockElementAtNode(root, position.node);\r\n\r\n    if (blockElement) {\r\n        // Find the first <A> tag within current block which covers current selection\r\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\r\n        let anchor = queryElements(\r\n            root,\r\n            'a[href]',\r\n            null /*forEachCallback*/,\r\n            QueryScope.OnSelection,\r\n            createRange(position)\r\n        ).filter(a => blockElement.contains(a))[0];\r\n\r\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\r\n        if (anchor && isNodeEmpty(anchor)) {\r\n            position = new Position(anchor, PositionType.Before);\r\n            safeRemove(anchor);\r\n            anchor = null;\r\n        }\r\n\r\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\r\n        // otherwise we will have nested A tags which is a wrong HTML structure\r\n        if (\r\n            anchor &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\r\n        ) {\r\n            let normalizedPosition = position.normalize();\r\n            let parentNode = normalizedPosition.node.parentNode;\r\n            let nextNode =\r\n                normalizedPosition.node.nodeType == NodeType.Text\r\n                    ? splitTextNode(\r\n                          <Text>normalizedPosition.node,\r\n                          normalizedPosition.offset,\r\n                          false /*returnFirstPart*/\r\n                      )\r\n                    : normalizedPosition.isAtEnd\r\n                    ? normalizedPosition.node.nextSibling\r\n                    : normalizedPosition.node;\r\n            let splitter: Node = root.ownerDocument.createTextNode('');\r\n            parentNode.insertBefore(splitter, nextNode);\r\n\r\n            while (contains(anchor, splitter)) {\r\n                splitter = splitBalancedNodeRange(splitter);\r\n            }\r\n\r\n            position = new Position(splitter, PositionType.Before);\r\n            safeRemove(splitter);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleStructuredNode(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let rootNodeToInsert = nodeToInsert;\r\n\r\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\r\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\r\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\r\n    }\r\n\r\n    let tag = getTagOfNode(rootNodeToInsert);\r\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\r\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\r\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\r\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\r\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\r\n\r\n    if (tag == 'LI') {\r\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\r\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\r\n    }\r\n\r\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\r\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\r\n\r\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\r\n            safeRemove(rootNodeToInsert.nextSibling);\r\n        }\r\n\r\n        if (shouldInsertListAsText) {\r\n            unwrap(rootNodeToInsert.firstChild);\r\n            unwrap(rootNodeToInsert);\r\n        } else if (getTagOfNode(listNode) == tag) {\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(\r\n                listItem,\r\n                isPositionAtBeginningOf(position, listItem)\r\n                    ? PositionType.Before\r\n                    : PositionType.After\r\n            );\r\n        }\r\n    } else if (tag == 'TABLE' && trNode) {\r\n        // When inserting a table into a table, if these tables have the same column count, and\r\n        // current position is at beginning of a row, then merge these two tables\r\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\r\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\r\n        if (\r\n            currentTable.col == 0 &&\r\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\r\n            newTable.cells[0] &&\r\n            newTable.cells[0].length == currentTable.cells[0].length &&\r\n            isPositionAtBeginningOf(position, tdNode)\r\n        ) {\r\n            if (\r\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\r\n                !rootNodeToInsert.firstChild.nextSibling\r\n            ) {\r\n                unwrap(rootNodeToInsert.firstChild);\r\n            }\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(trNode, PositionType.After);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleParagraph(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (getTagOfNode(position.node) == 'P') {\r\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\r\n        // Change P tag to DIV to make sure it works well\r\n        let pos = position.normalize();\r\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\r\n        if (pos.node != div) {\r\n            position = pos;\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleVoidElement(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (isVoidHtmlElement(position.node)) {\r\n        position = new Position(\r\n            position.node,\r\n            position.isAtEnd ? PositionType.After : PositionType.Before\r\n        );\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction safeRemove(node: Node) {\r\n    if (node && node.parentNode) {\r\n        node.parentNode.removeChild(node);\r\n    }\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","import contains from '../utils/contains';\nimport getListTypeFromNode from './getListTypeFromNode';\nimport getTagOfNode from '../utils/getTagOfNode';\nimport isBlockElement from '../utils/isBlockElement';\nimport toArray from '../utils/toArray';\nimport unwrap from '../utils/unwrap';\nimport wrap from '../utils/wrap';\nimport { ListType } from 'roosterjs-editor-types';\n\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\n\n/**\n * @internal\n * !!! Never directly create instance of this class. It should be created within VList class !!!\n *\n * Represent a list item.\n *\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\n * @internal\n */\nexport default class VListItem {\n    private listTypes: ListType[];\n\n    /**\n     * Construct a new instance of VListItem class\n     * @param node The DOM node for this item\n     * @param listTypes An array represnets list types of all parent and current level.\n     * Skip this parameter for a non-list item.\n     */\n    constructor(private node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\n        if (!node) {\n            throw new Error('node must not be null');\n        }\n\n        // Always add a None list type in front of all other types to represent non-list scenario.\n        this.listTypes = [ListType.None, ...listTypes];\n    }\n\n    /**\n     * Get type of current list item\n     */\n    getListType(): ListType {\n        return this.listTypes[this.listTypes.length - 1];\n    }\n\n    /**\n     * Get DOM node of this list item\n     */\n    getNode(): Node {\n        return this.node;\n    }\n\n    /**\n     * Check if a given node is contained by this list item\n     * @param node The node to check\n     */\n    contains(node: Node): boolean {\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\n    }\n\n    /**\n     * Check if this item is an orphan item.\n     *\n     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag\n     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.\n     *\n     * For example:\n     * ```html\n     * <ol>\n     *   <div>Orphan node</div>\n     *   <li>first item</li>\n     * </ol>\n     * ```\n     * Here the first DIV tag is an orphan item.\n     *\n     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be\n     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,\n     * those nodes will be merged into LI, so that ideally here they should not exist.\n     */\n    isOrphanItem(): boolean {\n        return getTagOfNode(this.node) != 'LI';\n    }\n\n    /**\n     * Check if the given item can be merged into this item.\n     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.\n     * @param item The item to check\n     */\n    canMerge(item: VListItem): boolean {\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\n            return false;\n        }\n\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\n    }\n\n    /**\n     * Merge items into this item.\n     * @example Before merge:\n     * ```html\n     * <ol>\n     *   <li>Current item</li>\n     *   <div>line 1</div>\n     *   <div>line 2</div>\n     * </ol>\n     * ```\n     * After merge then two DIVs into LI:\n     * ```html\n     * <ol>\n     *   <li>Current item\n     *     <div>line 1</div>\n     *     <div>line 2</div>\n     *   </li>\n     * </ol>\n     * ```\n     * @param items The items to merge\n     */\n    mergeItems(items: VListItem[]) {\n        const nodesToWrap = items?.map(item => item.node) || [];\n        const targetNodes = wrapIfNotBlockNode(\n            nodesToWrap,\n            true /*checkFirst*/,\n            false /*checkLast*/\n        );\n        targetNodes.forEach(node => this.node.appendChild(node));\n    }\n\n    /**\n     * Indent this item\n     * If this is not an list item, it will be no op\n     */\n    indent() {\n        const listType = this.getListType();\n        if (listType != ListType.None) {\n            this.listTypes.push(listType);\n        }\n    }\n\n    /**\n     * Outdent this item\n     * If this item is already not an list item, it will be no op\n     */\n    outdent() {\n        if (this.listTypes.length > 1) {\n            this.listTypes.pop();\n        }\n    }\n\n    /**\n     * Change list type of this item\n     * @param targetType The target list type to change to\n     */\n    changeListType(targetType: ListType) {\n        if (targetType == ListType.None) {\n            this.listTypes = [targetType];\n        } else {\n            this.outdent();\n            this.listTypes.push(targetType);\n        }\n    }\n\n    /**\n     * Write the change result back into DOM\n     * @param listStack current stack of list elements\n     */\n    writeBack(listStack: Node[]) {\n        const doc = this.node.ownerDocument;\n        let nextLevel = 1;\n\n        // 1. Determine list elements that we can reuse\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL > OL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then Fragment > OL > UL can be reused\n        for (; nextLevel < listStack.length; nextLevel++) {\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\n                listStack.splice(nextLevel);\n                break;\n            }\n        }\n\n        // 2. Add new list elements\n        // e.g.:\n        //    passed in listStack: Fragment > OL > UL\n        //    local listTypes:     null     > OL > UL > UL > OL\n        //    then we need to create a UL and a OL tag\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\n            const listType = this.listTypes[nextLevel];\n            const newList = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\n\n            if (listType == ListType.Ordered) {\n                newList.style.listStyleType =\n                    orderListStyles[(nextLevel - 1) % orderListStyles.length];\n            }\n\n            listStack[listStack.length - 1].appendChild(newList);\n            listStack.push(newList);\n        }\n\n        // 3. Add current node into deepest list element\n        listStack[listStack.length - 1].appendChild(this.node);\n\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\n        if (this.listTypes.length <= 1) {\n            wrapIfNotBlockNode(\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\n                true /*checkFirst*/,\n                true /*checkLast*/\n            );\n        }\n    }\n}\n\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\n    if (\n        nodes.length > 0 &&\n        (!checkFirst || !isBlockElement(nodes[0])) &&\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\n    ) {\n        nodes = [wrap(nodes)];\n    }\n\n    return nodes;\n}\n\nfunction getChildrenAndUnwrap(node: Node): Node[] {\n    const result = toArray(node.childNodes);\n    unwrap(node);\n    return result;\n}\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\nimport isNodeInRegion from '../region/isNodeInRegion';\nimport shouldSkipNode from '../utils/shouldSkipNode';\nimport VList from './VList';\nimport { getLeafSibling } from '../utils/getLeafSibling';\nimport { isListElement } from './getListTypeFromNode';\nimport { ListType, Region } from 'roosterjs-editor-types';\n\ntype ListElement = HTMLOListElement | HTMLUListElement;\nconst ListSelector = 'ol,ul';\n\n/**\n * @internal\n * @param region The region to get VList from\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\n * false to only include the list for the selected blocks\n * @param startNode (Optional) When specified, try get VList which will contain this node.\n * If not specified, get VList from selection of this region\n */\nexport default function createVListFromRegion(\n    region: Region,\n    includeSiblingLists?: boolean,\n    startNode?: Node\n): VList {\n    if (!region) {\n        return null;\n    }\n\n    let nodes: Node[] = [];\n\n    if (startNode) {\n        const list = getRootListNode(region, startNode);\n        if (list) {\n            nodes.push(list);\n        }\n    } else {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        blocks.forEach(block => {\n            const list = getRootListNode(region, block.getStartNode());\n\n            if (list) {\n                if (nodes[nodes.length - 1] != list) {\n                    nodes.push(list);\n                }\n            } else {\n                nodes.push(block.collapseToSingleElement());\n            }\n        });\n\n        if (includeSiblingLists) {\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\n        }\n\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\n    }\n\n    let vList: VList = null;\n\n    if (nodes.length > 0) {\n        const firstNode = nodes.shift();\n        vList = isListElement(firstNode)\n            ? new VList(firstNode)\n            : createVListFromItemNode(firstNode);\n\n        nodes.forEach(node => {\n            if (isListElement(node)) {\n                vList.mergeVList(new VList(node));\n            } else {\n                vList.appendItem(node, ListType.None);\n            }\n        });\n    }\n\n    return vList;\n}\n\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\n    let node = nodes[isNext ? nodes.length - 1 : 0];\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\n    node = getRootListNode(region, node);\n    if (isNodeInRegion(region, node) && isListElement(node)) {\n        if (isNext) {\n            nodes.push(node);\n        } else {\n            nodes.unshift(node);\n        }\n    }\n}\n\nfunction getRootListNode(region: Region, node: Node): ListElement {\n    let list = findClosestElementAncestor(node, region.rootNode, ListSelector) as ListElement;\n\n    if (list) {\n        let ancestor: ListElement;\n        while (\n            (ancestor = findClosestElementAncestor(\n                list.parentNode,\n                region.rootNode,\n                ListSelector\n            ) as ListElement)\n        ) {\n            list = ancestor;\n        }\n    }\n\n    return list;\n}\n\nfunction createVListFromItemNode(node: Node): VList {\n    // Create a temporary OL root element for this list.\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\n    node.parentNode?.insertBefore(listNode, node);\n\n    // Create the VList and append items\n    const vList = new VList(listNode);\n    vList.appendItem(node, ListType.None);\n\n    return vList;\n}\n","import contains from '../utils/contains';\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\nimport Position from '../selection/Position';\nimport queryElements from '../utils/queryElements';\nimport regionTypeData from './regionTypeData';\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\n\n/**\n * Get regions impacted by the given range under the root node\n * @param root Root node to get regions from\n * @param range A selection range. Regions will be created acording to this range. Each region will be\n * fully or partially covered by this range.\n * @param type Type of region. Currently we only support TABLE region.\n */\nexport default function getRegionsFromRange(\n    root: HTMLElement,\n    range: Range,\n    type: RegionType\n): Region[] {\n    let regions: Region[] = [];\n    if (root && range) {\n        const { innerSelector, skipTags } = regionTypeData[type];\n        const boundaryTree = buildBoundaryTree(root, range, type);\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\n        const creator = getRegionCreator(range, skipTags);\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\n    }\n\n    return regions.filter(r => !!r);\n}\n\n/**\n * @internal export for test only\n */\nexport function getRegionCreator(\n    fullRange: Range,\n    skipTags: string[]\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\n            ? {\n                  rootNode,\n                  nodeBefore,\n                  nodeAfter,\n                  skipTags,\n                  fullSelectionStart,\n                  fullSelectionEnd,\n              }\n            : null;\n    };\n}\n\n/**\n * This is a internal data structure used for build regions.\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\n */\ninterface Boundary {\n    /**\n     * inner node of this boundary\n     */\n    innerNode: HTMLElement;\n\n    /**\n     * Children of this boundary\n     */\n    children: {\n        /**\n         * Outer node of a boundary child\n         */\n        outerNode: Node;\n\n        /**\n         * Child bundaries\n         */\n        boundaries: Boundary[];\n    }[];\n}\n\n/**\n * Step 1: Build boundary tree\n * @param root Root node of the whole scope, normally this will be the root of editable scope\n * @param range Existing selected full range\n * @param type Type of region to create\n */\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\n    const { outerSelector, innerSelector } = regionTypeData[type];\n    const inSelectionOuterNode = queryElements(\n        root,\n        outerSelector,\n        null /*callback*/,\n        QueryScope.InSelection,\n        range\n    );\n\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\n    // is in document order, which is what we expect. So we don't need to sort the result here.\n    queryElements(\n        root,\n        innerSelector,\n        thisInnerNode => {\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\n\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\n                    const { innerNode, children } = allBoundaries[i];\n                    if (contains(innerNode, thisOuterNode)) {\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\n\n                        if (!child) {\n                            child = { outerNode: thisOuterNode, boundaries: [] };\n                            children.push(child);\n                        }\n\n                        child.boundaries.push(boundary);\n                        break;\n                    }\n                }\n                allBoundaries.push(boundary);\n            }\n        },\n        QueryScope.OnSelection,\n        range\n    );\n\n    return allBoundaries[0];\n}\n\n/**\n * Step 2: Recursively iterate all boundaries and create regions\n * @param creator A region creator function to help create region\n * @param boundary Current root boundary\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\n * @param started Whether we have already hit the start node\n */\nfunction iterateNodes(\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\n    boundary: Boundary,\n    start: Node,\n    end: Node,\n    started?: boolean\n): [Region[], boolean, boolean] {\n    started = started || boundary.innerNode == start;\n    let ended = false;\n    const { children, innerNode } = boundary;\n    let regions: Region[] = [];\n\n    if (children.length == 0) {\n        regions.push(creator(innerNode));\n    } else {\n        // Need to run one more time to add region after all children\n        for (let i = 0; i <= children.length && !ended; i++) {\n            const { outerNode, boundaries } = children[i] || {};\n            const previousOuterNode = children[i - 1]?.outerNode;\n            if (started) {\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\n            }\n\n            boundaries?.forEach(child => {\n                let newRegions: Region[];\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\n                regions = regions.concat(newRegions);\n            });\n        }\n    }\n\n    return [regions, started, ended || innerNode == end];\n}\n\n/**\n * Check if the given nodes combination is valid to create a region.\n * A combination is valid when:\n * 1. Root node is not null and is not empty. And\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\n * node between them.\n * @param root Root node of region\n * @param nodeBefore The boundary node before the region under root\n * @param nodeAfter The boundary node after the region under root\n * @param skipTags Tags to skip\n */\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\n    if (!root || !root.firstChild) {\n        return false;\n    } else {\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\n        const firstNodeValid =\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\n        const lastNodeValid =\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\n        const bothValid =\n            !nodeBefore ||\n            !nodeAfter ||\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\n        return firstNodeValid && lastNodeValid && bothValid;\n    }\n}\n","import { RegionType } from 'roosterjs-editor-types';\n\n/**\n * @internal\n * Constants for each region type\n */\nexport interface RegionTypeData {\n    /**\n     * Tags that child elements will be skipped\n     */\n    skipTags: string[];\n\n    /**\n     * Selector of outer node of a region\n     */\n    outerSelector: string;\n\n    /**\n     * Selector of inner node of a region\n     */\n    innerSelector: string;\n}\n\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\n    [RegionType.Table]: {\n        skipTags: ['TABLE'],\n        outerSelector: 'table',\n        innerSelector: 'td,th',\n    },\n};\n\n/**\n * @internal\n */\nexport default regionTypeData;\n","import collapseNode from '../utils/collapseNodes';\nimport isNodeInRegion from './isNodeInRegion';\nimport { Region } from 'roosterjs-editor-types';\n\n/**\n * Collapse nodes within this region to their common ascenstor node under this region\n * @param region The region to collapse nodes in.\n * @param nodes Nodes to collapse. All nodes not contained by the given region will be ignored.\n */\nexport default function collapseNodesInRegion(region: Region, nodes: Node[]): Node[] {\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\n\n    if (!nodes || nodes.length == 0) {\n        return [];\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\n    } else {\n        return [];\n    }\n}\n","import createRange from './createRange';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction normalizeRect(clientRect: ClientRect): Rect {\r\n    // A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n    // We validate that and only return a rect when the passed in ClientRect is valid\r\n    let { left, right, top, bottom } = clientRect || <ClientRect>{};\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import getSelectionPath from './getSelectionPath';\n\n/**\n * Get inner Html of a root node with a selection path which can be used for restore selection.\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\n * @param rootNode Root node to get inner Html from\n * @param range The range of selection. If pass null, no selection path will be added\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\n */\nexport default function getHtmlWithSelectionPath(rootNode: HTMLElement, range: Range): string {\n    if (!rootNode) {\n        return '';\n    }\n\n    const content = rootNode.innerHTML;\n    const selectionPath = range && getSelectionPath(rootNode, range);\n\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\n}\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n */\r\nexport default function addSnapshot(snapshots: Snapshots, snapshot: string) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import getInheritableStyles from './getInheritableStyles';\nimport htmlToDom from './htmlToDom';\nimport isHTMLElement from '../typeUtils/isHTMLElement';\nimport { cloneObject } from './cloneObject';\nimport {\n    getAllowedTags,\n    getAllowedAttributes,\n    getDefaultStyleValues,\n    getStyleCallbacks,\n    getAllowedCssClassesRegex,\n} from './getAllowedValues';\nimport {\n    HtmlSanitizerOptions,\n    SanitizeHtmlOptions,\n    StringMap,\n    StyleCallbackMap,\n    ElementCallbackMap,\n    AttributeCallbackMap,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * HTML sanitizer class provides two featuers:\n * 1. Convert global CSS to inline CSS\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\n */\nexport default class HtmlSanitizer {\n    /**\n     * Convert global CSS to inline CSS if any\n     * @param html HTML source\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\n     */\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\n        let sanitizer = new HtmlSanitizer({\n            additionalGlobalStyleNodes: additionalStyleNodes,\n        });\n        return sanitizer.exec(html, true /*convertCssOnly*/);\n    }\n\n    /**\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\n     * @param html HTML source string\n     * @param options Options used for this sanitizing process\n     */\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\n        options = options || {};\n        let sanitizer = new HtmlSanitizer(options);\n        let currentStyles = isHTMLElement(options.currentElementOrStyle)\n            ? getInheritableStyles(options.currentElementOrStyle)\n            : options.currentElementOrStyle;\n        return sanitizer.exec(\n            html,\n            options.convertCssOnly,\n            options.preserveFragmentOnly,\n            currentStyles\n        );\n    }\n\n    private elementCallbacks: ElementCallbackMap;\n    private styleCallbacks: StyleCallbackMap;\n    private attributeCallbacks: AttributeCallbackMap;\n    private allowedTags: string[];\n    private allowedAttributes: string[];\n    private allowedCssClassesRegex: RegExp;\n    private defaultStyleValues: StringMap;\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\n    private allowPreserveWhiteSpace: boolean;\n\n    /**\n     * Construct a new instance of HtmlSanitizer\n     * @param options Options for HtmlSanitizer\n     */\n    constructor(options?: HtmlSanitizerOptions) {\n        options = options || {};\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\n        this.styleCallbacks = getStyleCallbacks(options.styleCallbacks);\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\n        this.allowedTags = getAllowedTags(options.additionalAllowedTags);\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowAttributes);\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\n            options.additionalAllowedCssClasses\n        );\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\n        this.allowPreserveWhiteSpace = options.allowPreserveWhiteSpace;\n    }\n\n    /**\n     * Sanitize HTML string\n     * This function will do the following work:\n     * 1. Convert global CSS into inline CSS\n     * 2. Remove dangerous HTML tags and attributes\n     * 3. Remove useless CSS properties\n     * @param html The input HTML\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\n     * @param preserveFragmentOnly If set to true, only preserve the html content between &lt;!--StartFragment--&gt; and &lt;!--Endfragment--&gt;\n     * @param currentStyles Current inheritable CSS styles\n     */\n    exec(\n        html: string,\n        convertCssOnly?: boolean,\n        preserveFragmentOnly?: boolean,\n        currentStyles?: StringMap\n    ): string {\n        let doc = htmlToDom(html, preserveFragmentOnly);\n        if (doc) {\n            this.convertGlobalCssToInlineCss(doc);\n            if (!convertCssOnly) {\n                this.sanitize(doc.body, currentStyles);\n            }\n        }\n        return (doc && doc.body && doc.body.innerHTML) || '';\n    }\n\n    /**\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\n     * @param rootNode Root node to sanitize\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\n     * the same value with current styles will be ignored.\n     */\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\n        if (!rootNode) {\n            return '';\n        }\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\n        this.processNode(rootNode, currentStyles, {});\n    }\n\n    /**\n     * Convert global CSS into inline CSS\n     * @param rootNode The HTML Document\n     */\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\n        let styleSheets = this.additionalGlobalStyleNodes\n            .reverse()\n            .map(node => node.sheet as CSSStyleSheet)\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\n            .filter(sheet => sheet);\n        for (let styleSheet of styleSheets) {\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\n                // Skip any none-style rule, i.e. @page\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\n                    continue;\n                }\n                // Make sure the selector is not empty\n                for (let selector of styleRule.selectorText.split(',')) {\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\n                        continue;\n                    }\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\n                    // Always put existing styles after so that they have higher priority\n                    // Which means if both global style and inline style apply to the same element,\n                    // inline style will have higher priority\n                    nodes.forEach(node =>\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\n                    );\n                }\n            }\n        }\n\n        styleNodes.forEach(node => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\n        const nodeType = node.nodeType;\n        const isElement = nodeType == NodeType.Element;\n        const isText = nodeType == NodeType.Text;\n        const isFragment = nodeType == NodeType.DocumentFragment;\n\n        let element = <HTMLElement>node;\n        let tag = isElement ? element.tagName.toUpperCase() : '';\n\n        if (\n            (isElement && !this.allowElement(element, tag, context)) ||\n            (isText && /^[\\r\\n]*$/g.test(node.nodeValue) && !currentStyle.insidePRE) ||\n            (!isElement && !isText && !isFragment)\n        ) {\n            node.parentNode.removeChild(node);\n        } else if (\n            isText &&\n            !this.allowPreserveWhiteSpace &&\n            currentStyle['white-space'] == 'pre'\n        ) {\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\n        } else if (isElement || isFragment) {\n            let thisStyle = cloneObject(currentStyle);\n            if (isElement) {\n                this.processAttributes(element, context);\n                this.processCss(element, tag, thisStyle, context);\n\n                // Special handling for PRE tag, need to preserve \\r\\n inside PRE\n                if (tag == 'PRE') {\n                    thisStyle.insidePRE = 'true';\n                }\n            }\n\n            let child: Node = element.firstChild;\n            let next: Node;\n            for (; child; child = next) {\n                next = child.nextSibling;\n                this.processNode(child, thisStyle, context);\n            }\n        }\n    }\n\n    private processCss(element: HTMLElement, tag: string, thisStyle: StringMap, context: Object) {\n        let styleNode = element.getAttributeNode('style');\n        if (!styleNode) {\n            return;\n        }\n\n        let source = styleNode.value.split(';');\n        let result = source.filter(style => {\n            let pair: string[];\n\n            if (!style || style.trim() == '' || (pair = style.split(':')).length != 2) {\n                return false;\n            }\n\n            let name = pair[0].trim().toLowerCase();\n            let value = pair[1].trim().toLowerCase();\n            let callback = this.styleCallbacks[name];\n            let isInheritable = thisStyle[name] != undefined;\n            let keep =\n                (!callback || callback(value, element, context)) &&\n                value != 'inherit' &&\n                value.indexOf('expression') < 0 &&\n                name.substr(0, 1) != '-' &&\n                this.defaultStyleValues[name] != value &&\n                ((isInheritable && value != thisStyle[name]) ||\n                    (!isInheritable && value != 'initial' && value != 'normal'));\n            if (keep && isInheritable) {\n                thisStyle[name] = value;\n            }\n            return keep && (this.allowPreserveWhiteSpace || name != 'white-space');\n        });\n\n        if (source.length != result.length) {\n            if (result.length > 0) {\n                element.setAttribute('style', result.map(s => s.trim()).join('; '));\n            } else {\n                element.removeAttribute('style');\n            }\n        }\n    }\n\n    private processAttributes(element: HTMLElement, context: Object) {\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\n            let attribute = element.attributes[i];\n            let name = attribute.name.toLowerCase().trim();\n            let value = attribute.value;\n            let callback = this.attributeCallbacks[name];\n\n            let newValue = callback\n                ? callback(value, element, context)\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\n                ? value\n                : null;\n\n            if (name == 'class' && this.allowedCssClassesRegex) {\n                newValue = this.processCssClass(value, newValue);\n            }\n\n            if (\n                newValue === null ||\n                newValue === undefined ||\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\n            ) {\n                element.removeAttribute(name);\n            } else {\n                attribute.value = newValue;\n            }\n        }\n    }\n\n    private processCssClass(originalValue: string, calculatedValue: string): string {\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\n\n        originalClasses.forEach(className => {\n            if (\n                this.allowedCssClassesRegex.test(className) &&\n                calculatedClasses.indexOf(className) < 0\n            ) {\n                calculatedClasses.push(className);\n            }\n        });\n\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\n    }\n\n    private allowElement(element: HTMLElement, tag: string, context: Object): boolean {\n        let callback = this.elementCallbacks[tag];\n        return callback\n            ? callback(element, context)\n            : this.allowedTags.indexOf(tag) >= 0 || tag.indexOf(':') > 0;\n    }\n}\n\nfunction toArray<T extends Node>(list: NodeListOf<T>): T[] {\n    return [].slice.call(list) as T[];\n}\n","import { cloneObject } from './cloneObject';\nimport { StringMap, StyleCallbackMap } from 'roosterjs-editor-types';\n\nconst ALLOWED_HTML_TAGS = (\n    'BODY,H1,H2,H3,H4,H5,H6,FORM,P,BR,NOBR,HR,ACRONYM,ABBR,ADDRESS,B,' +\n    'BDI,BDO,BIG,BLOCKQUOTE,CENTER,CITE,CODE,DEL,DFN,EM,FONT,I,INS,KBD,MARK,METER,PRE,PROGRESS,' +\n    'Q,RP,RT,RUBY,S,SAMP,SMALL,STRIKE,STRONG,SUB,SUP,TEMPLATE,TIME,TT,U,VAR,WBR,XMP,INPUT,TEXTAREA,' +\n    'BUTTON,SELECT,OPTGROUP,OPTION,LABEL,FIELDSET,LEGEND,DATALIST,OUTPUT,IMG,MAP,AREA,CANVAS,FIGCAPTION,' +\n    'FIGURE,PICTURE,A,NAV,UL,OL,LI,DIR,UL,DL,DT,DD,MENU,MENUITEM,TABLE,CAPTION,TH,TR,TD,THEAD,TBODY,' +\n    'TFOOT,COL,COLGROUP,DIV,SPAN,HEADER,FOOTER,MAIN,SECTION,ARTICLE,ASIDE,DETAILS,DIALOG,SUMMARY,DATA'\n).split(',');\n\nconst ALLOWED_HTML_ATTRIBUTES = (\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\n    'width,wrap'\n).split(',');\n\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\n    'background-color': 'transparent',\n    'border-bottom-color': 'rgb(0, 0, 0)',\n    'border-bottom-style': 'none',\n    'border-bottom-width': '0px',\n    'border-image-outset': '0',\n    'border-image-repeat': 'stretch',\n    'border-image-slice': '100%',\n    'border-image-source': 'none',\n    'border-image-width': '1',\n    'border-left-color': 'rgb(0, 0, 0)',\n    'border-left-style': 'none',\n    'border-left-width': '0px',\n    'border-right-color': 'rgb(0, 0, 0)',\n    'border-right-style': 'none',\n    'border-right-width': '0px',\n    'border-top-color': 'rgb(0, 0, 0)',\n    'border-top-style': 'none',\n    'border-top-width': '0px',\n    'outline-color': 'transparent',\n    'outline-style': 'none',\n    'outline-width': '0px',\n    overflow: 'visible',\n    'text-decoration': 'none',\n    '-webkit-text-stroke-width': '0px',\n    'word-wrap': 'break-word',\n    'margin-left': '0px',\n    'margin-right': '0px',\n    padding: '0px',\n    'padding-top': '0px',\n    'padding-left': '0px',\n    'padding-right': '0px',\n    'padding-bottom': '0px',\n    border: '0px',\n    'border-top': '0px',\n    'border-left': '0px',\n    'border-right': '0px',\n    'border-bottom': '0px',\n    'vertical-align': 'baseline',\n    float: 'none',\n};\n\n// This is to preserve entity related CSS classes when paste.\nconst ALLOWED_CSS_CLASSES: string[] = [];\n\n/**\n * @internal\n */\nexport function getAllowedTags(additionalTags: string[]): string[] {\n    return unique(ALLOWED_HTML_TAGS.concat(additionalTags || [])).map(tag => tag.toUpperCase());\n}\n\n/**\n * @internal\n */\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\n        attr.toLocaleLowerCase()\n    );\n}\n\n/**\n * @internal\n */\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\n}\n\n/**\n * @internal\n */\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\n    if (additionalDefaultStyles) {\n        Object.keys(additionalDefaultStyles).forEach(name => {\n            let value = additionalDefaultStyles[name];\n            if (value !== null && value !== undefined) {\n                result[name] = value;\n            } else {\n                delete result[name];\n            }\n        });\n    }\n\n    return result;\n}\n\n/**\n * @internal\n */\nexport function getStyleCallbacks(callbacks: StyleCallbackMap): StyleCallbackMap {\n    let result = cloneObject(callbacks);\n    result.position = result.position || removeValue;\n    result.width = result.width || removeWidthForLiAndDiv;\n    return result;\n}\n\nfunction removeValue(): null {\n    return null;\n}\n\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\n    let tag = element.tagName;\n    return !(tag == 'LI' || tag == 'DIV');\n}\n\nfunction unique<T>(array: T[]): T[] {\n    return array.filter((value, index, self) => self.indexOf(value) == index);\n}\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\n\n/**\n * Create default value of HtmlSanitizerOptions with every property set\n */\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\n    return {\n        elementCallbacks: {},\n        attributeCallbacks: {},\n        styleCallbacks: {},\n        additionalAllowedTags: [],\n        additionalAllowAttributes: [],\n        additionalAllowedCssClasses: [],\n        additionalDefaultStyleValues: {},\n        additionalGlobalStyleNodes: [],\n        allowPreserveWhiteSpace: false,\n    };\n}\n","/**\n * Chain all callback for an attribute together\n * @param map The source callback map\n * @param name Name of the property to chain\n * @param newCallback A new callback to process the given name on the given map.\n * If the same property got multiple callbacks, the final return value will be the return\n * value of the latest callback\n */\nexport default function chainSanitizerCallback<T extends any[], R>(\n    map: Record<string, (...args: T) => R>,\n    name: string,\n    newCallback: (...args: T) => R\n) {\n    if (!map[name]) {\n        map[name] = newCallback;\n    } else {\n        const originalCallback = map[name];\n        map[name] = (...args: T) => {\n            originalCallback(...args);\n            return newCallback(...args);\n        };\n    }\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is DocumentFragment\n * @param obj The object to check\n */\nexport default function isDocumentFragment(obj: any): obj is DocumentFragment {\n    return safeInstanceOf(obj as Node, 'DocumentFragment');\n}\n","import safeInstanceOf from './safeInstanceOf';\n\n/**\n * Check if the given object is HTMLOListElement\n * @param obj The object to check\n */\nexport default function isHTMLOListElement(obj: any): obj is HTMLOListElement {\n    return safeInstanceOf(obj as Node, 'HTMLOListElement');\n}\n","import { LinkInlineElement, matchLink } from 'roosterjs-editor-dom';\nimport { removeLink, replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    LinkData,\n    PluginEvent,\n    PluginEventType,\n    PluginKeyboardEvent,\n    ClipboardData,\n} from 'roosterjs-editor-types';\nimport {\n    Editor,\n    cacheGetEventData,\n    cacheGetContentSearcher,\n    clearContentSearcherCache,\n    GenericContentEditFeature,\n    Keys,\n} from 'roosterjs-editor-core';\n\n/**\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\n * we need to trim off the trailing puncatuation before turning it to link match\n */\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\nconst MINIMUM_LENGTH = 5;\n\n/**\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\n * in hyperlink format into a real hyperlink\n */\nexport const AutoLink: GenericContentEditFeature<PluginEvent> = {\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\n    shouldHandleEvent: cacheGetLinkData,\n    handleEvent: autoLink,\n};\n\n/**\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\n * if user presses BACKSPACE right after a hyperlink\n */\nexport const UnlinkWhenBackspaceAfterLink: GenericContentEditFeature<PluginKeyboardEvent> = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: hasLinkBeforeCursor,\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n        removeLink(editor);\n    },\n};\n\nfunction cacheGetLinkData(event: PluginEvent, editor: Editor): LinkData {\n    return event.eventType == PluginEventType.KeyDown ||\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\n              // First try to match link from the whole paste string from the plain text in clipboard.\n              // This helps when we paste a link next to some existing character, and the text we got\n              // from clipboard will only contain what we pasted, any existing characters will not\n              // be included.\n              let clipboardData =\n                  event.eventType == PluginEventType.ContentChanged &&\n                  event.source == ChangeSource.Paste &&\n                  (event.data as ClipboardData);\n              let link = matchLink((clipboardData.text || '').trim());\n              let searcher = cacheGetContentSearcher(event, editor);\n\n              // In case the matched link is already inside a <A> tag, we do a range search.\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\n                  return link;\n              }\n\n              let word = searcher && searcher.getWordBefore();\n              if (word && word.length > MINIMUM_LENGTH) {\n                  // Check for trailing punctuation\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\n\n                  // Do special handling for ')', '}', ']'\n                  ['()', '{}', '[]'].forEach(str => {\n                      if (\n                          candidate[candidate.length - 1] == str[1] &&\n                          candidate.indexOf(str[0]) < 0\n                      ) {\n                          candidate = candidate.substr(0, candidate.length - 1);\n                      }\n                  });\n\n                  // Match and replace in editor\n                  return matchLink(candidate);\n              }\n              return null;\n          })\n        : null;\n}\n\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: Editor): boolean {\n    let contentSearcher = cacheGetContentSearcher(event, editor);\n    let inline = contentSearcher.getInlineElementBefore();\n    return inline instanceof LinkInlineElement;\n}\n\nfunction autoLink(event: PluginEvent, editor: Editor) {\n    let anchor = editor.getDocument().createElement('a');\n    let linkData = cacheGetLinkData(event, editor);\n\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\n    // and at that time a new searcher won't be able to find the link text to replace\n    let searcher = editor.getContentSearcherOfCursor();\n    anchor.textContent = linkData.originalUrl;\n    anchor.href = linkData.normalizedUrl;\n\n    editor.runAsync(() => {\n        editor.performAutoComplete(() => {\n            replaceWithNode(editor, linkData.originalUrl, anchor, false /* exactMatch */, searcher);\n\n            // The content at cursor has changed. Should also clear the cursor data cache\n            clearContentSearcherCache(event);\n            return anchor;\n        }, ChangeSource.AutoLink);\n    });\n}\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { FontSizeChange } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: Editor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, NodeType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport {\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    unwrap,\r\n    wrap,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n} from 'roosterjs-editor-dom';\r\n\r\nexport const TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nexport const TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\nexport const ATTRIBUTES_TO_PRESERVE = ['href'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n * @param tagsToUnwrap Optional. A string array contains HTML tags in upper case which we will unwrap when clear format\r\n * @param tagsToStopUnwrap Optional. A string array contains HTML tags in upper case which we will stop unwrap if these tags are hit\r\n */\r\nexport default function clearBlockFormat(\r\n    editor: Editor,\r\n    tagsToUnwrap: string[] = TAGS_TO_UNWRAP,\r\n    tagsToStopUnwrap: string[] = TAGS_TO_STOP_UNWRAP,\r\n    attributesToPreserve: string[] = ATTRIBUTES_TO_PRESERVE\r\n) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        let groups: {\r\n            first?: HTMLElement;\r\n            last?: HTMLElement;\r\n            td?: HTMLElement;\r\n        }[] = [{}];\r\n        let stopUnwrapSelector = tagsToStopUnwrap.join(',');\r\n\r\n        // 1. Collapse the selected blocks and get first and last element\r\n        collapseSelectedBlocks(editor, element => {\r\n            let group = groups[groups.length - 1];\r\n            let td = editor.getElementAtCursor(stopUnwrapSelector, element);\r\n            if (td != group.td && group.first) {\r\n                groups.push((group = {}));\r\n            }\r\n\r\n            group.td = td;\r\n            group.first = group.first || element;\r\n            group.last = element;\r\n        });\r\n\r\n        groups\r\n            .filter(group => group.first)\r\n            .forEach(group => {\r\n                // 2. Collapse with first and last element to make them under same parent\r\n                let nodes = editor.collapseNodes(group.first, group.last, true /*canSplitParent*/);\r\n\r\n                // 3. Continue collapse until we can't collapse any more (hit root node, or a table)\r\n                if (canCollapse(tagsToStopUnwrap, nodes[0])) {\r\n                    while (\r\n                        editor.contains(nodes[0].parentNode) &&\r\n                        canCollapse(tagsToStopUnwrap, nodes[0].parentNode as HTMLElement)\r\n                    ) {\r\n                        nodes = [splitBalancedNodeRange(nodes)];\r\n                    }\r\n                }\r\n\r\n                // 4. Clear formats of the nodes\r\n                nodes.forEach(node =>\r\n                    clearNodeFormat(\r\n                        node as HTMLElement,\r\n                        tagsToUnwrap,\r\n                        tagsToStopUnwrap,\r\n                        attributesToPreserve\r\n                    )\r\n                );\r\n\r\n                // 5. Clear CSS of container TD if exist\r\n                if (group.td) {\r\n                    let styles = group.td.getAttribute('style') || '';\r\n                    let styleArray = styles.split(';');\r\n                    styleArray = styleArray.filter(\r\n                        style => style.trim().toLowerCase().indexOf('border') == 0\r\n                    );\r\n                    styles = styleArray.join(';');\r\n                    if (styles) {\r\n                        group.td.setAttribute('style', styles);\r\n                    } else {\r\n                        group.td.removeAttribute('style');\r\n                    }\r\n                }\r\n            });\r\n\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction clearNodeFormat(\r\n    node: Node,\r\n    tagsToUnwrap: string[],\r\n    tagsToStopUnwrap: string[],\r\n    attributesToPreserve: string[]\r\n): boolean {\r\n    if (node.nodeType != NodeType.Element || getTagOfNode(node) == 'BR') {\r\n        return false;\r\n    }\r\n\r\n    // 1. Recursively clear format of all its child nodes\r\n    let allChildrenAreBlock = toArray(node.childNodes)\r\n        .map(n => clearNodeFormat(n, tagsToUnwrap, tagsToStopUnwrap, attributesToPreserve))\r\n        .reduce((previousValue, value) => previousValue && value, true);\r\n\r\n    if (!canCollapse(tagsToStopUnwrap, node)) {\r\n        return false;\r\n    }\r\n\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. If we should unwrap this tag, put it into an array and unwrap it later\r\n    if (tagsToUnwrap.indexOf(getTagOfNode(node)) >= 0 || allChildrenAreBlock) {\r\n        if (returnBlockElement && !allChildrenAreBlock) {\r\n            wrap(node);\r\n        }\r\n        unwrap(node);\r\n    } else {\r\n        // 3. Otherwise, remove all attributes\r\n        clearAttribute(node as HTMLElement, attributesToPreserve);\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement, attributesToPreserve: string[]) {\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (\r\n            attributesToPreserve.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction canCollapse(tagsToStopUnwrap: string[], node: Node) {\r\n    return tagsToStopUnwrap.indexOf(getTagOfNode(node)) < 0;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: Editor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: Editor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { cacheGetElementAtCursor, Editor } from 'roosterjs-editor-core';\r\nimport { getPendableFormatState } from 'roosterjs-editor-dom';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    PluginEvent,\r\n    QueryScope,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: Editor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'OL,UL'));\r\n    let headerTag = getTagOfNode(cacheGetElementAtCursor(editor, event, 'H1,H2,H3,H4,H5,H6'));\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * @deprecated Use Editor.getStyleBasedFormatState() instead\r\n * Get style based Format State at cursor\r\n * @param editor The editor instance\r\n * @returns A StyleBasedFormatState object\r\n */\r\nexport function getStyleBasedFormatState(editor: Editor): StyleBasedFormatState {\r\n    return editor.getStyleBasedFormatState();\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: Editor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        canUndo: editor.canUndo(),\r\n        canRedo: editor.canRedo(),\r\n    };\r\n}\r\n","import adjustBrowserBehavior from './adjustBrowserBehavior';\r\nimport createEditorCore from './createEditorCore';\r\nimport EditorCore from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport mapPluginEvents from './mapPluginEvents';\r\nimport normalizeContentColor from '../darkMode/normalizeContentColor';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { convertContentToDarkMode } from '../darkMode/convertContentToDarkMode';\r\nimport { GenericContentEditFeature } from '../interfaces/ContentEditFeature';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ContentPosition,\r\n    DarkModeOptions,\r\n    DefaultFormat,\r\n    InlineElement,\r\n    InsertOption,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Rect,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getHtmlWithSelectionPath,\r\n    getSelectionPath,\r\n    getTextContent,\r\n    getInlineElementAtNode,\r\n    getPositionRect,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    isRange,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    setHtmlWithSelectionPath,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor {\r\n    private core: EditorCore;\r\n    private eventDisposers: (() => void)[];\r\n    private contenteditableChanged: boolean;\r\n    private enableExperimentFeatures: boolean;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        this.core = createEditorCore(contentDiv, options);\r\n        this.enableExperimentFeatures = options.enableExperimentFeatures;\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure initial content and its format\r\n        this.setContent(\r\n            options.initialContent || contentDiv.innerHTML || '',\r\n            false /*triggerContentChangedEvent*/\r\n        );\r\n\r\n        // 5. Create event handler to bind DOM events\r\n        this.eventDisposers = mapPluginEvents(this.core);\r\n\r\n        // 6. Add additional content edit features to the editor if specified\r\n        if (options.additionalEditFeatures) {\r\n            options.additionalEditFeatures.forEach(feature => this.addContentEditFeature(feature));\r\n        }\r\n\r\n        // 7. Make the container editable and set its selection styles\r\n        if (!options.omitContentEditableAttributeChanges && !contentDiv.isContentEditable) {\r\n            contentDiv.setAttribute('contenteditable', 'true');\r\n            let styles = contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = 'text';\r\n            this.contenteditableChanged = true;\r\n        }\r\n\r\n        // 8. Do proper change for browsers to disable some browser-specified behaviors.\r\n        adjustBrowserBehavior(this.core.document);\r\n\r\n        // 9. Let plugins know that we are ready\r\n        this.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\r\n\r\n        // 10. Before give editor to user, make sure there is at least one DIV element to accept typing\r\n        this.core.corePlugins.typeInContainer.ensureTypeInElement(\r\n            this.getFocusedPosition() || new Position(contentDiv, PositionType.Begin)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\r\n\r\n        this.core.plugins.forEach(plugin => plugin.dispose());\r\n        this.eventDisposers.forEach(disposer => disposer());\r\n        this.eventDisposers = null;\r\n\r\n        for (let key of Object.keys(this.core.customData)) {\r\n            let data = this.core.customData[key];\r\n            if (data && data.disposer) {\r\n                data.disposer(data.value);\r\n            }\r\n            delete this.core.customData[key];\r\n        }\r\n\r\n        if (this.contenteditableChanged) {\r\n            let styles = this.core.contentDiv.style;\r\n            styles.userSelect = styles.msUserSelect = styles.webkitUserSelect = '';\r\n            this.core.contentDiv.removeAttribute('contenteditable');\r\n        }\r\n\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        // DocumentFragment type nodes become empty after they're inserted.\r\n        // Therefore, we get the list of nodes to transform prior to their insertion.\r\n        const darkModeOptions = this.getDarkModeOptions();\r\n        const darkModeTransform = this.isDarkMode()\r\n            ? convertContentToDarkMode(\r\n                  node,\r\n                  darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                      ? darkModeOptions.onExternalContentTransform\r\n                      : undefined\r\n              )\r\n            : null;\r\n\r\n        const result = node ? this.core.api.insertNode(this.core, node, option) : false;\r\n\r\n        if (result && darkModeTransform) {\r\n            darkModeTransform();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param new node to replace to\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(existingNode: Node, toNode: Node): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (existingNode && toNode && this.contains(existingNode)) {\r\n            existingNode.parentNode.replaceChild(toNode, existingNode);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get InlineElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The InlineElement result\r\n     */\r\n    public getInlineElementAtNode(node: Node): InlineElement {\r\n        return getInlineElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    /**\r\n     * Check if the node falls in the editor content\r\n     * @param node The node to check\r\n     * @returns True if the given node is in editor content, otherwise false\r\n     */\r\n    public contains(node: Node): boolean;\r\n\r\n    /**\r\n     * Check if the range falls in the editor content\r\n     * @param range The range to check\r\n     * @returns True if the given range is in editor content, otherwise false\r\n     */\r\n    public contains(range: Range): boolean;\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    /**\r\n     * Query HTML elements in editor by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements in editor by a selector string\r\n     * @param selector Selector string to query\r\n     * @param forEachCallback An optional callback to be invoked on each node in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by tag name\r\n     * @param tag Tag name of the element to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element list of the query result\r\n     */\r\n    public queryElements<T extends keyof HTMLElementTagNameMap>(\r\n        tag: T,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: HTMLElementTagNameMap[T]) => any\r\n    ): HTMLElementTagNameMap[T][];\r\n\r\n    /**\r\n     * Query HTML elements with the given scope by a selector string\r\n     * @param selector Selector string to query\r\n     * @param scope The scope of the query, default value is QueryScope.Body\r\n     * @param forEachCallback An optional callback to be invoked on each element in query result\r\n     * @returns HTML Element array of the query result\r\n     */\r\n    public queryElements<T extends HTMLElement = HTMLElement>(\r\n        selector: string,\r\n        scope: QueryScope,\r\n        forEachCallback?: (node: T) => any\r\n    ): T[];\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins\r\n     * before return. Use this parameter to remove any temporary content added by plugins.\r\n     * @param includeSelectionMarker Set to true if need include selection marker inside the content.\r\n     * When restore this content, editor will set the selection to the position marked by these markers.\r\n     * This parameter will be ignored when triggerExtractContentEvent is set to true\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(\r\n        triggerExtractContentEvent: boolean = true,\r\n        includeSelectionMarker: boolean = false\r\n    ): string {\r\n        let content = '';\r\n        const isDarkMode = this.core.inDarkMode;\r\n        if (triggerExtractContentEvent || isDarkMode) {\r\n            const clonedRoot = this.core.contentDiv.cloneNode(true /*deep*/) as HTMLElement;\r\n            const path = includeSelectionMarker && this.getSelectionPath();\r\n            const range = path && createRange(clonedRoot, path.start, path.end);\r\n\r\n            if (isDarkMode) {\r\n                normalizeContentColor(clonedRoot);\r\n            }\r\n\r\n            if (triggerExtractContentEvent) {\r\n                this.triggerPluginEvent(\r\n                    PluginEventType.ExtractContentWithDom,\r\n                    {\r\n                        clonedRoot,\r\n                    },\r\n                    true /*broadcast*/\r\n                );\r\n\r\n                // TODO: Deprecated ExtractContentEvent once we have entity API ready in next major release\r\n                content = this.triggerPluginEvent(\r\n                    PluginEventType.ExtractContent,\r\n                    { content: clonedRoot.innerHTML },\r\n                    true /*broadcast*/\r\n                ).content;\r\n            } else if (range) {\r\n                // range is not null, which means we want to include a selection path in the content\r\n                content = getHtmlWithSelectionPath(clonedRoot, range);\r\n            } else {\r\n                content = clonedRoot.innerHTML;\r\n            }\r\n        } else {\r\n            content = getHtmlWithSelectionPath(\r\n                this.core.contentDiv,\r\n                includeSelectionMarker && this.getSelectionRange()\r\n            );\r\n        }\r\n\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Get plain text content inside editor\r\n     * @returns The text content inside editor\r\n     */\r\n    public getTextContent(): string {\r\n        return getTextContent(this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        let contentDiv = this.core.contentDiv;\r\n        let contentChanged = false;\r\n        if (contentDiv.innerHTML != content) {\r\n            let range = setHtmlWithSelectionPath(contentDiv, content);\r\n            this.select(range);\r\n            contentChanged = true;\r\n        }\r\n\r\n        // Convert content even if it hasn't changed.\r\n        if (this.core.inDarkMode) {\r\n            const darkModeOptions = this.getDarkModeOptions();\r\n            const convertFunction = convertContentToDarkMode(\r\n                contentDiv,\r\n                darkModeOptions && darkModeOptions.onExternalContentTransform\r\n                    ? darkModeOptions.onExternalContentTransform\r\n                    : undefined,\r\n                true /* skipRootElement */\r\n            );\r\n            if (convertFunction) {\r\n                convertFunction();\r\n                contentChanged = true;\r\n            }\r\n        }\r\n\r\n        if (triggerContentChangedEvent && contentChanged) {\r\n            this.triggerContentChangedEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            let allNodes = fromHtml(content, this.core.document);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = this.core.document.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n\r\n        if (clipboardData && pos) {\r\n            if (clipboardData.snapshotBeforePaste) {\r\n                // Restore original content before paste a new one\r\n                this.setContent(clipboardData.snapshotBeforePaste);\r\n            } else {\r\n                clipboardData.snapshotBeforePaste = this.getContent(\r\n                    false /*triggerExtractContentEvent*/,\r\n                    true /*includeSelectionMarker*/\r\n                );\r\n            }\r\n\r\n            const fragment = this.core.api.createPasteFragment(\r\n                this.core,\r\n                clipboardData,\r\n                pos,\r\n                pasteAsText,\r\n                applyCurrentFormat\r\n            );\r\n\r\n            this.addUndoSnapshot(() => {\r\n                this.insertNode(fragment);\r\n                return clipboardData;\r\n            }, ChangeSource.Paste);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(): Range {\r\n        return this.core.api.getSelectionRange(this.core, true /*tryGetFromCache*/);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Select content by range\r\n     * @param range The range to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(range: Range): boolean;\r\n\r\n    /**\r\n     * Select content by Position and collapse to this position\r\n     * @param position The position to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(position: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by a start and end position\r\n     * @param start The start position to select\r\n     * @param end The end position to select, if this is the same with start, the selection will be collapsed\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(start: NodePosition, end: NodePosition): boolean;\r\n\r\n    /**\r\n     * Select content by node\r\n     * @param node The node to select\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node): boolean;\r\n\r\n    /**\r\n     * Select content by node and offset, and collapse to this position\r\n     * @param node The node to select\r\n     * @param offset The offset of node to select, can be a number or value of PositionType\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(node: Node, offset: number | PositionType): boolean;\r\n\r\n    /**\r\n     * Select content by start and end nodes and offsets\r\n     * @param startNode The node to select start from\r\n     * @param startOffset The offset to select start from\r\n     * @param endNode The node to select end to\r\n     * @param endOffset The offset to select end to\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(\r\n        startNode: Node,\r\n        startOffset: number | PositionType,\r\n        endNode: Node,\r\n        endOffset: number | PositionType\r\n    ): boolean;\r\n\r\n    /**\r\n     * Select content by selection path\r\n     * @param path A selection path object\r\n     * @returns True if content is selected, otherwise false\r\n     */\r\n    public select(path: SelectionPath): boolean;\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : isRange(arg1)\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current selection\r\n     * @return current selection object\r\n     */\r\n    public getSelection(): Selection {\r\n        return this.core.document.defaultView.getSelection();\r\n    }\r\n\r\n    /**\r\n     * Save the current selection in editor so that when focus again, the selection can be restored\r\n     */\r\n    public saveSelectionRange() {\r\n        this.core.cachedSelectionRange = this.core.api.getSelectionRange(\r\n            this.core,\r\n            false /*tryGetFromCache*/\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Restore the saved selection range and clear it\r\n     */\r\n    public restoreSavedRange() {\r\n        this.select(this.core.cachedSelectionRange);\r\n        this.core.cachedSelectionRange = null;\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a rect representing the location of the cursor.\r\n     * @returns a Rect object representing cursor location\r\n     */\r\n    public getCursorRect(): Rect {\r\n        let position = this.getFocusedPosition();\r\n        return position && getPositionRect(position);\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     */\r\n    public getElementAtCursor(selector?: string, startFrom?: Node): HTMLElement {\r\n        if (!startFrom) {\r\n            let position = this.getFocusedPosition();\r\n            startFrom = position && position.node;\r\n        }\r\n        return startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        // Make sure there is a wrpper around cursor first, otherwise there will be no valid region\r\n        this.core.corePlugins.typeInContainer.ensureTypeInElement(\r\n            this.getFocusedPosition() || new Position(this.core.contentDiv, PositionType.Begin)\r\n        );\r\n\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    /**\r\n     * Add a custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param eventName DOM event name to handle\r\n     * @param handler Handler callback\r\n     * @returns A dispose function. Call the function to dispose this event handler\r\n     */\r\n    public addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;\r\n\r\n    /**\r\n     * Add a bunch of custom DOM event handler to handle events not handled by roosterjs.\r\n     * Caller need to take the responsibility to dispose the handler properly\r\n     * @param handlerMap A event name => event handler map\r\n     * @returns A dispose function. Call the function to dispose all event handlers added by this function\r\n     */\r\n    public addDomEventHandler(handlerMap: {\r\n        [eventName: string]: (event: UIEvent) => void;\r\n    }): () => void;\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap:\r\n            | string\r\n            | {\r\n                  [eventName: string]: (event: UIEvent) => void;\r\n              },\r\n        handler?: (event: UIEvent) => void\r\n    ): () => void {\r\n        if (nameOrMap instanceof Object) {\r\n            let handlers = Object.keys(nameOrMap)\r\n                .map(\r\n                    eventName =>\r\n                        nameOrMap[eventName] &&\r\n                        this.core.api.attachDomEvent(\r\n                            this.core,\r\n                            eventName,\r\n                            null /*pluginEventType*/,\r\n                            nameOrMap[eventName]\r\n                        )\r\n                )\r\n                .filter(x => x);\r\n            return () => handlers.forEach(handler => handler());\r\n        } else {\r\n            return this.core.api.attachDomEvent(\r\n                this.core,\r\n                nameOrMap,\r\n                null /*pluginEventType*/,\r\n                handler\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use triggerPluginEvent instead\r\n     */\r\n    public triggerEvent(pluginEvent: PluginEvent, broadcast: boolean = true) {\r\n        this.core.api.triggerEvent(this.core, pluginEvent, broadcast);\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.undo();\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.corePlugins.undo.redo();\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n        changeSource?: ChangeSource | string\r\n    ) {\r\n        this.core.api.editWithUndo(this.core, callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Perform an auto complete action in the callback, save a snapsnot of content before the action,\r\n     * and trigger ContentChangedEvent with the change source if specified\r\n     * @param callback The auto complete callback, return value will be used as data field of ContentChangedEvent\r\n     * @param changeSource Chagne source of ContentChangedEvent. If not passed, no ContentChangedEvent will be  triggered\r\n     */\r\n    public performAutoComplete(callback: () => any, changeSource?: ChangeSource | string) {\r\n        this.core.corePlugins.edit.performAutoComplete(callback, changeSource);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo snapshot\r\n     */\r\n    public canUndo(): boolean {\r\n        return this.core.corePlugins.undo.canUndo();\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available redo snapshot\r\n     */\r\n    public canRedo(): boolean {\r\n        return this.core.corePlugins.undo.canRedo();\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.document;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return this.core.api.getCustomData(this.core, key, getter, disposer);\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.corePlugins.domEvent.isInIME();\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): ContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): ContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     */\r\n    public getContentSearcherOfCursor(): PositionContentSearcher {\r\n        let range = this.getSelectionRange();\r\n        return range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range));\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: () => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature. This is mostly called from ContentEdit plugin\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        this.core.corePlugins.edit.addFeature(feature);\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(\r\n            undefined /* triggerContentChangedEvent */,\r\n            true /* getSelectionMarker */\r\n        );\r\n\r\n        this.core.inDarkMode = nextDarkMode;\r\n        this.core.defaultFormat = calculateDefaultFormat(\r\n            this.core.contentDiv,\r\n            this.core.defaultFormat,\r\n            this.core.inDarkMode\r\n        );\r\n\r\n        this.setContent(currentContent);\r\n        this.triggerPluginEvent(PluginEventType.DarkModeChanged, {\r\n            changedToDarkMode: nextDarkMode,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.inDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Returns the dark mode options set on the editor\r\n     * @returns A DarkModeOptions object\r\n     */\r\n    public getDarkModeOptions(): DarkModeOptions {\r\n        return this.core.darkModeOptions;\r\n    }\r\n\r\n    /**\r\n     * Whether experiment features can be used\r\n     */\r\n    public useExperimentFeatures(): boolean {\r\n        return !!this.enableExperimentFeatures;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\n\r\nconst COMMANDS: {\r\n    [command: string]: any;\r\n} = Browser.isFirefox\r\n    ? {\r\n          /**\r\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\r\n           */\r\n          [DocumentCommand.EnableObjectResizing]: false,\r\n          [DocumentCommand.EnableInlineTableEditing]: false,\r\n      }\r\n    : Browser.isIE\r\n    ? {\r\n          /**\r\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\r\n           */\r\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\r\n\r\n          /**\r\n           * Disable auto link feature in IE since we have our own implementation\r\n           */\r\n          [DocumentCommand.AutoUrlDetect]: false,\r\n      }\r\n    : {};\r\n\r\n/**\r\n * Execute document command to adjust browser default behavior\r\n */\r\nexport default function adjustBrowserBehavior(document: HTMLDocument) {\r\n    Object.keys(COMMANDS).forEach(command => {\r\n        // Catch any possible exception since this should not block the initialization of editor\r\n        try {\r\n            document.execCommand(command, false, COMMANDS[command]);\r\n        } catch {}\r\n    });\r\n}\r\n","import CopyPlugin from '../corePlugins/CopyPlugin';\r\nimport CorePastePlugin from '../corePlugins/CorePastePlugin';\r\nimport DOMEventPlugin from '../corePlugins/DOMEventPlugin';\r\nimport EditorCore, { CoreApiMap, CorePlugins } from '../interfaces/EditorCore';\r\nimport EditorOptions from '../interfaces/EditorOptions';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport EditPlugin from '../corePlugins/EditPlugin';\r\nimport FirefoxTypeAfterLink from '../corePlugins/FirefoxTypeAfterLink';\r\nimport MouseUpPlugin from '../corePlugins/MouseUpPlugin';\r\nimport TypeInContainerPlugin from '../corePlugins/TypeInContainerPlugin';\r\nimport Undo from '../undo/Undo';\r\nimport { attachDomEvent } from '../coreAPI/attachDomEvent';\r\nimport { Browser } from 'roosterjs-editor-dom';\r\nimport { calculateDefaultFormat } from '../coreAPI/calculateDefaultFormat';\r\nimport { createPasteFragment } from '../coreAPI/createPasteFragment';\r\nimport { CustomDataMap } from '../interfaces/CustomData';\r\nimport { editWithUndo } from '../coreAPI/editWithUndo';\r\nimport { focus } from '../coreAPI/focus';\r\nimport { getCustomData } from '../coreAPI/getCustomData';\r\nimport { getSelectionRange } from '../coreAPI/getSelectionRange';\r\nimport { getStyleBasedFormatState } from '../coreAPI/getStyleBasedFormatState';\r\nimport { hasFocus } from '../coreAPI/hasFocus';\r\nimport { insertNode } from '../coreAPI/insertNode';\r\nimport { select, selectRange } from '../coreAPI/selectRange';\r\nimport { triggerEvent } from '../coreAPI/triggerEvent';\r\n\r\n/**\r\n * Create core object for editor\r\n * @param contentDiv The DIV element used for editor\r\n * @param options Options to create an editor\r\n */\r\nexport default function createEditorCore(\r\n    contentDiv: HTMLDivElement,\r\n    options: EditorOptions\r\n): EditorCore {\r\n    let corePlugins: CorePlugins = {\r\n        undo: options.undo || new Undo(),\r\n        edit: new EditPlugin(),\r\n        typeInContainer: new TypeInContainerPlugin(),\r\n        mouseUp: new MouseUpPlugin(),\r\n        domEvent: new DOMEventPlugin(options.disableRestoreSelectionOnFocus),\r\n        firefoxTypeAfterLink: new FirefoxTypeAfterLink(),\r\n        copyPlugin: !Browser.isIE && new CopyPlugin(),\r\n        pastePlugin: new CorePastePlugin(),\r\n    };\r\n    let allPlugins = buildPluginList(corePlugins, options.plugins);\r\n    let eventHandlerPlugins = allPlugins.filter(\r\n        plugin => plugin.onPluginEvent || plugin.willHandleEventExclusively\r\n    );\r\n    return {\r\n        contentDiv,\r\n        scrollContainer: options.scrollContainer || contentDiv,\r\n        document: contentDiv.ownerDocument,\r\n        defaultFormat: calculateDefaultFormat(\r\n            contentDiv,\r\n            options.defaultFormat,\r\n            options.inDarkMode\r\n        ),\r\n        corePlugins,\r\n        currentUndoSnapshot: null,\r\n        customData: createCustomData(options.customData || {}),\r\n        cachedSelectionRange: null,\r\n        plugins: allPlugins,\r\n        eventHandlerPlugins: eventHandlerPlugins,\r\n        api: createCoreApiMap(options.coreApiOverride),\r\n        defaultApi: createCoreApiMap(),\r\n        inDarkMode: options.inDarkMode,\r\n        darkModeOptions: options.darkModeOptions,\r\n    };\r\n}\r\n\r\nfunction buildPluginList(corePlugins: CorePlugins, plugins: EditorPlugin[]): EditorPlugin[] {\r\n    return [\r\n        corePlugins.typeInContainer,\r\n        corePlugins.edit,\r\n        corePlugins.mouseUp,\r\n        ...(plugins || []),\r\n        corePlugins.firefoxTypeAfterLink,\r\n        corePlugins.undo,\r\n        corePlugins.domEvent,\r\n        corePlugins.copyPlugin,\r\n        corePlugins.pastePlugin,\r\n    ].filter(plugin => !!plugin);\r\n}\r\n\r\nfunction createCoreApiMap(map?: Partial<CoreApiMap>): CoreApiMap {\r\n    map = map || {};\r\n    return {\r\n        attachDomEvent: map.attachDomEvent || attachDomEvent,\r\n        editWithUndo: map.editWithUndo || editWithUndo,\r\n        focus: map.focus || focus,\r\n        getCustomData: map.getCustomData || getCustomData,\r\n        getSelectionRange: map.getSelectionRange || getSelectionRange,\r\n        getStyleBasedFormatState: map.getStyleBasedFormatState || getStyleBasedFormatState,\r\n        hasFocus: map.hasFocus || hasFocus,\r\n        insertNode: map.insertNode || insertNode,\r\n        createPasteFragment: map.createPasteFragment || createPasteFragment,\r\n        select: map.select || select,\r\n        selectRange: map.selectRange || selectRange,\r\n        triggerEvent: map.triggerEvent || triggerEvent,\r\n    };\r\n}\r\n\r\nfunction createCustomData(initValue: { [key: string]: any }): CustomDataMap {\r\n    return Object.keys(initValue).reduce((result, key) => {\r\n        result[key] = {\r\n            value: initValue[key],\r\n        };\r\n        return result;\r\n    }, <CustomDataMap>{});\r\n}\r\n","import UndoSnapshotsService from '../interfaces/UndoSnapshotsService';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\nimport {\r\n    addSnapshot,\r\n    canMoveCurrentSnapshot,\r\n    moveCurrentSnapsnot,\r\n    clearProceedingSnapshots,\r\n    createSnapshots,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\r\n// to keep size under limit. This is kept at 10MB\r\nconst MAXSIZELIMIT = 1e7;\r\n\r\n/**\r\n * A class to help manage undo snapshots\r\n */\r\nexport default class UndoSnapshots implements UndoSnapshotsService {\r\n    private snapshots: Snapshots;\r\n\r\n    constructor(public readonly maxSize: number = MAXSIZELIMIT) {\r\n        this.snapshots = createSnapshots(maxSize);\r\n    }\r\n\r\n    /**\r\n     * Check whether can move current undo snapshot with the given step\r\n     * @param step The step to check, can be positive, negative or 0\r\n     * @returns True if can move current snapshot with the given step, otherwise false\r\n     */\r\n    public canMove(delta: number): boolean {\r\n        return canMoveCurrentSnapshot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n     * @param step The step to move\r\n     * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n     */\r\n    public move(delta: number): string {\r\n        return moveCurrentSnapsnot(this.snapshots, delta);\r\n    }\r\n\r\n    /**\r\n     * Add a new undo snapshot\r\n     * @param snapshot The snapshot to add\r\n     */\r\n    public addSnapshot(snapshot: string) {\r\n        addSnapshot(this.snapshots, snapshot);\r\n    }\r\n\r\n    /**\r\n     * Clear all undo snapshots after the current one\r\n     */\r\n    public clearRedo() {\r\n        clearProceedingSnapshots(this.snapshots);\r\n    }\r\n}\r\n","import EditorCore, { AttachDomEvent } from '../interfaces/EditorCore';\r\nimport isCharacterValue from '../eventApi/isCharacterValue';\r\nimport { PluginDomEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Attach a DOM event to the editor content DIV\r\n * @param core The EditorCore object\r\n * @param eventName The DOM event name\r\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\r\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\r\n */\r\nexport const attachDomEvent: AttachDomEvent = (\r\n    core: EditorCore,\r\n    eventName: string,\r\n    pluginEventType?: PluginEventType,\r\n    beforeDispatch?: (event: UIEvent) => void\r\n) => {\r\n    let onEvent = (event: UIEvent) => {\r\n        // Stop propagation of a printable keyboard event (a keyboard event which is caused by printable char input).\r\n        // This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n        // event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n        // So if we missed some case here it is still acceptable.\r\n        if (\r\n            (isKeyboardEvent(event) && isCharacterValue(event)) ||\r\n            pluginEventType == PluginEventType.Input\r\n        ) {\r\n            event.stopPropagation();\r\n        }\r\n\r\n        if (beforeDispatch) {\r\n            beforeDispatch(event);\r\n        }\r\n        if (pluginEventType != null) {\r\n            core.api.triggerEvent(\r\n                core,\r\n                <PluginDomEvent>{\r\n                    eventType: pluginEventType,\r\n                    rawEvent: event,\r\n                },\r\n                false /*broadcast*/\r\n            );\r\n        }\r\n    };\r\n    core.contentDiv.addEventListener(eventName, onEvent);\r\n    return () => {\r\n        core.contentDiv.removeEventListener(eventName, onEvent);\r\n    };\r\n};\r\n\r\nfunction isKeyboardEvent(e: UIEvent): e is KeyboardEvent {\r\n    return e.type == 'keydown' || e.type == 'keypress' || e.type == 'keyup';\r\n}\r\n","import EditorCore, { CreatePasteFragment } from '../interfaces/EditorCore';\nimport {\n    applyFormat,\n    applyTextStyle,\n    createDefaultHtmlSanitizerOptions,\n    getInheritableStyles,\n    getPendableFormatState,\n    HtmlSanitizer,\n    toArray,\n    wrap,\n} from 'roosterjs-editor-dom';\nimport {\n    BeforePasteEvent,\n    ClipboardData,\n    PasteOption,\n    PluginEventType,\n    DefaultFormat,\n    NodePosition,\n} from 'roosterjs-editor-types';\n\nconst START_FRAGMENT = '<!--StartFragment-->';\nconst END_FRAGMENT = '<!--EndFragment-->';\nconst NBSP_HTML = '\\u00A0';\n\nexport const createPasteFragment: CreatePasteFragment = (\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    position: NodePosition,\n    pasteAsText: boolean,\n    applyCurrentStyle: boolean\n) => {\n    // Step 1: Prepare BeforePasteEvent object\n    const event = createBeforePasteEvent(core, clipboardData, pasteAsText);\n    const { fragment, pasteOption, sanitizingOption } = event;\n    const { rawHtml, text, imageDataUri } = clipboardData;\n    let doc: HTMLDocument;\n\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\n    if (pasteOption == PasteOption.PasteImage && imageDataUri) {\n        const img = core.document.createElement('img');\n        img.style.maxWidth = '100%';\n        img.src = imageDataUri;\n        fragment.appendChild(img);\n    } else if (\n        pasteOption == PasteOption.PasteHtml &&\n        rawHtml &&\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\n    ) {\n        // Save HTML node attributes and META attributes so that plugin can query\n        const attributes = doc.querySelector('html')?.attributes;\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\n            attrs[attr.name] = attr.value;\n            return attrs;\n        }, event.htmlAttributes);\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\n            attrs[meta.name] = meta.content;\n            return attrs;\n        }, event.htmlAttributes);\n\n        // Move all STYLE nodes into header, and save them into sanitizing options.\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\n        processStyles(doc, style => {\n            doc.head.appendChild(style);\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\n        });\n\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\n\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\n            event.htmlBefore = rawHtml.substr(0, startIndex);\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\n                startIndex + START_FRAGMENT.length,\n                endIndex\n            );\n\n            // Remove style nodes just added by setting innerHTML of body since we already have all\n            // style nodes in header.\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\n            // and the nodes under HEAD are still used when convert global CSS to inline\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\n        }\n\n        while (doc.body.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n\n        if (applyCurrentStyle && position) {\n            const format = getCurrentFormat(core, position.node);\n            applyTextStyle(fragment, node => applyFormat(node, format));\n        }\n    } else if (text) {\n        text.split('\\n').forEach((line, index, lines) => {\n            line = line\n                .replace(/^ /g, NBSP_HTML)\n                .replace(/\\r/g, '')\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\n\n            const node = line == '' ? document.createElement('br') : document.createTextNode(line);\n\n            fragment.appendChild(index == 0 || index == lines.length - 1 ? node : wrap(node));\n        });\n    }\n\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\n    core.api.triggerEvent(core, event, true /*broadcast*/);\n\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\n\n    sanitizer.convertGlobalCssToInlineCss(fragment);\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\n\n    return fragment;\n};\n\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\n    const pendableFormat = getPendableFormatState(core.document);\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\n    return {\n        fontFamily: styleBasedForamt.fontName,\n        fontSize: styleBasedForamt.fontSize,\n        textColor: styleBasedForamt.textColor,\n        backgroundColor: styleBasedForamt.backgroundColor,\n        textColors: styleBasedForamt.textColors,\n        backgroundColors: styleBasedForamt.backgroundColors,\n        bold: pendableFormat.isBold,\n        italic: pendableFormat.isItalic,\n        underline: pendableFormat.isUnderline,\n    };\n}\n\nfunction createBeforePasteEvent(\n    core: EditorCore,\n    clipboardData: ClipboardData,\n    pasteAsText: boolean\n): BeforePasteEvent {\n    const pasteOption = pasteAsText\n        ? PasteOption.PasteText\n        : clipboardData.text || !clipboardData.image\n        ? PasteOption.PasteHtml\n        : PasteOption.PasteImage;\n    const fragment = core.document.createDocumentFragment();\n    return {\n        eventType: PluginEventType.BeforePaste,\n        clipboardData,\n        pasteOption,\n        fragment,\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\n        htmlBefore: '',\n        htmlAfter: '',\n        htmlAttributes: {},\n    };\n}\n\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\n    const styles = node.querySelectorAll('style');\n    for (let i = 0; i < styles.length; i++) {\n        callback(styles[i]);\n    }\n}\n","import EditorCore, { EditWithUndo } from '../interfaces/EditorCore';\r\nimport { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentChangedEvent,\r\n    NodePosition,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\r\n * Undo snapshot will not be added if this call is nested inside another editWithUndo() call.\r\n * @param core The EditorCore object\r\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\r\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\r\n */\r\nexport const editWithUndo: EditWithUndo = (\r\n    core: EditorCore,\r\n    callback: (start: NodePosition, end: NodePosition, snapshotBeforeCallback: string) => any,\r\n    changeSource: ChangeSource | string\r\n) => {\r\n    let isNested = core.currentUndoSnapshot !== null;\r\n    let data: any;\r\n\r\n    if (!isNested) {\r\n        core.currentUndoSnapshot = core.corePlugins.undo.addUndoSnapshot();\r\n    }\r\n\r\n    try {\r\n        if (callback) {\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            data = callback(\r\n                range && Position.getStart(range).normalize(),\r\n                range && Position.getEnd(range).normalize(),\r\n                core.currentUndoSnapshot\r\n            );\r\n\r\n            if (!isNested) {\r\n                core.corePlugins.undo.addUndoSnapshot();\r\n            }\r\n        }\r\n    } finally {\r\n        if (!isNested) {\r\n            core.currentUndoSnapshot = null;\r\n        }\r\n    }\r\n\r\n    if (callback && changeSource) {\r\n        let event: ContentChangedEvent = {\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: changeSource,\r\n            data: data,\r\n        };\r\n        core.api.triggerEvent(core, event, true /*broadcast*/);\r\n    }\r\n};\r\n","import EditorCore, { Focus } from '../interfaces/EditorCore';\r\nimport { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Focus to editor. If there is a cached selection range, use it as current selection\r\n * @param core The EditorCore object\r\n */\r\nexport const focus: Focus = (core: EditorCore) => {\r\n    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {\r\n        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\r\n        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\r\n        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\r\n        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\r\n        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\r\n        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\r\n        // It should be better than the case you cannot type\r\n        if (\r\n            !core.cachedSelectionRange ||\r\n            !core.api.selectRange(core, core.cachedSelectionRange, true /*skipSameRange*/)\r\n        ) {\r\n            let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\r\n            core.api.selectRange(\r\n                core,\r\n                createRange(node, PositionType.Begin),\r\n                true /*skipSameRange*/\r\n            );\r\n        }\r\n    }\r\n\r\n    // remember to clear cachedSelectionRange\r\n    core.cachedSelectionRange = null;\r\n\r\n    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\r\n    if (!core.api.hasFocus(core)) {\r\n        core.contentDiv.focus();\r\n    }\r\n};\r\n","import EditorCore, { GetCustomData } from '../interfaces/EditorCore';\r\n\r\n/**\r\n * Get custom data related with this editor\r\n * @param core The EditorCore object\r\n * @param key Key of the custom data\r\n * @param getter Getter function. If custom data for the given key doesn't exist,\r\n * call this function to get one and store it if it is specified. Otherwise return undefined\r\n * @param disposer An optional disposer function to dispose this custom data when\r\n * dispose editor.\r\n */\r\nexport const getCustomData: GetCustomData = <T>(\r\n    core: EditorCore,\r\n    key: string,\r\n    getter: () => T,\r\n    disposer?: (value: T) => void\r\n): T => {\r\n    return (core.customData[key] = core.customData[key] || {\r\n        value: getter ? getter() : undefined,\r\n        disposer,\r\n    }).value as T;\r\n};\r\n","import EditorCore, { GetSelectionRange } from '../interfaces/EditorCore';\r\nimport { contains } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Get current or cached selection range\r\n * @param core The EditorCore object\r\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\r\n * @returns A Range object of the selection range\r\n */\r\nexport const getSelectionRange: GetSelectionRange = (\r\n    core: EditorCore,\r\n    tryGetFromCache: boolean\r\n) => {\r\n    let result: Range = null;\r\n\r\n    if (!tryGetFromCache || core.api.hasFocus(core)) {\r\n        let selection = core.document.defaultView.getSelection();\r\n        if (selection && selection.rangeCount > 0) {\r\n            let range = selection.getRangeAt(0);\r\n            if (contains(core.contentDiv, range)) {\r\n                result = range;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!result && tryGetFromCache) {\r\n        result = core.cachedSelectionRange;\r\n    }\r\n\r\n    return result;\r\n};\r\n","import EditorCore, { GetStyleBasedFormatState } from '../interfaces/EditorCore';\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\n\nconst ORIGINAL_STYLE_COLOR_SELECTOR = '[data-ogsc],[data-ogac]';\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = '[data-ogsb],[data-ogab]';\n\n/**\n * Get style based format state from current selection, including font name/size and colors\n * @param core The EditorCore objects\n * @param node The node to get style from\n */\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\n    core: EditorCore,\n    node: Node\n) => {\n    if (!node) {\n        return {};\n    }\n    const styles = node ? getComputedStyles(node) : [];\n    const isDarkMode = core.inDarkMode;\n    const root = core.contentDiv;\n    const ogTextColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\n    const ogBackgroundColorNode =\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\n\n    return {\n        fontName: styles[0],\n        fontSize: styles[1],\n        textColor: styles[2],\n        backgroundColor: styles[3],\n        textColors: ogTextColorNode\n            ? {\n                  darkModeColor: styles[2],\n                  lightModeColor: ogTextColorNode.dataset.ogsc || ogTextColorNode.dataset.ogac,\n              }\n            : undefined,\n        backgroundColors: ogBackgroundColorNode\n            ? {\n                  darkModeColor: styles[3],\n                  lightModeColor:\n                      ogBackgroundColorNode.dataset.ogsb || ogBackgroundColorNode.dataset.ogab,\n              }\n            : undefined,\n    };\n};\n","import EditorCore, { InsertNode } from '../interfaces/EditorCore';\r\nimport {\r\n    ContentPosition,\r\n    InsertOption,\r\n    NodeType,\r\n    PositionType,\r\n    BlockElement,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Position,\r\n    getBlockElementAtNode,\r\n    getFirstLastBlockElement,\r\n    isBlockElement,\r\n    isVoidHtmlElement,\r\n    wrap,\r\n    adjustNodeInsertPosition,\r\n    createRange,\r\n} from 'roosterjs-editor-dom';\r\n\r\nfunction getInitialRange(\r\n    core: EditorCore,\r\n    option: InsertOption\r\n): { range: Range; rangeToRestore: Range } {\r\n    // Selection start replaces based on the current selection.\r\n    // Range inserts based on a provided range.\r\n    // Both have the potential to use the current selection to restore cursor position\r\n    // So in both cases we need to store the selection state.\r\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n    let rangeToRestore = null;\r\n    if (option.position == ContentPosition.Range) {\r\n        rangeToRestore = range;\r\n        range = option.range;\r\n    } else if (range) {\r\n        rangeToRestore = range.cloneRange();\r\n    }\r\n\r\n    return { range, rangeToRestore };\r\n}\r\n\r\n/**\r\n * Insert a DOM node into editor content\r\n * @param core The EditorCore object. No op if null.\r\n * @param option An insert option object to specify how to insert the node\r\n */\r\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\r\n    option = option || {\r\n        position: ContentPosition.SelectionStart,\r\n        insertOnNewLine: false,\r\n        updateCursor: true,\r\n        replaceSelection: true,\r\n    };\r\n    let contentDiv = core.contentDiv;\r\n\r\n    if (option.updateCursor) {\r\n        core.api.focus(core);\r\n    }\r\n\r\n    switch (option.position) {\r\n        case ContentPosition.Begin:\r\n        case ContentPosition.End: {\r\n            let isBegin = option.position == ContentPosition.Begin;\r\n            let block = getFirstLastBlockElement(contentDiv, isBegin);\r\n            let insertedNode: Node;\r\n            if (block) {\r\n                let refNode = isBegin ? block.getStartNode() : block.getEndNode();\r\n                if (\r\n                    option.insertOnNewLine ||\r\n                    refNode.nodeType == NodeType.Text ||\r\n                    isVoidHtmlElement(refNode)\r\n                ) {\r\n                    // For insert on new line, or refNode is text or void html element (HR, BR etc.)\r\n                    // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\r\n                    // first and last node. Insert before 'hello' or after 'world', but still inside DIV\r\n                    insertedNode = refNode.parentNode.insertBefore(\r\n                        node,\r\n                        isBegin ? refNode : refNode.nextSibling\r\n                    );\r\n                } else {\r\n                    // if the refNode can have child, use appendChild (which is like to insert as first/last child)\r\n                    // i.e. <div>hello</div>, the content will be inserted before/after hello\r\n                    insertedNode = refNode.insertBefore(node, isBegin ? refNode.firstChild : null);\r\n                }\r\n            } else {\r\n                // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\r\n                insertedNode = contentDiv.appendChild(node);\r\n            }\r\n\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n\r\n            break;\r\n        }\r\n        case ContentPosition.DomEnd:\r\n            // Use appendChild to insert the node at the end of the content div.\r\n            let insertedNode = contentDiv.appendChild(node);\r\n            // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n            // add a DIV wrapping\r\n            if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                wrap(insertedNode);\r\n            }\r\n            break;\r\n        case ContentPosition.Range:\r\n        case ContentPosition.SelectionStart:\r\n            let { range, rangeToRestore } = getInitialRange(core, option);\r\n\r\n            if (!range) {\r\n                return;\r\n            }\r\n\r\n            // if to replace the selection and the selection is not collapsed, remove the the content at selection first\r\n            if (option.replaceSelection && !range.collapsed) {\r\n                range.deleteContents();\r\n            }\r\n\r\n            let pos = Position.getStart(range);\r\n            let blockElement: BlockElement;\r\n\r\n            if (\r\n                option.insertOnNewLine &&\r\n                (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\r\n            ) {\r\n                pos = new Position(blockElement.getEndNode(), PositionType.After);\r\n            } else {\r\n                pos = adjustNodeInsertPosition(contentDiv, node, pos);\r\n            }\r\n\r\n            let nodeForCursor = node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\r\n            range = createRange(pos);\r\n            range.insertNode(node);\r\n            if (option.updateCursor && nodeForCursor) {\r\n                rangeToRestore = createRange(\r\n                    new Position(nodeForCursor, PositionType.After).normalize()\r\n                );\r\n            }\r\n            core.api.selectRange(core, rangeToRestore);\r\n\r\n            break;\r\n        case ContentPosition.Outside:\r\n            core.contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\r\n            break;\r\n    }\r\n\r\n    return true;\r\n};\r\n","import EditorCore, { Select, SelectRange } from '../interfaces/EditorCore';\r\nimport { Browser, contains, createRange, isRange } from 'roosterjs-editor-dom';\r\nimport { hasFocus } from './hasFocus';\r\n\r\n/**\r\n * Change the editor selection to the given range\r\n * @param core The EditorCore object\r\n * @param range The range to select\r\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\r\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\r\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\r\n */\r\nexport const selectRange: SelectRange = (\r\n    core: EditorCore,\r\n    range: Range,\r\n    skipSameRange?: boolean\r\n) => {\r\n    let selection: Selection;\r\n    let needAddRange = true;\r\n\r\n    if (\r\n        !contains(core.contentDiv, range) ||\r\n        !(selection = core.document.defaultView.getSelection())\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    if (selection.rangeCount > 0) {\r\n        // Workaround IE exception 800a025e\r\n        try {\r\n            let currentRange: Range;\r\n            // Do not remove/add range if current selection is the same with target range\r\n            // Without this check, execCommand() may fail in Edge since we changed the selection\r\n            if (\r\n                (skipSameRange || Browser.isEdge) &&\r\n                (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\r\n                currentRange.startContainer == range.startContainer &&\r\n                currentRange.startOffset == range.startOffset &&\r\n                currentRange.endContainer == range.endContainer &&\r\n                currentRange.endOffset == range.endOffset\r\n            ) {\r\n                needAddRange = false;\r\n            } else {\r\n                selection.removeAllRanges();\r\n            }\r\n        } catch (e) {}\r\n    }\r\n\r\n    if (needAddRange) {\r\n        selection.addRange(range);\r\n    }\r\n\r\n    if (!hasFocus(core)) {\r\n        core.cachedSelectionRange = range;\r\n    }\r\n\r\n    if (range.collapsed) {\r\n        // If selected, and current selection is collapsed,\r\n        // need to restore pending format state if exists.\r\n        core.corePlugins.domEvent.restorePendingFormatState();\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * @deprecated Only for compatibility with existing code, don't use ths function, use selectRange instead\r\n */\r\nexport const select: Select = (core: EditorCore, arg1: any, arg2?: any, arg3?: any, arg4?: any) => {\r\n    let range = isRange(arg1) ? arg1 : createRange(arg1, arg2, arg3, arg4);\r\n    return core.api.selectRange(core, range);\r\n};\r\n","import EditorCore, { TriggerEvent } from '../interfaces/EditorCore';\r\nimport EditorPlugin from '../interfaces/EditorPlugin';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Trigger a plugin event\r\n * @param core The EditorCore object\r\n * @param pluginEvent The event object to trigger\r\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\r\n */\r\nexport const triggerEvent: TriggerEvent = (\r\n    core: EditorCore,\r\n    pluginEvent: PluginEvent,\r\n    broadcast: boolean\r\n) => {\r\n    if (\r\n        broadcast ||\r\n        !core.eventHandlerPlugins.some(plugin => handledExclusively(pluginEvent, plugin))\r\n    ) {\r\n        core.eventHandlerPlugins.forEach(plugin => {\r\n            if (plugin.onPluginEvent) {\r\n                plugin.onPluginEvent(pluginEvent);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\r\n    if (\r\n        plugin.onPluginEvent &&\r\n        plugin.willHandleEventExclusively &&\r\n        plugin.willHandleEventExclusively(event)\r\n    ) {\r\n        plugin.onPluginEvent(event);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\r\nimport { EditorCore } from '..';\r\nimport { PluginEventType } from 'roosterjs-editor-types';\r\n\r\nconst EVENT_MAPPING: { [domEvent: string]: PluginEventType } = {\r\n    keypress: PluginEventType.KeyPress,\r\n    keydown: PluginEventType.KeyDown,\r\n    keyup: PluginEventType.KeyUp,\r\n    mousedown: PluginEventType.MouseDown,\r\n    [Browser.isIE ? 'textinput' : 'input']: PluginEventType.Input,\r\n};\r\n\r\n/**\r\n * Map DOM events to editor plugin events\r\n * @param core The EditorCore object\r\n */\r\nexport default function mapPluginEvents(core: EditorCore): (() => void)[] {\r\n    return Object.keys(EVENT_MAPPING).map(pluginEvent =>\r\n        core.api.attachDomEvent(core, pluginEvent, EVENT_MAPPING[pluginEvent])\r\n    );\r\n}\r\n","import { isDocumentFragment, isHTMLElement } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Converter for dark mode that runs all child elements of a node through the content transform function.\r\n * @param node The node containing HTML elements to convert.\r\n * @param skipRootElement Optional parameter to skip the root element of the Node passed in, if applicable.\r\n */\r\nexport function convertContentToDarkMode(\r\n    node: Node,\r\n    onExternalContentTransform?: (element: Element) => void,\r\n    skipRootElement?: boolean\r\n): () => void {\r\n    let childElements: HTMLElement[] = [];\r\n\r\n    // Get a list of all the decendents of a node.\r\n    // querySelectorAll doesn't return a live list when called on an HTMLElement\r\n    // So we use getElementsByTagName instead for HTMLElement types.\r\n    if (isHTMLElement(node)) {\r\n        childElements = Array.prototype.slice.call(node.getElementsByTagName('*'));\r\n        if (!skipRootElement) {\r\n            childElements.unshift(node);\r\n        }\r\n    } else if (isDocumentFragment(node)) {\r\n        childElements = Array.prototype.slice.call(node.querySelectorAll('*'));\r\n    }\r\n\r\n    return childElements.length > 0\r\n        ? () => {\r\n              childElements.forEach(element => {\r\n                  if (onExternalContentTransform) {\r\n                      onExternalContentTransform(element);\r\n                  } else {\r\n                      element.style.color = null;\r\n                      element.style.backgroundColor = null;\r\n                  }\r\n              });\r\n          }\r\n        : null;\r\n}\r\n","import cacheGetEventData from './cacheGetEventData';\r\nimport Editor from '../editor/Editor';\r\nimport { PluginEvent } from 'roosterjs-editor-types';\r\n\r\nconst CACHE_KEY_PREFIX = 'GET_ELEMENT_AT_CURSOR_';\r\n\r\n/**\r\n * Get an HTML element at cursor from event cache if it exists.\r\n * If an selector is specified, return the nearest ancestor of current node\r\n * which matches the selector, or null if no match found in editor.\r\n * @param editor The editor instance\r\n * @param event Event object to get cached object from\r\n * @param selector The expected selector. If null, return the element at cursor\r\n * @returns The element at cursor or the nearest ancestor with the tag name is specified\r\n */\r\nexport default function cacheGetElementAtCursor(\r\n    editor: Editor,\r\n    event: PluginEvent,\r\n    selector: string\r\n): HTMLElement {\r\n    return cacheGetEventData(event, CACHE_KEY_PREFIX + selector, () =>\r\n        editor.getElementAtCursor(selector)\r\n    );\r\n}\r\n","import { ChangeSource } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: Editor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: Editor, url: string): void;\r\n\r\nexport default function insertImage(editor: Editor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        let reader = new FileReader();\r\n        reader.onload = (event: ProgressEvent) => {\r\n            if (!editor.isDisposed()) {\r\n                insertImageWithSrc(editor, (event.target as FileReader).result as string);\r\n            }\r\n        };\r\n        reader.readAsDataURL(imageFile);\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: Editor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: Editor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(() => editor.select(new Position(table, PositionType.Begin).normalize()));\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, TableOperation } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: Editor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            if (!editor.select(start, end)) {\r\n                editor.select(editor.contains(td) ? td : vtable.getCurrentTd());\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, TableFormat } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: Editor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: Editor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { PositionContentSearcher } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: Editor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: PositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { Alignment, ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: Editor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: Editor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: Editor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import experimentSetIndentation from '../experiment/experimentSetIndentation';\r\nimport processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, Indentation, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: Editor, indentation: Indentation) {\r\n    if (editor.useExperimentFeatures()) {\r\n        experimentSetIndentation(editor, indentation);\r\n    } else {\r\n        let command: DocumentCommand.Indent | DocumentCommand.Outdent =\r\n            indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n        editor.addUndoSnapshot(() => {\r\n            editor.focus();\r\n            let listNode = editor.getElementAtCursor('OL,UL');\r\n            let newNode: Node;\r\n\r\n            if (listNode) {\r\n                // There is already list node, setIndentation() will increase/decrease the list level,\r\n                // so we need to process the list when change indentation\r\n                newNode = processList(editor, command);\r\n            } else {\r\n                // No existing list node, browser will create <Blockquote> node for indentation.\r\n                // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n                editor.getDocument().execCommand(command, false, null);\r\n                editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                    newNode = newNode || node;\r\n                    node.style.marginTop = '0px';\r\n                    node.style.marginBottom = '0px';\r\n                });\r\n            }\r\n\r\n            return newNode;\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import blockFormat from '../utils/blockFormat';\nimport { BlockElement, Indentation, Region } from 'roosterjs-editor-types';\nimport { Editor } from 'roosterjs-editor-core';\nimport { getSelectedBlockElementsInRegion } from 'roosterjs-editor-dom';\nimport {\n    collapseNodesInRegion,\n    createVListFromRegion,\n    findClosestElementAncestor,\n    getTagOfNode,\n    isNodeInRegion,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\n\n/**\n * @internal\n */\nexport default function experimentSetIndentation(editor: Editor, indentation: Indentation) {\n    const handler = indentation == Indentation.Increase ? indent : outdent;\n\n    blockFormat(editor, (region, start, end) => {\n        const blocks = getSelectedBlockElementsInRegion(region);\n        const blockGroups: BlockElement[][] = [[]];\n\n        for (let i = 0; i < blocks.length; i++) {\n            const startNode = blocks[i].getStartNode();\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\n\n            if (vList) {\n                blockGroups.push([]);\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\n                    i++;\n                }\n                vList.setIndentation(start, end, indentation);\n                vList.writeBack();\n            } else {\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\n            }\n        }\n\n        blockGroups.forEach(group => handler(region, group));\n    });\n}\n\nfunction indent(region: Region, blocks: BlockElement[]) {\n    if (blocks.length > 0) {\n        const startNode = blocks[0].getStartNode();\n        const endNode = blocks[blocks.length - 1].getEndNode();\n        const nodes = collapseNodesInRegion(region, [startNode, endNode]);\n        wrap(nodes, BlockWrapper);\n    }\n}\n\nfunction outdent(region: Region, blocks: BlockElement[]) {\n    blocks.forEach(blockElement => {\n        let node = blockElement.collapseToSingleElement();\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\n        if (quote) {\n            if (node == quote) {\n                node = wrap(toArray(node.childNodes));\n            }\n\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\n                node = splitBalancedNodeRange(node);\n            }\n\n            if (isNodeInRegion(region, node)) {\n                unwrap(node);\n            }\n        }\n    });\n}\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, ListType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: Editor) {\r\n    if (editor.useExperimentFeatures()) {\r\n        experimentToggleListType(editor, ListType.Unordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport { ChangeSource, DocumentCommand, ListType } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: Editor) {\r\n    if (editor.useExperimentFeatures()) {\r\n        experimentToggleListType(editor, ListType.Ordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertOrderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void) {\r\n    toggleTagCore(editor, BLOCKQUOTE_TAG, styler || DEFAULT_STYLER);\r\n}\r\n","import toggleTagCore from '../utils/toggleTagCore';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { getTagOfNode, unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst CODE_NODE_TAG = 'CODE';\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: Editor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    toggleTagCore(editor, PRE_TAG, styler, wrapFunction, unwrapFunction);\r\n}\r\n\r\nfunction wrapFunction(nodes: Node[]): HTMLElement {\r\n    let codeBlock = wrap(nodes, CODE_TAG);\r\n    return wrap(codeBlock, PRE_TAG);\r\n}\r\n\r\nfunction unwrapFunction(node: HTMLElement): Node {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n\r\n    let firstChild = node.childNodes[0];\r\n    if (node.childNodes.length == 1 && getTagOfNode(firstChild) == CODE_NODE_TAG) {\r\n        unwrap(firstChild);\r\n    }\r\n\r\n    return unwrap(node);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: Editor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, QueryScope } from 'roosterjs-editor-types';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: Editor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                styleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser } from 'roosterjs-editor-dom';\nimport { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\nimport { FontSizeChange, PluginEventType, PluginKeyboardEvent } from 'roosterjs-editor-types';\nimport {\n    changeFontSize,\n    toggleBold,\n    toggleItalic,\n    toggleUnderline,\n    toggleBullet,\n    toggleNumbering,\n} from 'roosterjs-editor-api';\n\ninterface ShortcutCommand {\n    winKey: number;\n    macKey: number;\n    action: (editor: Editor) => any;\n}\n\nfunction createCommand(winKey: number, macKey: number, action: (editor: Editor) => any) {\n    return {\n        winKey,\n        macKey,\n        action,\n    };\n}\n\nconst commands: ShortcutCommand[] = [\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\n        editor => changeFontSize(editor, FontSizeChange.Increase)\n    ),\n    createCommand(\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\n        Keys.Meta | Keys.Shift | Keys.COMMA,\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\n    ),\n];\n\n/**\n * DefaultShortcut edit feature, provides shortcuts for the following features:\n * Ctrl/Meta+B: toggle bold style\n * Ctrl/Meta+I: toggle italic style\n * Ctrl/Meta+U: toggle underline style\n * Ctrl/Meta+Z: undo\n * Ctrl+Y/Meta+Shift+Z: redo\n * Ctrl/Meta+PERIOD: toggle bullet list\n * Ctrl/Meta+/: toggle numbering list\n * Ctrl/Meta+Shift+>: increase font size\n * Ctrl/Meta+Shift+<: decrease font size\n */\nexport const DefaultShortcut: ContentEditFeature = {\n    allowFunctionKeys: true,\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\n    shouldHandleEvent: cacheGetCommand,\n    handleEvent: (event, editor) => {\n        let command = cacheGetCommand(event);\n        if (command) {\n            command.action(editor);\n            event.rawEvent.preventDefault();\n            event.rawEvent.stopPropagation();\n        }\n    },\n};\n\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\n        let e = event.rawEvent;\n        let key =\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\n            event.eventType == PluginEventType.KeyDown && !e.altKey\n                ? e.which |\n                  (e.metaKey && Keys.Meta) |\n                  (e.shiftKey && Keys.Shift) |\n                  (e.ctrlKey && Keys.Ctrl)\n                : 0;\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\n    });\n}\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\nimport {\n    Browser,\n    fromHtml,\n    isPositionAtBeginningOf,\n    Position,\n    getTagOfNode,\n} from 'roosterjs-editor-dom';\n\n// Edge can sometimes lose current format when Enter to new line.\n// So here we add an extra SPAN for Edge to workaround this bug\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\n    TD: 'TABLE',\n    TH: 'TABLE',\n    LI: 'OL,UL',\n};\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\n\n/**\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\n * document\n */\nexport const InsertLineBeforeStructuredNodeFeature: ContentEditFeature = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetStructuredElement,\n    handleEvent: (event, editor) => {\n        let element = cacheGetStructuredElement(event, editor);\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\n        editor.addUndoSnapshot(() => {\n            element.parentNode.insertBefore(div, element);\n            // Select the new line when we are in table. This is the same behavior with Word\n            if (getTagOfNode(element) == 'TABLE') {\n                editor.select(new Position(div, PositionType.Begin).normalize());\n            }\n        });\n        event.rawEvent.preventDefault();\n    },\n};\n\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: Editor) {\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\n        // Provide a chance to keep browser default behavior by pressing SHIFT\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\n\n        if (element) {\n            let range = editor.getSelectionRange();\n            if (\n                range &&\n                range.collapsed &&\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\n            ) {\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\n            }\n        }\n\n        return null;\n    });\n}\n","import { ContentEditFeature, Keys } from 'roosterjs-editor-core';\nimport { isRtl, Position } from 'roosterjs-editor-dom';\n\nexport const NoCycleCursorMove: ContentEditFeature = {\n    keys: [Keys.LEFT, Keys.RIGHT],\n    allowFunctionKeys: true,\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\n        let range: Range;\n        let position: Position;\n\n        if (\n            !ctrlOrMeta ||\n            !(range = editor.getSelectionRange()) ||\n            !range.collapsed ||\n            !(position = Position.getStart(range)) ||\n            !editor.isPositionAtBeginning(position)\n        ) {\n            return false;\n        }\n\n        let rtl = isRtl(position.element);\n        let rawEvent = event.rawEvent;\n\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\n    },\n    handleEvent: event => {\n        event.rawEvent.preventDefault();\n    },\n};\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\nimport { contains, getTagOfNode, isVoidHtmlElement, Position, VTable } from 'roosterjs-editor-dom';\nimport { NodeType, PluginEvent, PositionType } from 'roosterjs-editor-types';\n\n/**\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\n */\nexport const TabInTable: ContentEditFeature = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let shift = event.rawEvent.shiftKey;\n        let td = cacheGetTableCell(event, editor);\n        for (\n            let vtable = new VTable(td),\n                step = shift ? -1 : 1,\n                row = vtable.row,\n                col = vtable.col + step;\n            ;\n            col += step\n        ) {\n            if (col < 0 || col >= vtable.cells[row].length) {\n                row += step;\n                if (row < 0 || row >= vtable.cells.length) {\n                    editor.select(vtable.table, shift ? PositionType.Before : PositionType.After);\n                    break;\n                }\n                col = shift ? vtable.cells[row].length - 1 : 0;\n            }\n            let cell = vtable.getCell(row, col);\n            if (cell.td) {\n                editor.select(cell.td, PositionType.Begin);\n                break;\n            }\n        }\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\n * in table\n */\nexport const UpDownInTable: ContentEditFeature = {\n    keys: [Keys.UP, Keys.DOWN],\n    shouldHandleEvent: cacheGetTableCell,\n    handleEvent: (event, editor) => {\n        let td = cacheGetTableCell(event, editor);\n        let vtable = new VTable(td);\n        let isUp = event.rawEvent.which == Keys.UP;\n        let step = isUp ? -1 : 1;\n        let targetTd: HTMLTableCellElement = null;\n        let hasShiftKey = event.rawEvent.shiftKey;\n        let { anchorNode, anchorOffset } = editor.getSelection();\n\n        for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\n            let cell = vtable.getCell(row, vtable.col);\n            if (cell.td && cell.td != td) {\n                targetTd = cell.td;\n                break;\n            }\n        }\n\n        editor.runAsync(() => {\n            let newContainer = editor.getElementAtCursor();\n            if (\n                contains(vtable.table, newContainer) &&\n                !contains(td, newContainer, true /*treatSameNodeAsContain*/)\n            ) {\n                let newPos = targetTd\n                    ? new Position(targetTd, PositionType.Begin)\n                    : new Position(vtable.table, isUp ? PositionType.Before : PositionType.After);\n                if (hasShiftKey) {\n                    newPos =\n                        newPos.node.nodeType == NodeType.Element && isVoidHtmlElement(newPos.node)\n                            ? new Position(\n                                  newPos.node,\n                                  newPos.isAtEnd ? PositionType.After : PositionType.Before\n                              )\n                            : newPos;\n                    editor\n                        .getSelection()\n                        .setBaseAndExtent(anchorNode, anchorOffset, newPos.node, newPos.offset);\n                } else {\n                    editor.select(newPos);\n                }\n            }\n        });\n    },\n};\n\nfunction cacheGetTableCell(event: PluginEvent, editor: Editor): HTMLTableCellElement {\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\n        let pos = editor.getFocusedPosition();\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\n        return (\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\n        );\n    });\n}\n","import { createRange } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    NodePosition,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetContentSearcher,\n    cacheGetEventData,\n    ContentEditFeature,\n    Editor,\n    Keys,\n} from 'roosterjs-editor-core';\n\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nfunction generateBasicMarkdownFeature(\n    key: Keys,\n    triggerCharacter: string,\n    elementTag: string,\n    useShiftKey: boolean\n): ContentEditFeature {\n    return {\n        keys: [key],\n        shouldHandleEvent: (event, editor) =>\n            event.rawEvent.shiftKey === useShiftKey &&\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\n        handleEvent: (event, editor) => {\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\n            editor.runAsync(() => {\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\n            });\n        },\n    };\n}\n\nfunction cacheGetRangeForMarkdownOperation(\n    event: PluginKeyboardEvent,\n    editor: Editor,\n    triggerCharacter: string\n): Range {\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\n        const searcher = cacheGetContentSearcher(event, editor);\n\n        let startPosition: NodePosition;\n        let endPosition: NodePosition;\n        searcher.forEachTextInlineElement(textInlineElement => {\n            if (endPosition && startPosition) {\n                return true;\n            }\n            const inlineTextContent = textInlineElement.getTextContent();\n\n            // special case for immediately preceeding character being whitespace\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\n                return false;\n            }\n\n            // special case for consecutive trigger characters\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\n                return false;\n            }\n\n            if (!endPosition) {\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\n            }\n            if (inlineTextContent[0] == triggerCharacter) {\n                startPosition = textInlineElement.getStartPosition();\n            } else {\n                let contentIndex = inlineTextContent.length - 1;\n                for (; contentIndex > 0; contentIndex--) {\n                    if (startPosition) {\n                        return true;\n                    }\n                    if (\n                        inlineTextContent[contentIndex] == triggerCharacter &&\n                        inlineTextContent[contentIndex - 1].trim().length == 0\n                    ) {\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\n                        return true;\n                    }\n                }\n            }\n        });\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\n    });\n}\n\nfunction handleMarkdownEvent(\n    event: PluginKeyboardEvent,\n    editor: Editor,\n    triggerCharacter: string,\n    elementTag: string\n) {\n    editor.performAutoComplete(() => {\n        const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\n        if (!!range) {\n            // get the text content range\n            const textContentRange = range.cloneRange();\n            textContentRange.setStart(\n                textContentRange.startContainer,\n                textContentRange.startOffset + 1\n            );\n\n            // set the removal range to include the typed last character.\n            range.setEnd(range.endContainer, range.endOffset + 1);\n\n            // extract content and put it into a new element.\n            const elementToWrap = editor.getDocument().createElement(elementTag);\n            elementToWrap.appendChild(textContentRange.extractContents());\n            range.deleteContents();\n\n            // ZWS here ensures we don't end up inside the newly created node.\n            const nonPrintedSpaceTextNode = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\n            range.insertNode(nonPrintedSpaceTextNode);\n            range.insertNode(elementToWrap);\n            editor.select(nonPrintedSpaceTextNode, PositionType.End);\n        }\n    }, ChangeSource.Format);\n}\n\n/**\n * Markdown bold feature. Bolds text with markdown shortcuts.\n */\nexport const MarkdownBold: ContentEditFeature = generateBasicMarkdownFeature(\n    Keys.EIGHT_ASTIRISK,\n    '*',\n    'b',\n    true\n);\n\n/**\n * Markdown italics feature. Italicises text with markdown shortcuts.\n */\nexport const MarkdownItalic: ContentEditFeature = generateBasicMarkdownFeature(\n    Keys.DASH_UNDERSCORE,\n    '_',\n    'i',\n    true\n);\n\n/**\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\n */\nexport const MarkdownStrikethru: ContentEditFeature = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '~',\n    's',\n    true\n);\n\n/**\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\n */\nexport const MarkdownInlineCode: ContentEditFeature = generateBasicMarkdownFeature(\n    Keys.GRAVE_TILDE,\n    '`',\n    'code',\n    false\n);\n","import { setIndentation, toggleBullet, toggleNumbering } from 'roosterjs-editor-api';\nimport {\n    getTagOfNode,\n    isHTMLOListElement,\n    isNodeEmpty,\n    isPositionAtBeginningOf,\n    Position,\n} from 'roosterjs-editor-dom';\nimport {\n    cacheGetContentSearcher,\n    cacheGetElementAtCursor,\n    Editor,\n    ContentEditFeature,\n    GenericContentEditFeature,\n    Keys,\n} from 'roosterjs-editor-core';\nimport {\n    ContentChangedEvent,\n    Indentation,\n    PluginKeyboardEvent,\n    PositionType,\n    NodeType,\n} from 'roosterjs-editor-types';\n\n/**\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\n */\nexport const IndentWhenTab: ContentEditFeature = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Increase);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\n */\nexport const OutdentWhenShiftTab: ContentEditFeature = {\n    keys: [Keys.TAB],\n    shouldHandleEvent: (event, editor) =>\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\n    handleEvent: (event, editor) => {\n        setIndentation(editor, Indentation.Decrease);\n        event.rawEvent.preventDefault();\n    },\n};\n\n/**\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\n * BACKSPACE at beginning of a list item\n */\nexport const MergeInNewLine: ContentEditFeature = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\n        let range = editor.getSelectionRange();\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\n    },\n    handleEvent: (event, editor) => {\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\n        if (li.previousSibling) {\n            editor.runAsync(() => {\n                let br = editor.getDocument().createElement('BR');\n                editor.insertNode(br);\n                editor.select(br, PositionType.After);\n            });\n        } else {\n            toggleListAndPreventDefault(event, editor);\n        }\n    },\n};\n\n/**\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\n * BACKSPACE at the first and empty line of a list\n */\nexport const OutdentWhenBackOn1stEmptyLine: ContentEditFeature = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\n        return li && isNodeEmpty(li) && !li.previousSibling;\n    },\n    handleEvent: toggleListAndPreventDefault,\n};\n\n/**\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\n * ENTER at the beginning of an empty line of a list\n */\nexport const OutdentWhenEnterOnEmptyLine: ContentEditFeature = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let li = cacheGetElementAtCursor(editor, event, 'LI');\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\n    },\n    handleEvent: (event, editor) => {\n        editor.performAutoComplete(() => toggleListAndPreventDefault(event, editor));\n    },\n};\n\n/**\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\n * When user input \"1. \", convert into a numbering list\n * When user input \"- \" or \"* \", convert into a bullet list\n */\nexport const AutoBullet: ContentEditFeature = {\n    keys: [Keys.SPACE],\n    shouldHandleEvent: (event, editor) => {\n        if (!cacheGetListElement(event, editor)) {\n            let searcher = cacheGetContentSearcher(event, editor);\n            let textBeforeCursor = searcher.getSubStringBefore(3);\n\n            // Auto list is triggered if:\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\n            // 2. There's no non-text inline entities before cursor\n            return (\n                ['*', '-', '1.'].indexOf(textBeforeCursor) >= 0 &&\n                !searcher.getNearestNonTextInlineElement()\n            );\n        }\n        return false;\n    },\n    handleEvent: (event, editor) => {\n        editor.runAsync(() => {\n            editor.performAutoComplete(() => {\n                let searcher = editor.getContentSearcherOfCursor();\n                let textBeforeCursor = searcher.getSubStringBefore(3);\n                let rangeToDelete = searcher.getRangeFromText(\n                    textBeforeCursor,\n                    true /*exactMatch*/\n                );\n\n                if (rangeToDelete) {\n                    rangeToDelete.deleteContents();\n                    const node = rangeToDelete.startContainer;\n                    if (\n                        node?.nodeType == NodeType.Text &&\n                        node.nodeValue == '' &&\n                        !node.previousSibling &&\n                        !node.nextSibling\n                    ) {\n                        const br = editor.getDocument().createElement('BR');\n                        editor.insertNode(br);\n                        editor.select(br, PositionType.Before);\n                    }\n                }\n\n                if (textBeforeCursor.indexOf('1.') == 0) {\n                    toggleNumbering(editor);\n                } else {\n                    toggleBullet(editor);\n                }\n            });\n        });\n    },\n};\n\n/**\n * Get an instance of SmartOrderedList edit feature. This feature provides the ability to use different\n * number style for different level of numbering list.\n * @param styleList The list of number styles used for this feature.\n * See https://www.w3schools.com/cssref/pr_list-style-type.asp for more information\n */\nexport function getSmartOrderedList(\n    styleList: string[]\n): GenericContentEditFeature<ContentChangedEvent> {\n    return {\n        keys: [Keys.CONTENTCHANGED], // Triggered by ContentChangedEvent\n        shouldHandleEvent: (event, editor) => isHTMLOListElement(event.data),\n        handleEvent: (event, editor) => {\n            let ol = event.data as HTMLOListElement;\n            let parentOl = editor.getElementAtCursor('OL', ol.parentNode) as HTMLOListElement;\n            if (parentOl) {\n                // The style list must has at least one value. If no value is passed in, fallback to decimal\n                let styles = styleList && styleList.length > 0 ? styleList : ['decimal'];\n                ol.style.listStyle =\n                    styles[(styles.indexOf(parentOl.style.listStyle) + 1) % styles.length];\n            }\n        },\n    };\n}\n\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: Editor) {\n    let listInfo = cacheGetListElement(event, editor);\n    if (listInfo) {\n        let listElement = listInfo[0];\n        let tag = getTagOfNode(listElement);\n        if (tag == 'UL') {\n            toggleBullet(editor);\n        } else if (tag == 'OL') {\n            toggleNumbering(editor);\n        }\n        editor.focus();\n        event.rawEvent.preventDefault();\n    }\n}\n\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: Editor) {\n    let li = cacheGetElementAtCursor(editor, event, 'LI,TABLE');\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\n    return listElement ? [listElement, li] : null;\n}\n","import { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\nimport { PluginKeyboardEvent, PositionType } from 'roosterjs-editor-types';\nimport {\n    getTagOfNode,\n    isNodeEmpty,\n    splitBalancedNodeRange,\n    toArray,\n    unwrap,\n    wrap,\n} from 'roosterjs-editor-dom';\n\nconst QUOTE_TAG = 'BLOCKQUOTE';\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\n\n/**\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\n */\nexport const UnquoteWhenBackOnEmpty1stLine: ContentEditFeature = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\n    },\n    handleEvent: splitQuote,\n};\n\n/**\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\n * user press ENTER on an empty line of a BLOCKQUOTE\n */\nexport const UnquoteWhenEnterOnEmptyLine: ContentEditFeature = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let shift = event.rawEvent.shiftKey;\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\n    },\n    handleEvent: (event, editor) => editor.performAutoComplete(() => splitQuote(event, editor)),\n};\n\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: Editor): Node {\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\n            let pos = editor.getFocusedPosition();\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\n            if (block) {\n                let node =\n                    block.getStartNode() == quote\n                        ? block.getStartNode()\n                        : block.collapseToSingleElement();\n                return isNodeEmpty(node) ? node : null;\n            }\n        }\n\n        return null;\n    });\n}\n\nfunction splitQuote(event: PluginKeyboardEvent, editor: Editor) {\n    editor.addUndoSnapshot(() => {\n        let childOfQuote = cacheGetQuoteChild(event, editor);\n        let parent: Node;\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\n        }\n        parent = splitBalancedNodeRange(childOfQuote);\n        unwrap(parent);\n        editor.select(childOfQuote, PositionType.Begin);\n    });\n    event.rawEvent.preventDefault();\n}\n","export * from './plugins/CustomReplace/index';\n","export { default as CustomReplace } from './CustomReplace';\nexport { default as Replacement } from './Replacement';\n","import Replacement from './Replacement';\nimport { cacheGetContentSearcher, Editor, EditorPlugin } from 'roosterjs-editor-core';\nimport { PluginEvent, PluginEventType, PositionType } from 'roosterjs-editor-types';\n\nconst makeReplacement = (\n    sourceString: string,\n    replacementHTML: string,\n    matchSourceCaseSensitive: boolean\n): Replacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\n\nconst defaultReplacements: Replacement[] = [\n    makeReplacement(':)', '🙂', true),\n    makeReplacement(';)', '😉', true),\n    makeReplacement(':O', '😲', true),\n    makeReplacement(':o', '😯', true),\n    makeReplacement('<3', '❤️', true),\n];\n\n/**\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\n * content edit feature\n */\nexport default class CustomReplacePlugin implements EditorPlugin {\n    private longestReplacementLength: number;\n    private editor: Editor;\n    private replacements: Replacement[];\n    private replacementEndCharacters: Set<string>;\n\n    /**\n     * Create instance of CustomReplace plugin\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\n     */\n    constructor(replacements: Replacement[] = defaultReplacements) {\n        this.updateReplacements(replacements);\n    }\n\n    /**\n     * Set the replacements that this plugin is looking for.\n     * @param newReplacements new set of replacements for this plugin\n     */\n    updateReplacements(newReplacements: Replacement[]) {\n        this.replacements = newReplacements;\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'CustomReplace';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: Editor): void {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        this.editor = null;\n    }\n\n    public onPluginEvent(event: PluginEvent) {\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\n            return;\n        }\n\n        // Exit early on input events that do not insert a replacement's final character.\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\n            return;\n        }\n\n        // Get the matching replacement\n        const range = this.editor.getSelectionRange();\n        if (range == null) {\n            return;\n        }\n        const searcher = cacheGetContentSearcher(event, this.editor);\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\n\n        const replacement = this.getMatchingReplacement(stringToSearch);\n        if (replacement == null) {\n            return;\n        }\n\n        // Reconstruct a selection of the text on the document that matches the\n        // replacement we selected.\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\n\n        // parse the html string off the dom and inline the resulting element.\n        const document = this.editor.getDocument();\n        const parsingSpan = document.createElement('span');\n        parsingSpan.innerHTML = replacement.replacementHTML;\n        const nodeToInsert =\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\n\n        // Switch the node for the selection range\n        this.editor.performAutoComplete(() => {\n            matchingRange.deleteContents();\n            matchingRange.insertNode(nodeToInsert);\n            this.editor.select(nodeToInsert, PositionType.End);\n        });\n    }\n\n    private getMatchingReplacement(stringToSearch: string): Replacement | null {\n        if (stringToSearch.length == 0) {\n            return null;\n        }\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\n        for (const replacement of this.replacements) {\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\n                ? [stringToSearch, replacement.sourceString]\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\n\n            if (\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\n                replacementMatch\n            ) {\n                return replacement;\n            }\n        }\n        return null;\n    }\n}\n\nfunction getLongestReplacementSourceLength(replacements: Replacement[]): number {\n    return Math.max.apply(\n        null,\n        replacements.map(replacement => replacement.sourceString.length)\n    );\n}\n\nfunction getReplacementEndCharacters(replacements: Replacement[]): Set<string> {\n    const endChars = new Set<string>();\n    for (let replacement of replacements) {\n        const sourceString = replacement.sourceString;\n        if (sourceString.length == 0) {\n            continue;\n        }\n        const lastChar = sourceString[sourceString.length - 1];\n        if (!replacement.matchSourceCaseSensitive) {\n            endChars.add(lastChar.toLocaleLowerCase());\n            endChars.add(lastChar.toLocaleUpperCase());\n        } else {\n            endChars.add(lastChar);\n        }\n    }\n    return endChars;\n}\n","export * from './plugins/HyperLink/index';\n","export { default as HyperLink } from './HyperLink';\n","import { Browser } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin, isCtrlOrMetaPressed } from 'roosterjs-editor-core';\nimport { PluginEvent, PluginEventType } from 'roosterjs-editor-types';\n\n/**\n * An editor plugin that show a tooltip for existing link\n */\nexport default class HyperLink implements EditorPlugin {\n    private editor: Editor;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of HyperLink class\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\n     * Default value is to return the href itself. If null, there will be no tooltip text.\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\n     */\n    constructor(\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\n        private target?: string,\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Hyperlink';\n    }\n\n    /**\n     * Initialize this plugin\n     * @param editor The editor instance\n     */\n    public initialize(editor: Editor): void {\n        this.editor = editor;\n        this.disposer =\n            this.getTooltipCallback &&\n            editor.addDomEventHandler({ mouseover: this.onMouse, mouseout: this.onMouse });\n    }\n\n    protected onMouse = (e: MouseEvent) => {\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\n        const href = this.tryGetHref(a);\n\n        if (href) {\n            this.editor.setEditorDomAttribute(\n                'title',\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\n            );\n        }\n    };\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose(): void {\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = null;\n        }\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent): void {\n        if (event.eventType == PluginEventType.MouseUp) {\n            const anchor = this.editor.getElementAtCursor(\n                'A',\n                <Node>event.rawEvent.srcElement\n            ) as HTMLAnchorElement;\n\n            if (anchor) {\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\n                    return;\n                }\n\n                let href: string;\n                if (\n                    !Browser.isFirefox &&\n                    (href = this.tryGetHref(anchor)) &&\n                    isCtrlOrMetaPressed(event.rawEvent) &&\n                    event.rawEvent.button === 0\n                ) {\n                    try {\n                        const target = this.target || '_blank';\n                        const window = this.editor.getDocument().defaultView;\n                        window.open(href, target);\n                    } catch {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Try get href from an anchor element\n     * The reason this is put in a try-catch is that\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\n     */\n    private tryGetHref(anchor: HTMLAnchorElement): string {\n        try {\n            return anchor ? anchor.href : null;\n        } catch {}\n    }\n}\n","export * from './plugins/ImageResize/index';\n","export { default as ImageResize } from './ImageResize';\n","import { contains, getTagOfNode, toArray } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\nimport {\n    ContentChangedEvent,\n    ChangeSource,\n    NodeType,\n    PluginEvent,\n    PluginEventType,\n    ExtractContentEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\nconst BEGIN_TAG = 'RoosterJsImageResizingBegin';\nconst END_TAG = 'RoosterJsImageResizingEnd';\nconst EXTRACT_HTML_REGEX = new RegExp(\n    `<!--${BEGIN_TAG}-->[\\\\s\\\\S]*(<img\\\\s[^>]+>)[\\\\s\\\\S]*<!--${END_TAG}-->`,\n    'gim'\n);\nconst DELETE_KEYCODE = 46;\nconst BACKSPACE_KEYCODE = 8;\nconst SHIFT_KEYCODE = 16;\nconst CTRL_KEYCODE = 17;\nconst ALT_KEYCODE = 18;\n\n/**\n * ImageResize plugin provides the ability to resize an inline image in editor\n */\nexport default class ImageResize implements EditorPlugin {\n    private editor: Editor;\n    private startPageX: number;\n    private startPageY: number;\n    private startWidth: number;\n    private startHeight: number;\n    private resizeDiv: HTMLElement;\n    private direction: string;\n    private disposer: () => void;\n\n    /**\n     * Create a new instance of ImageResize\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\n     * that the tag must be IMG regardless what the selector is\n     */\n    constructor(\n        private minWidth: number = 10,\n        private minHeight: number = 10,\n        private selectionBorderColor: string = '#DB626C',\n        private forcePreserveRatio: boolean = false,\n        private resizableImageSelector: string = 'img'\n    ) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'ImageResize';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.disposer = editor.addDomEventHandler({\n            dragstart: this.onDragStart,\n            blur: this.onBlur,\n        });\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        if (this.resizeDiv) {\n            this.hideResizeHandle();\n        }\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(e: PluginEvent) {\n        if (e.eventType == PluginEventType.MouseDown) {\n            const event = e.rawEvent;\n            const target = <HTMLElement>(event.srcElement || event.target);\n\n            if (getTagOfNode(target) == 'IMG') {\n                const parent = target.parentNode as HTMLElement;\n                const elements = parent\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\n                    : [];\n                if (elements.indexOf(target) < 0) {\n                    return;\n                }\n\n                target.contentEditable = 'false';\n                const currentImg = this.getSelectedImage();\n                if (currentImg && currentImg != target) {\n                    this.hideResizeHandle();\n                }\n\n                if (!this.resizeDiv) {\n                    this.showResizeHandle(<HTMLImageElement>target);\n                }\n            } else if (this.resizeDiv && !contains(this.resizeDiv, target)) {\n                this.hideResizeHandle();\n            }\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\n            const event = e.rawEvent;\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\n                this.editor.addUndoSnapshot(() => {\n                    this.removeResizeDiv(this.resizeDiv);\n                });\n                this.resizeDiv = null;\n                event.preventDefault();\n                this.resizeDiv = null;\n            } else if (\n                event.which != SHIFT_KEYCODE &&\n                event.which != CTRL_KEYCODE &&\n                event.which != ALT_KEYCODE\n            ) {\n                this.hideResizeHandle(true /*selectImage*/);\n            }\n        } else if (\n            e.eventType == PluginEventType.ContentChanged &&\n            (<ContentChangedEvent>e).source != ChangeSource.ImageResize\n        ) {\n            this.editor.queryElements('img', this.removeResizeDivIfAny);\n            this.resizeDiv = null;\n        } else if (e.eventType == PluginEventType.ExtractContent) {\n            const event = <ExtractContentEvent>e;\n            event.content = this.extractHtml(event.content);\n        }\n    }\n\n    /**\n     * Select a given IMG element, show the resize handle\n     * @param img The IMG element to select\n     */\n    showResizeHandle(img: HTMLImageElement) {\n        this.resizeDiv = this.createResizeDiv(img);\n        img.contentEditable = 'false';\n        this.editor.select(this.resizeDiv, PositionType.After);\n    }\n\n    /**\n     * Hide resize handle of current selected image\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\n     */\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\n        let img = this.getSelectedImage();\n        let parent = this.resizeDiv && this.resizeDiv.parentNode;\n        if (parent) {\n            if (img) {\n                img.removeAttribute('contentEditable');\n                let referenceNode =\n                    this.resizeDiv.previousSibling &&\n                    this.resizeDiv.previousSibling.nodeType == NodeType.Comment\n                        ? this.resizeDiv.previousSibling\n                        : this.resizeDiv;\n                parent.insertBefore(img, referenceNode);\n\n                if (selectImageAfterUnSelect) {\n                    this.editor.select(img);\n                } else {\n                    this.editor.select(img, PositionType.After);\n                }\n            }\n            this.removeResizeDiv(this.resizeDiv);\n            this.resizeDiv = null;\n        }\n    }\n\n    private startResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            this.startPageX = e.pageX;\n            this.startPageY = e.pageY;\n            this.startWidth = img.clientWidth;\n            this.startHeight = img.clientHeight;\n            this.editor.addUndoSnapshot();\n\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).style.cursor;\n        }\n\n        this.stopEvent(e);\n    };\n\n    private doResize = (e: MouseEvent) => {\n        let img = this.getSelectedImage();\n        if (this.editor && img) {\n            let widthChange = e.pageX - this.startPageX;\n            let heightChange = e.pageY - this.startPageY;\n            let newWidth = Math.max(\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\n                this.minWidth\n            );\n            let newHeight = Math.max(\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\n                this.minHeight\n            );\n\n            if (this.forcePreserveRatio || e.shiftKey) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n                if (ratio > 0) {\n                    if (newWidth < newHeight * ratio) {\n                        newWidth = newHeight * ratio;\n                    } else {\n                        newHeight = newWidth / ratio;\n                    }\n                }\n            }\n\n            img.style.width = newWidth + 'px';\n            img.style.height = newHeight + 'px';\n\n            // double check\n            if (this.forcePreserveRatio || e.shiftKey) {\n                let ratio =\n                    this.startWidth > 0 && this.startHeight > 0\n                        ? (this.startWidth * 1.0) / this.startHeight\n                        : 0;\n\n                const clientWidth = Math.floor(img.clientWidth);\n                const clientHeight = Math.floor(img.clientHeight);\n                newWidth = Math.floor(newWidth);\n                newHeight = Math.floor(newHeight);\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\n                    if (clientHeight < newHeight) {\n                        newWidth = clientHeight * ratio;\n                    } else {\n                        newHeight = clientWidth / ratio;\n                    }\n                    img.style.width = newWidth + 'px';\n                    img.style.height = newHeight + 'px';\n                }\n            }\n        }\n        this.stopEvent(e);\n    };\n\n    private finishResize = (e: MouseEvent) => {\n        var img = this.getSelectedImage() as HTMLImageElement;\n        if (this.editor && img) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\n            let width = img.clientWidth;\n            let height = img.clientHeight;\n            img.style.width = width + 'px';\n            img.style.height = height + 'px';\n            img.width = width;\n            img.height = height;\n            this.resizeDiv.style.width = '';\n            this.resizeDiv.style.height = '';\n        }\n        this.direction = null;\n        this.editor.addUndoSnapshot();\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize);\n        this.stopEvent(e);\n    };\n\n    private createResizeDiv(target: HTMLElement) {\n        let document = this.editor.getDocument();\n        let resizeDiv = document.createElement('DIV');\n        let parent = target.parentNode;\n        parent.insertBefore(resizeDiv, target);\n        parent.insertBefore(document.createComment(BEGIN_TAG), resizeDiv);\n        parent.insertBefore(document.createComment(END_TAG), resizeDiv.nextSibling);\n\n        resizeDiv.style.position = 'relative';\n        resizeDiv.style.display = 'inline-flex';\n        resizeDiv.contentEditable = 'false';\n        resizeDiv.addEventListener('click', this.stopEvent);\n        resizeDiv.appendChild(target);\n        ['nw', 'ne', 'sw', 'se'].forEach(pos => {\n            let div = document.createElement('DIV');\n            resizeDiv.appendChild(div);\n            div.style.position = 'absolute';\n            div.style.width = '7px';\n            div.style.height = '7px';\n            div.style.backgroundColor = this.selectionBorderColor;\n            div.style.cursor = pos + '-resize';\n            if (this.isNorth(pos)) {\n                div.style.top = '-3px';\n            } else {\n                div.style.bottom = '-3px';\n            }\n            if (this.isWest(pos)) {\n                div.style.left = '-3px';\n            } else {\n                div.style.right = '-3px';\n            }\n            div.addEventListener('mousedown', this.startResize);\n        });\n        let div = document.createElement('DIV');\n        resizeDiv.appendChild(div);\n        div.style.position = 'absolute';\n        div.style.top = '0';\n        div.style.left = '0';\n        div.style.right = '0';\n        div.style.bottom = '0';\n        div.style.border = 'solid 1px ' + this.selectionBorderColor;\n        div.style.pointerEvents = 'none';\n        return resizeDiv;\n    }\n\n    private stopEvent = (e: UIEvent) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    private removeResizeDiv(resizeDiv: HTMLElement) {\n        if (this.editor && this.editor.contains(resizeDiv)) {\n            [resizeDiv.previousSibling, resizeDiv.nextSibling].forEach(comment => {\n                if (comment && comment.nodeType == NodeType.Comment) {\n                    this.editor.deleteNode(comment);\n                }\n            });\n            this.editor.deleteNode(resizeDiv);\n        }\n    }\n\n    private removeResizeDivIfAny = (img: HTMLImageElement) => {\n        let div = img && (img.parentNode as HTMLElement);\n        let previous = div && div.previousSibling;\n        let next = div && div.nextSibling;\n        if (\n            previous &&\n            previous.nodeType == NodeType.Comment &&\n            previous.nodeValue == BEGIN_TAG &&\n            next &&\n            next.nodeType == NodeType.Comment &&\n            next.nodeValue == END_TAG\n        ) {\n            div.parentNode.insertBefore(img, div);\n            this.removeResizeDiv(div);\n        }\n    };\n\n    private onBlur = (e: FocusEvent) => {\n        this.hideResizeHandle();\n    };\n\n    private extractHtml(html: string): string {\n        return html.replace(EXTRACT_HTML_REGEX, (...groups: string[]) => {\n            return groups[1].replace(\n                /(\\s*contenteditable=\"false\"(\\/?>)|contenteditable=\"false\"\\s*)/im,\n                '$2'\n            );\n        });\n    }\n\n    private getSelectedImage(): HTMLElement {\n        return this.resizeDiv ? <HTMLElement>this.resizeDiv.getElementsByTagName('IMG')[0] : null;\n    }\n\n    private isNorth(direction: string): boolean {\n        return direction && direction.substr(0, 1) == 'n';\n    }\n\n    private isWest(direction: string): boolean {\n        return direction && direction.substr(1, 1) == 'w';\n    }\n\n    private onDragStart = (e: DragEvent) => {\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\n            this.hideResizeHandle(true);\n        }\n    };\n}\n","export * from './plugins/Paste/index';\n","export { default as Paste } from './Paste';\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\nimport {\n    AttributeCallbackMap,\n    ClipboardData,\n    PluginEvent,\n    PluginEventType,\n} from 'roosterjs-editor-types';\nimport convertPastedContentFromWordOnline, {\n    isWordOnlineWithList,\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\n\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\nconst EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\n\n/**\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\n * 1. Content copied from Word\n * 2. Content copied from Excel\n * 3. Content copied from Word Online or Onenote Online\n */\nexport default class Paste implements EditorPlugin {\n    private editor: Editor;\n\n    /**\n     * Create an instance of Paste\n     * @param preserved @deprecated Not used. Preserved parameter only used for compatibility with old code\n     * @param attributeCallbacks @deprecated A set of callbacks to help handle html attribute during sanitization\n     */\n    constructor(preserved?: any, private attributeCallbacks?: AttributeCallbackMap) {}\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Paste';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: Editor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.BeforePaste) {\n            const { htmlAttributes, fragment, sanitizingOption } = event;\n            let wacListElements: NodeListOf<Element>;\n\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\n                // Handle HTML copied from Word\n                convertPastedContentFromWord(event);\n            } else if (\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\n                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\n            ) {\n                // Handle HTML copied from Excel\n                convertPastedContentFromExcel(event);\n            } else if ((wacListElements = fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))[0]) {\n                // Once it is known that the document is from WAC\n                // We need to remove the display property and margin from all the list item\n                wacListElements.forEach((el: HTMLElement) => {\n                    el.style.display = null;\n                    el.style.margin = null;\n                });\n                // call conversion function if the pasted content is from word online and\n                // has list element in the pasted content.\n                if (isWordOnlineWithList(fragment)) {\n                    convertPastedContentFromWordOnline(fragment);\n                }\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\n                sanitizingOption.additionalAllowedTags.push(GOOGLE_SHEET_NODE_NAME);\n            }\n\n            // TODO: Deprecate attributeCallbacks parameter\n            if (this.attributeCallbacks) {\n                Object.keys(this.attributeCallbacks).forEach(name => {\n                    chainSanitizerCallback(\n                        sanitizingOption.attributeCallbacks,\n                        name,\n                        this.attributeCallbacks[name]\n                    );\n                });\n            }\n        }\n    }\n\n    /**\n     * @deprecated\n     * Paste into editor using passed in clipboardData with original format\n     * @param clipboardData The clipboardData to paste\n     */\n    public pasteOriginal(clipboardData: ClipboardData) {\n        this.editor.paste(clipboardData);\n    }\n\n    /**\n     * @deprecated\n     * Paste plain text into editor using passed in clipboardData\n     * @param clipboardData The clipboardData to paste\n     */\n    public pasteText(clipboardData: ClipboardData) {\n        this.editor.paste(clipboardData, true /*pasteAsText*/);\n    }\n\n    /**\n     * @deprecated\n     * Paste into editor using passed in clipboardData with curent format\n     * @param clipboardData The clipboardData to paste\n     */\n    public pasteAndMergeFormat(clipboardData: ClipboardData) {\n        this.editor.paste(clipboardData, false /*pasteAsText*/, true /*applyCurrentFormat*/);\n    }\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\n\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\n\n/**\n * @internal\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\n * @param doc HTML Document which contains the content from Excel\n */\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\n    const {\n        fragment,\n        sanitizingOption,\n        htmlBefore,\n        clipboardData: { html },\n    } = event;\n    let newHtml = event.clipboardData.html;\n\n    if (html.match(LAST_TD_END_REGEX)) {\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\n        const tr = trMatch ? trMatch[0] : '<TR>';\n        newHtml = tr + html + '</TR>';\n    }\n    if (html.match(LAST_TR_END_REGEX)) {\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\n        newHtml = table + html + '</TABLE>';\n    }\n\n    if (newHtml != html) {\n        const doc = new DOMParser().parseFromString(newHtml, 'text/html');\n        while (fragment.firstChild) {\n            fragment.removeChild(fragment.firstChild);\n        }\n        while (doc?.body?.firstChild) {\n            fragment.appendChild(doc.body.firstChild);\n        }\n    }\n\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\n        if (element.style.borderStyle == 'none') {\n            element.style.border = DEFAULT_BORDER_STYLE;\n        }\n        return true;\n    });\n}\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\nimport { createWordConverter } from './wordConverter';\nimport { createWordConverterArguments } from './WordConverterArguments';\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\n\n/**\n * @internal\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\n */\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\n    const { sanitizingOption, fragment } = event;\n\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\n        element.innerHTML = '&nbsp;';\n        return true;\n    });\n\n    let wordConverter = createWordConverter();\n\n    // First find all the nodes that we need to check for list item information\n    // This call will return all the p and header elements under the root node.. These are the elements that\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\n    let elements = fragment.querySelectorAll('p');\n    if (elements.length > 0) {\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\n        if (processNodesDiscovery(wordConverter)) {\n            processNodeConvert(wordConverter);\n        }\n    }\n}\n","import CustomData, { createCustomData } from './CustomData';\nimport WordConverterArguments from './WordConverterArguments';\n\n/**\n * @internal\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\n */\nexport default interface WordConverter {\n    /** Next unique id to be assigned to a list */\n    nextUniqueId: number;\n\n    /** Number of bullets converted */\n    numBulletsConverted: number;\n\n    /** Number of numbering converted */\n    numNumberedConverted: number;\n\n    /** The structure that records the status of the conversion */\n    wordConverterArgs: WordConverterArguments;\n\n    /** Custom data storage for list items */\n    customData: CustomData;\n}\n\n/**\n * @internal\n * create an empty WordConverter\n */\nexport function createWordConverter(): WordConverter {\n    return {\n        nextUniqueId: 1,\n        numBulletsConverted: 0,\n        numNumberedConverted: 0,\n        wordConverterArgs: null,\n        customData: createCustomData(),\n    };\n}\n","import LevelLists, { createLevelLists } from './LevelLists';\nimport ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\n\n/**\n * @internal\n * Contains the state of the WordConverter when called back after yielding\n */\nexport default interface WordConverterArguments {\n    /** The list of element nodes being processed */\n    nodes: NodeListOf<HTMLElement>;\n\n    /** The index of the element currently being processed */\n    currentIndex: number;\n\n    /**\n     * Holds the metadata for all the lists we have found\n     * key: unique list id, value: list metadata\n     */\n    lists: { [key: string]: ListMetadata };\n\n    /**\n     * Stores the list item metatada of the items we\n     * have found that need to be converted\n     */\n    listItems: ListItemMetadata[];\n\n    /**\n     * This array holds the list id of the lists we are processing\n     * that are next to each other.. This list will be used to determine\n     * if list items are next to each other or if they are separated...\n     * Separated items are ignored from the conversion\n     */\n\n    currentListIdsByLevels: LevelLists[];\n\n    /** Remembers the item that was last processed  */\n    lastProcessedItem: HTMLElement;\n}\n\n/**\n * @internal\n * create an empty WordConverterArguments\n */\nexport function createWordConverterArguments(\n    nodes: NodeListOf<HTMLElement>\n): WordConverterArguments {\n    return {\n        nodes: nodes,\n        currentIndex: 0,\n        lists: {},\n        listItems: [],\n        currentListIdsByLevels: [createLevelLists()],\n        lastProcessedItem: null,\n    };\n}\n","import ListItemMetadata from './ListItemMetadata';\nimport ListMetadata from './ListMetadata';\nimport WordConverter from './wordConverter';\nimport WordConverterArguments from './WordConverterArguments';\nimport { createLevelLists } from './LevelLists';\nimport { getObject, setObject } from './CustomData';\nimport { getTagOfNode } from 'roosterjs-editor-dom';\nimport { NodeType } from 'roosterjs-editor-types';\n\n/** Word list metadata style name */\nconst LOOKUP_DEPTH = 5;\n\n/** Name for the word list id property in the custom data */\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\n\n/** Word list metadata style name */\nconst MSO_LIST_STYLE_NAME = 'mso-list';\n\n/** Regular expression to match line breaks */\nconst LINE_BREAKS = /[\\n|\\r]/gi;\n\n/**\n * @internal\n * Handles the pass 1: Discovery\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\n */\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    while (args.currentIndex < args.nodes.length) {\n        let node = args.nodes.item(args.currentIndex);\n\n        // Try to get the list metadata for the specified node\n        let itemMetadata = getListItemMetadata(node);\n        if (itemMetadata) {\n            let levelInfo =\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\n\n            // We need to drop some list information if this is not an item next to another\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\n                // This list item is not next to the previous one. This means that there is some content in between them\n                // so we need to reset our list of list ids per level\n                resetCurrentLists(args);\n            }\n\n            // Get the list metadata for the list that will hold this item\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\n            if (!listMetadata) {\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n\n                // This is a the first item of a list.. We'll create the list metadata using the information\n                // we already have from this first item\n                listMetadata = {\n                    numberOfItems: 0,\n                    uniqueListId: wordConverter.nextUniqueId++,\n                    firstFakeBullet: firstFakeBullet,\n\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\n                    // that this is not an item we need to convert of that the format doesn't match what\n                    // we are expecting\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\n\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\n                    tagName: getFakeBulletTagName(firstFakeBullet),\n                };\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\n                // items we have an decide if we create ordered or unordered lists based on this.\n                // This is the best way we can do this since we cannot read the metadata that Word\n                // puts in the head of the HTML...\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\n                listMetadata.tagName =\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\n            }\n\n            // Set the unique id to the list\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\n\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\n            // it, or we'll know it because the previous list items are not next to this one\n            if (\n                listMetadata.ignore ||\n                (listMetadata.tagName == 'OL' &&\n                    listMetadata.numberOfItems > 0 &&\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\n            ) {\n                // We need to ignore this item... and we also need to forget about the lists that\n                // are not at the root level\n                listMetadata.ignore = true;\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\n            } else {\n                // This is an item we don't need to ignore... If added lists deep under this one before\n                // we'll drop their ids from the list of ids per level.. this is because this list item\n                // breaks the deeper lists.\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\n                        0,\n                        itemMetadata.level\n                    );\n                }\n\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\n\n                // Add the list item into the list of items to be processed\n                args.listItems.push(itemMetadata);\n                listMetadata.numberOfItems++;\n            }\n\n            args.lastProcessedItem = node;\n        } else {\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\n            // the list conversion thinking that the list items are not together...\n            let last = args.lastProcessedItem;\n            if (\n                last &&\n                getRealPreviousSibling(node) == last &&\n                node.tagName == last.tagName &&\n                node.className == last.className\n            ) {\n                // Add 2 line breaks and move all the nodes to the last item\n                last.appendChild(last.ownerDocument.createElement('br'));\n                last.appendChild(last.ownerDocument.createElement('br'));\n                while (node.firstChild != null) {\n                    last.appendChild(node.firstChild);\n                }\n\n                // Remove the item that we don't need anymore\n                node.parentNode.removeChild(node);\n            }\n        }\n\n        // Move to the next element are return true if more elements need to be processed\n        args.currentIndex++;\n    }\n\n    return args.listItems.length > 0;\n}\n\n/**\n * @internal\n * Handles the pass 2: Conversion\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\n * conversion needed\n */\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\n    let args = wordConverter.wordConverterArgs;\n    args.currentIndex = 0;\n\n    while (args.currentIndex < args.listItems.length) {\n        let metadata = args.listItems[args.currentIndex];\n        let node = metadata.originalNode;\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\n        if (!listMetadata.ignore) {\n            // We have a list item that we need to convert, get or create the list\n            // that hold this item out\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\n            if (list) {\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\n                cleanupListIgnore(node, LOOKUP_DEPTH);\n\n                // Create a new list item and transfer the children\n                let li = node.ownerDocument.createElement('LI');\n                while (node.firstChild) {\n                    li.appendChild(node.firstChild);\n                }\n\n                // Append the list item into the list\n                list.appendChild(li);\n\n                // Remove the node we just converted\n                node.parentNode.removeChild(node);\n\n                if (listMetadata.tagName == 'UL') {\n                    wordConverter.numBulletsConverted++;\n                } else {\n                    wordConverter.numNumberedConverted++;\n                }\n            }\n        }\n\n        args.currentIndex++;\n    }\n\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\n}\n\n/**\n * Gets or creates the list (UL or OL) that holds this item out based on the\n * items content and the specified metadata\n */\nfunction getOrCreateListForNode(\n    wordConverter: WordConverter,\n    node: HTMLElement,\n    metadata: ListItemMetadata,\n    listMetadata: ListMetadata\n): Node {\n    // First get the last list next to this node under the specified level. This code\n    // path will return the list or will create lists if needed\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\n\n    // Here use the unique list ID to detect if we have the right list...\n    // it is possible to have 2 different lists next to each other with different formats, so\n    // we want to detect this an create separate lists for those cases\n    let listId = getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\n\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\n    // is a completely new list, so we'll append a new list for that\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\n        list.parentNode.insertBefore(newList, list.nextSibling);\n        list = newList;\n    }\n\n    // Set the list id into the custom data\n    setObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA, metadata.uniqueListId);\n\n    // This call will convert the list if needed to the right type of list required. This can happen\n    // on the cases where the first list item for this list is located after a deeper list. for that\n    // case, we will have created a UL for it, and we may need to convert it\n    return convertListIfNeeded(wordConverter, list, listMetadata);\n}\n\n/**\n * Converts the list between UL and OL if needed, by using the fake bullet and\n * information already stored in the list itself\n */\nfunction convertListIfNeeded(\n    wordConverter: WordConverter,\n    list: Node,\n    listMetadata: ListMetadata\n): Node {\n    // Check if we need to convert the list out\n    if (listMetadata.tagName != getTagOfNode(list)) {\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\n        setObject(\n            wordConverter.customData,\n            newList,\n            UNIQUE_LIST_ID_CUSTOM_DATA,\n            getObject(wordConverter.customData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\n        );\n        while (list.firstChild) {\n            newList.appendChild(list.firstChild);\n        }\n        list.parentNode.insertBefore(newList, list);\n        list.parentNode.removeChild(list);\n        list = newList;\n    }\n\n    return list;\n}\n\n/**\n * Gets or creates the specified list\n */\nfunction recurringGetOrCreateListAtNode(\n    node: HTMLElement,\n    level: number,\n    listMetadata: ListMetadata\n): Node {\n    let parent: Node = null;\n    let possibleList: Node;\n    if (level == 1) {\n        // Root case, we'll check if the list is the previous sibling of the node\n        possibleList = getRealPreviousSibling(node);\n    } else {\n        // If we get here, we are looking for level 2 or deeper... get the upper list\n        // and check if the last element is a list\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\n        possibleList = parent.lastChild;\n    }\n\n    // Check the element that we got and verify that it is a list\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\n        let tag = getTagOfNode(possibleList);\n        if (tag == 'UL' || tag == 'OL') {\n            // We have a list.. use it\n            return possibleList;\n        }\n    }\n\n    // If we get here, it means we don't have a list and we need to create one\n    // this code path will always create new lists as UL lists\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\n    if (level == 1) {\n        // For level 1, we'll insert the list beofre the node\n        node.parentNode.insertBefore(newList, node);\n    } else {\n        // Any level 2 or above, we insert the list as the last\n        // child of the upper level list\n        parent.appendChild(newList);\n    }\n\n    return newList;\n}\n\n/**\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\n * This nodes hold the fake bullet information that Word puts in and when\n * conversion is happening, we want to get rid of these elements\n */\nfunction cleanupListIgnore(node: Node, levels: number) {\n    let nodesToRemove: Node[] = [];\n\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\n        // Clean up the item internally first if we need to based on the number of levels\n        if (child.nodeType == NodeType.Element && levels > 1) {\n            cleanupListIgnore(child, levels - 1);\n        }\n\n        // Try to convert word comments into ignore elements if we haven't done so for this element\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if we can remove this item out\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\n            nodesToRemove.push(child);\n        }\n    }\n\n    nodesToRemove.forEach(child => node.removeChild(child));\n}\n\n/**\n * Reads the word list metadada out of the specified node. If the node\n * is not a Word list item, it returns null.\n */\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0) {\n            try {\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\n                // Where:\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\n                // list indentation value\n                // (2) Contains a specific list identifier.\n                // Example value: \"l0 level1 lfo1\"\n                let listprops = listatt.split(' ');\n                if (listprops.length == 3) {\n                    return <ListItemMetadata>{\n                        level: parseInt(listprops[1].substr('level'.length)),\n                        wordListId: listatt,\n                        originalNode: node,\n                        uniqueListId: 0,\n                    };\n                }\n            } catch (e) {}\n        }\n    }\n    return null;\n}\n\nfunction isFakeBullet(fakeBullet: string): boolean {\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\n}\n\n/** Given a fake bullet text, returns the type of list that should be used for it */\nfunction getFakeBulletTagName(fakeBullet: string): string {\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\n}\n\n/**\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\n * a bullet string. If not found, it returns null...\n */\nfunction getFakeBulletText(node: Node, levels: number): string {\n    // Word uses the following format for their bullets:\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\n    // &lt;span style=\"...\"&gt;\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\n    // &lt;/span&gt;\n    // Content here...\n    // &lt;/p&gt;\n    //\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\n    // text or image node will be the fake bullet we are looking for\n    let result: string = null;\n    let child: Node = node.firstChild;\n    while (!result && child) {\n        // First, check if we need to convert the Word list comments into real elements\n        child = fixWordListComments(child, true /*removeComments*/);\n\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\n        if (isIgnoreNode(child)) {\n            // Yes... this is the node that holds either the text or image data\n            result = child.textContent.trim();\n\n            // This is the case for image case\n            if (result.length == 0) {\n                result = 'o';\n            }\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\n            // If this is an element and we are not in the last level, try to get the fake bullet\n            // out of the child\n            result = getFakeBulletText(child, levels - 1);\n        }\n\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * If the specified element is a Word List comments, this code verifies and fixes\n * the markup when needed to ensure that Chrome bullet conversions work as expected\n * -----\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\n * styles of the span, but we'll use these comments to recreate them out\n */\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\n    if (child.nodeType == NodeType.Comment) {\n        let value = (child as Comment).data;\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\n            // We have a list ignore start, find the end.. We know is not more than\n            // 3 nodes away, so we'll optimize our checks\n            let nextElement = child;\n            let endComment: Node = null;\n            for (let j = 0; j < 4; j++) {\n                nextElement = getRealNextSibling(nextElement);\n                if (!nextElement) {\n                    break;\n                }\n                if (nextElement.nodeType == NodeType.Comment) {\n                    value = (nextElement as Comment).data;\n                    if (value && value.trim().toLowerCase() == '[endif]') {\n                        endComment = nextElement;\n                        break;\n                    }\n                }\n            }\n\n            // if we found the end node, wrap everything out\n            if (endComment) {\n                let newSpan = child.ownerDocument.createElement('span');\n                newSpan.setAttribute('style', 'mso-list: ignore');\n                nextElement = getRealNextSibling(child);\n                while (nextElement != endComment) {\n                    nextElement = nextElement.nextSibling as HTMLElement;\n                    newSpan.appendChild(nextElement.previousSibling);\n                }\n\n                // Insert the element out and use that one as the current child\n                endComment.parentNode.insertBefore(newSpan, endComment);\n\n                // Remove the comments out if the call specified it out\n                if (removeComments) {\n                    child.parentNode.removeChild(child);\n                    endComment.parentNode.removeChild(endComment);\n                }\n\n                // Last, make sure we return the new element out instead of the comment\n                child = newSpan;\n            }\n        }\n    }\n\n    return child;\n}\n\n/** Finds the real previous sibling, ignoring emtpy text nodes */\nfunction getRealPreviousSibling(node: Node): Node {\n    let prevSibling = node;\n    do {\n        prevSibling = prevSibling.previousSibling;\n    } while (prevSibling && isEmptyTextNode(prevSibling));\n    return prevSibling;\n}\n\n/** Finds the real next sibling, ignoring empty text nodes */\nfunction getRealNextSibling(node: Node): Node {\n    let nextSibling = node;\n    do {\n        nextSibling = nextSibling.nextSibling;\n    } while (nextSibling && isEmptyTextNode(nextSibling));\n\n    return nextSibling;\n}\n\n/**\n * Checks if the specified node is marked as a mso-list: Ignore. These\n * nodes need to be ignored when a list item is converted into standard\n * HTML lists\n */\nfunction isIgnoreNode(node: Node): boolean {\n    if (node.nodeType == NodeType.Element) {\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/** Checks if the specified node is an empty span. */\nfunction isEmptySpan(node: Node): boolean {\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\n}\n\n/** Reads the specified style value from the node */\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\n    // Word uses non-standard names for the metadata that puts in the style of the element...\n    // Most browsers will not provide the information for those unstandard values throug the node.style\n    // property, so the only reliable way to read them is to get the attribute directly and do\n    // the required parsing..\n    let textStyle = node.getAttribute('style');\n    if (textStyle && textStyle.length > 0 && textStyle.indexOf(styleName) >= 0) {\n        // Split all the CSS name: value pairs\n        let inStyles = textStyle.split(';');\n        for (let i = 0; i < inStyles.length; i++) {\n            // Split the name and value\n            let nvpair = inStyles[i].split(':');\n            if (nvpair.length == 2 && nvpair[0].trim() == styleName) {\n                return nvpair[1].trim();\n            }\n        }\n    }\n\n    // As a backup mechanism, we'll still try to get the value from the style object\n    // Dictionary styles = (Dictionary)(object)node.Style;\n    // return (string)styles[styleName];\n    return null;\n}\n\n/** Checks if the node is an empty text node that can be ignored */\nfunction isEmptyTextNode(node: Node): boolean {\n    // No node is empty\n    if (!node) {\n        return true;\n    }\n\n    // Empty text node is empty\n    if (node.nodeType == NodeType.Text) {\n        let value = node.nodeValue;\n        value = value.replace(LINE_BREAKS, '');\n        return value.trim().length == 0;\n    }\n\n    // Span or Font with an empty child node is empty\n    let tagName = getTagOfNode(node);\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\n        return isEmptyTextNode(node.firstChild);\n    }\n\n    // If not found, then this is not empty\n    return false;\n}\n\n/** Resets the list */\nfunction resetCurrentLists(args: WordConverterArguments) {\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\n        let ll = args.currentListIdsByLevels[i];\n        if (ll) {\n            ll.currentUniqueListId = -1;\n        }\n    }\n}\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\nimport {\n    WORD_ORDERED_LIST_SELECTOR,\n    WORD_UNORDERED_LIST_SELECTOR,\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\n    ORDERED_LIST_TAG_NAME,\n    UNORDERED_LIST_TAG_NAME,\n} from './constants';\n\nimport {\n    splitParentNode,\n    getNextLeafSibling,\n    getFirstLeafNode,\n    getTagOfNode,\n    collapseNodes,\n    unwrap,\n} from 'roosterjs-editor-dom';\n\n/**\n * @internal\n */\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\n}\n\n// Word Online pasted content DOM structure as of July 12th 2019\n//<html>\n//  <body>\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\n//          <div class=\"OutlineElement\">  ----------> text content\n//              <p></p>\n//          </div>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\n//                  <li></li>\n//              </ul>\n//          </div>\n//      </div>\n//      <div class='OutlineGroup'>\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//          <div class=\"ListItemWrapper\">\n//              <ol>\n//                  <li></li>\n//              </ol>\n//          </div>\n//      </div>\n//  </body>\n//</html>\n//\n\n/**\n * @internal\n * Convert text copied from word online into text that's workable with rooster editor\n * @param fragment Document fragment that is being pasted into editor.\n */\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\n    sanitizeListItemContainer(fragment);\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\n\n    listItemBlocks.forEach(itemBlock => {\n        // There are cases where consecutive List Elements are seperated into different divs:\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // <div>\n        //   <div>\n        //      <ol></ol>\n        //   </div>\n        // </div>\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\n        // after the following flattening the list will become following:\n        //\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // <div>\n        //    <ol></ol>\n        // </div>\n        // Then we are start processing.\n        flattenListBlock(fragment, itemBlock);\n\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\n\n        let convertedListElement: Element;\n        const doc = fragment.ownerDocument;\n\n        itemBlock.listItemContainers.forEach(listItemContainer => {\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\n            // Initialize processed element with propery listType if this is the first element\n            if (!convertedListElement) {\n                convertedListElement = doc.createElement(listType);\n            }\n\n            // Get all list items(<li>) in the current iterator element.\n            const currentListItems = listItemContainer.querySelectorAll('li');\n            currentListItems.forEach(item => {\n                // If item is in root level and the type of list changes then\n                // insert the current list into body and then reinitialize the convertedListElement\n                // Word Online is using data-aria-level to determine the the depth of the list item.\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\n                // In first level list, there are cases where a consecutive list item divs may have different list type\n                // When that happens we need to insert the processed elements into the document, then change the list type\n                // and keep the processing going.\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n                    convertedListElement = doc.createElement(listType);\n                }\n                insertListItem(convertedListElement, item, listType, doc);\n            });\n        });\n\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\n\n        // Once we finish the process the list items and put them into a list.\n        // After inserting the processed element,\n        // we need to remove all the non processed node from the parent node.\n        const parentContainer = itemBlock.startElement.parentNode;\n        if (parentContainer) {\n            itemBlock.listItemContainers.forEach(listItemContainer => {\n                parentContainer.removeChild(listItemContainer);\n            });\n        }\n    });\n}\n\n/**\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\n * @param fragment pasted document that contains all the list element.\n */\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\n    const listItemContainerListEl = fragment.querySelectorAll(\n        `${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`\n    );\n    listItemContainerListEl.forEach(el => {\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\n        if (el.previousSibling) {\n            const prevParent = splitParentNode(el, true) as HTMLElement;\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\n        }\n        if (el.nextSibling) {\n            const nextParent = splitParentNode(el, false) as HTMLElement;\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\n        }\n    });\n}\n\n/**\n * Take all the list items in the document, and group the consecutive list times in a list block;\n * @param fragment pasted document that contains all the list element.\n */\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\n    const result: ListItemBlock[] = [];\n    let curListItemBlock: ListItemBlock;\n    for (let i = 0; i < listElements.length; i++) {\n        let curItem = listElements[i];\n        if (!curListItemBlock) {\n            curListItemBlock = createListItemBlock(curItem);\n        } else {\n            const { listItemContainers } = curListItemBlock;\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\n            if (\n                curItem == lastItemInCurBlock.nextSibling ||\n                getFirstLeafNode(curItem) ==\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\n            ) {\n                listItemContainers.push(curItem);\n                curListItemBlock.endElement = curItem;\n            } else {\n                curListItemBlock.endElement = lastItemInCurBlock;\n                result.push(curListItemBlock);\n                curListItemBlock = createListItemBlock(curItem);\n            }\n        }\n    }\n\n    if (curListItemBlock.listItemContainers.length > 0) {\n        result.push(curListItemBlock);\n    }\n\n    return result;\n}\n\n/**\n * Flatten the list items, so that all the consecutive list items are under the same parent.\n * @param fragment Root element of that contains the element.\n * @param listItemBlock The list item block needed to be flattened.\n */\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\n    const collapsedListItemSections = collapseNodes(\n        fragment,\n        listItemBlock.startElement,\n        listItemBlock.endElement,\n        true\n    );\n    collapsedListItemSections.forEach(section => {\n        if (getTagOfNode(section.firstChild) == 'DIV') {\n            unwrap(section);\n        }\n    });\n}\n\n/**\n * Get the list type that the container contains. If there is no list in the container\n * return null;\n * @param listItemContainer Container that contains a list\n */\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\n    const tag = getTagOfNode(listItemContainer.firstChild);\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\n}\n\n/**\n * Insert list item into the correct position of a list\n * @param listRootElement Root element of the list that is accepting a coming element.\n * @param itemToInsert List item that needed to be inserted.\n * @param listType Type of list(ul/ol)\n */\nfunction insertListItem(\n    listRootElement: Element,\n    itemToInsert: HTMLElement,\n    listType: string,\n    doc: HTMLDocument\n): void {\n    if (!listType) {\n        return;\n    }\n    // Get item level from 'data-aria-level' attribute\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\n    while (itemLevel > 1) {\n        if (!curListLevel.firstChild) {\n            // If the current level is empty, create empty list within the current level\n            // then move the level iterator into the next level.\n            curListLevel.append(doc.createElement(listType));\n            curListLevel = curListLevel.firstElementChild;\n        } else {\n            // If the current level is not empty, the last item in the needs to be a UL or OL\n            // and the level iterator should move to the UL/OL at the last position.\n            let lastChild = curListLevel.lastElementChild;\n            let lastChildTag = getTagOfNode(lastChild);\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\n                curListLevel = lastChild;\n            } else {\n                // If the last child is not a list, then append a new list to the level\n                // and move the level iterator to the new level.\n                curListLevel.append(doc.createElement(listType));\n                curListLevel = curListLevel.lastElementChild;\n            }\n        }\n        itemLevel--;\n    }\n\n    // Once the level iterator is at the right place, then append the list item in the level.\n    curListLevel.appendChild(itemToInsert);\n}\n\n/**\n * Insert the converted list item into the correct place.\n * @param convertedListElement List element that is converted from list item block\n * @param fragment Root element of that contains the converted listItemBlock\n * @param listItemBlock List item block that was converted.\n */\nfunction insertConvertedListToDoc(\n    convertedListElement: Element,\n    fragment: DocumentFragment,\n    listItemBlock: ListItemBlock\n) {\n    if (!convertedListElement) {\n        return;\n    }\n\n    const { insertPositionNode } = listItemBlock;\n    if (insertPositionNode) {\n        const { parentElement } = insertPositionNode;\n        if (parentElement) {\n            parentElement.insertBefore(convertedListElement, insertPositionNode);\n        }\n    } else {\n        const { parentElement } = listItemBlock.startElement;\n        if (parentElement) {\n            parentElement.appendChild(convertedListElement);\n        } else {\n            fragment.appendChild(convertedListElement);\n        }\n    }\n}\n","/**\n * @internal\n * Type that holds all the info of a consecutive list item block.\n */\nexport default interface ListItemBlock {\n    /**\n     * The first element in block of list item from pasted word online document.\n     */\n    startElement: Element;\n\n    /**\n     * The last element in block of list item from pasted word online document.\n     */\n    endElement: Element;\n\n    /**\n     * The position where the processed bulleted list should be inserted.\n     */\n    insertPositionNode: Node;\n\n    /**\n     * The list of containers that wraps each list item.\n     */\n    listItemContainers: Element[];\n}\n\n/**\n * @internal\n * Initialize an empty ListItemBlock\n */\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\n    return {\n        startElement: listItem,\n        endElement: listItem,\n        insertPositionNode: null,\n        listItemContainers: listItem ? [listItem] : [],\n    };\n}\n","export * from './plugins/Picker/index';\n","export { default as PickerPlugin, EditorPickerPluginInterface } from './PickerPlugin';\nexport { PickerPluginOptions, PickerDataProvider } from './PickerDataProvider';\n","import { Browser, createRange, PartialInlineElement } from 'roosterjs-editor-dom';\nimport { PickerDataProvider, PickerPluginOptions } from './PickerDataProvider';\nimport { replaceWithNode } from 'roosterjs-editor-api';\nimport {\n    ChangeSource,\n    NodePosition,\n    PluginDomEvent,\n    PluginEvent,\n    PluginEventType,\n    PluginInputEvent,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\nimport {\n    cacheGetContentSearcher,\n    Editor,\n    EditorPlugin,\n    isCharacterValue,\n    isModifierKey,\n} from 'roosterjs-editor-core';\n\n// Character codes.\n// IE11 uses different character codes. which are noted below.\n// If adding a new key, test in IE to figure out what the code is.\nconst BACKSPACE_CHARCODE = 'Backspace';\nconst TAB_CHARCODE = 'Tab';\nconst ENTER_CHARCODE = 'Enter';\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\n\n// Input event input types.\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\n\n// Unidentified key, the code for Android keyboard events.\nconst UNIDENTIFIED_KEY = 'Unidentified';\n// the char code for Android keyboard events on Webview below 51.\nconst UNIDENTIFIED_CODE = [0, 229];\n\n/**\n * Interface for PickerPlugin\n */\nexport interface EditorPickerPluginInterface<T extends PickerDataProvider = PickerDataProvider>\n    extends EditorPlugin {\n    dataProvider: T;\n}\n\n/**\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\n * - Show picker when special trigger key is pressed\n * - Hide picker\n * - Change selection in picker by Up/Down/Left/Right\n * - Apply selected item in picker\n *\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\n * To show a picker UI, you need to build your own UI component. Please reference to\n * https://github.com/microsoft/roosterjs/tree/master/publish/samplesite/scripts/controls/samplepicker\n */\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\n    implements EditorPickerPluginInterface<T> {\n    private editor: Editor;\n    private eventHandledOnKeyDown: boolean;\n    private blockSuggestions: boolean;\n    private isSuggesting: boolean;\n    private lastKnownRange: Range;\n\n    // For detecting backspace in Android\n    private isPendingInputEventHandling: boolean = false;\n    private currentInputLength: number;\n    private newInputLength: number;\n\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) { }\n\n    /**\n     * Get a friendly name\n     */\n    getName() {\n        return 'Picker';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    public initialize(editor: Editor) {\n        this.editor = editor;\n        this.dataProvider.onInitalize(\n            (htmlNode: Node) => {\n                this.editor.focus();\n\n                let wordToReplace = this.getWord(null);\n\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\n                // We fall back to using the lastKnownRange to try to get around this.\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\n                    this.editor.select(this.lastKnownRange);\n                    wordToReplace = this.getWord(null);\n                }\n\n                let insertNode = () => {\n                    if (wordToReplace) {\n                        replaceWithNode(\n                            this.editor,\n                            wordToReplace,\n                            htmlNode,\n                            true /* exactMatch */\n                        );\n                    } else {\n                        this.editor.insertNode(htmlNode);\n                    }\n                    this.setIsSuggesting(false);\n                };\n\n                if (this.pickerOptions.handleAutoComplete) {\n                    this.editor.performAutoComplete(insertNode, this.pickerOptions.changeSource);\n                } else {\n                    this.editor.addUndoSnapshot(insertNode, this.pickerOptions.changeSource);\n                }\n            },\n            (isSuggesting: boolean) => {\n                this.setIsSuggesting(isSuggesting);\n            },\n            editor\n        );\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    public dispose() {\n        this.editor = null;\n        this.dataProvider.onDispose();\n    }\n\n    /**\n     * Check if the plugin should handle the given event exclusively.\n     * Handle an event exclusively means other plugin will not receive this event in\n     * onPluginEvent method.\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\n     * the final result depends on the order of the plugins are added into editor\n     * @param event The event to check\n     */\n    public willHandleEventExclusively(event: PluginEvent) {\n        return (\n            this.isSuggesting &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.KeyUp ||\n                event.eventType == PluginEventType.Input)\n        );\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    public onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.ContentChanged:\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\n                    // Stop suggesting since content is fully changed\n                    if (this.isSuggesting) {\n                        this.setIsSuggesting(false);\n                    }\n\n                    // Undos and other major changes to document content fire this type of event.\n                    // Inform the data provider of the current picker placed elements in the body.\n                    let elementIds: string[] = [];\n                    this.editor.queryElements(\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\n                        element => {\n                            if (element.id) {\n                                elementIds.push(element.id);\n                            }\n                        }\n                    );\n                    this.dataProvider.onContentChanged(elementIds);\n                }\n                break;\n\n            case PluginEventType.KeyDown:\n                this.eventHandledOnKeyDown = false;\n                if (this.isAndroidKeyboardEvent(event)) {\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\n                    // so handling should be done using the input rather than key down event\n                    // Since the key down event happens right before the input event, calculate the input\n                    // length here in preparation for onAndroidInputEvent\n                    this.currentInputLength = this.calcInputLength(event);\n                    this.isPendingInputEventHandling = true;\n                } else {\n                    this.onKeyDownEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.Input:\n                if (this.isPendingInputEventHandling) {\n                    this.onAndroidInputEvent(event);\n                }\n                break;\n\n            case PluginEventType.KeyUp:\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\n                    this.onKeyUpDomEvent(event);\n                    this.isPendingInputEventHandling = false;\n                }\n                break;\n\n            case PluginEventType.MouseUp:\n                if (this.isSuggesting) {\n                    this.setIsSuggesting(false);\n                }\n                break;\n\n            case PluginEventType.Scroll:\n                if (this.dataProvider.onScroll) {\n                    // Dispatch scroll event to data provider\n                    this.dataProvider.onScroll(event.scrollContainer);\n                }\n                break;\n        }\n    }\n\n    private setLastKnownRange(range: Range) {\n        this.lastKnownRange = range;\n    }\n\n    private setIsSuggesting(isSuggesting: boolean) {\n        this.isSuggesting = isSuggesting;\n\n        if (!isSuggesting) {\n            this.setLastKnownRange(null);\n        }\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\n\n        this.setAriaOwns(isSuggesting);\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\n    }\n\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\n        this.eventHandledOnKeyDown = true;\n        event.rawEvent.preventDefault();\n        event.rawEvent.stopImmediatePropagation();\n    }\n\n    private getIdValue(node: Node): string {\n        let element = node as Element;\n        return element.attributes && element.attributes.getNamedItem('id')\n            ? (element.attributes.getNamedItem('id').value as string)\n            : null;\n    }\n\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\n        let searcher = cacheGetContentSearcher(event, this.editor);\n        return searcher ? searcher.getWordBefore() : null;\n    }\n\n    private replaceNode(currentNode: Node, replacementNode: Node) {\n        if (currentNode) {\n            this.editor.deleteNode(currentNode);\n        }\n        if (replacementNode) {\n            this.editor.insertNode(replacementNode);\n        }\n    }\n\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\n        let PositionContentSearcher = cacheGetContentSearcher(event, this.editor);\n        let startPos: NodePosition;\n        let endPos: NodePosition;\n        PositionContentSearcher.forEachTextInlineElement(textInline => {\n            let hasMatched = false;\n            let nodeContent = textInline.getTextContent();\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\n            while (nodeIndex >= 0) {\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\n                    startPos = textInline.getStartPosition().move(nodeIndex);\n                    hasMatched = true;\n                    break;\n                }\n                nodeIndex--;\n            }\n\n            if (hasMatched) {\n                endPos = textInline.getEndPosition();\n            }\n\n            return hasMatched;\n        });\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\n    }\n\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\n        return (\n            this.isAndroidKeyboardEvent(event) ||\n            isCharacterValue(event.rawEvent) ||\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\n        );\n    }\n\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\n        if (this.isSuggesting) {\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\n            const wordBeforeCursor = this.getWord(event);\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n\n            // If we hit a case where wordBeforeCursor is just the trigger character,\n            // that means we've gotten a onKeyUp event right after it's been typed.\n            // Otherwise, update the query string when:\n            // 1. There's an actual value\n            // 2. That actual value isn't just pure whitespace\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\n            // Otherwise, we want to dismiss the picker plugin's UX.\n            if (\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\n                (trimmedWordBeforeCursor &&\n                    trimmedWordBeforeCursor.length > 0 &&\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\n            ) {\n                this.dataProvider.queryStringUpdated(\n                    trimmedWordBeforeCursor,\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                );\n                this.setLastKnownRange(this.editor.getSelectionRange());\n            } else {\n                this.setIsSuggesting(false);\n            }\n        } else {\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\n            if (!this.blockSuggestions) {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor.split(' ').length <= 4 &&\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\n                ) {\n                    this.setIsSuggesting(true);\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\n                    this.dataProvider.queryStringUpdated(\n                        trimmedWordBeforeCursor,\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\n                    );\n                    this.setLastKnownRange(this.editor.getSelectionRange());\n                    if (this.dataProvider.setCursorPoint) {\n                        // Determine the bounding rectangle for the @mention\n                        let searcher = cacheGetContentSearcher(event, this.editor);\n                        let rangeNode = this.editor.getDocument().createRange();\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\n                        let rangeStartSuccessfullySet = this.setRangeStart(\n                            rangeNode,\n                            nodeBeforeCursor,\n                            wordBeforeCursor\n                        );\n                        if (!rangeStartSuccessfullySet) {\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\n                            // is not including the trigger character. In this case, the node before\n                            // the node before cursor is the trigger character, and this is where the range should start.\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\n                            this.setRangeStart(\n                                rangeNode,\n                                nodeBeforeNodeBeforeCursor,\n                                this.pickerOptions.triggerCharacter\n                            );\n                        }\n                        let rect = rangeNode.getBoundingClientRect();\n\n                        // Safari's support for range.getBoundingClientRect is incomplete.\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\n                            rect = rangeNode.getClientRects()[0];\n                        }\n\n                        if (rect) {\n                            rangeNode.detach();\n\n                            // Display the @mention popup in the correct place\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\n                            let bufferZone = (rect.bottom - rect.top) / 2;\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\n                        }\n                    }\n                }\n            } else {\n                if (\n                    wordBeforeCursor != null &&\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\n                ) {\n                    this.blockSuggestions = false;\n                }\n            }\n        }\n    }\n\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\n        let keyboardEvent = event.rawEvent;\n        if (this.isSuggesting) {\n            if (keyboardEvent.key == ESC_CHARCODE) {\n                this.setIsSuggesting(false);\n                this.blockSuggestions = true;\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.shiftHighlight &&\n                (this.pickerOptions.isHorizontal\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\n                    keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\n                    keyboardEvent.key == DOWN_ARROW_CHARCODE)\n            ) {\n                this.dataProvider.shiftHighlight(\n                    this.pickerOptions.isHorizontal\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\n                );\n\n                if (this.dataProvider.getSelectedIndex) {\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\n                }\n\n                this.cancelDefaultKeyDownEvent(event);\n            } else if (\n                this.dataProvider.selectOption &&\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\n            ) {\n                this.dataProvider.selectOption();\n                this.cancelDefaultKeyDownEvent(event);\n            } else {\n                // Currently no op.\n            }\n        } else {\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\n                const nodeRemoved = this.tryRemoveNode(event);\n                if (nodeRemoved) {\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\n                let searcher = cacheGetContentSearcher(event, this.editor);\n                let nodeAfterCursor = searcher.getInlineElementAfter()\n                    ? searcher.getInlineElementAfter().getContainerNode()\n                    : null;\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\n                    this.replaceNode(nodeAfterCursor, replacementNode);\n                    this.cancelDefaultKeyDownEvent(event);\n                }\n            }\n        }\n    }\n\n    private onAndroidInputEvent(event: PluginInputEvent) {\n        this.newInputLength = this.calcInputLength(event);\n\n        if (\n            this.newInputLength < this.currentInputLength ||\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\n        ) {\n            const nodeRemoved = this.tryRemoveNode(event);\n            if (nodeRemoved) {\n                this.eventHandledOnKeyDown = true;\n            }\n        }\n    }\n\n    private calcInputLength(event: PluginEvent) {\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\n        return wordBeforCursor ? wordBeforCursor.length : 0;\n    }\n\n    private tryRemoveNode(event: PluginDomEvent): boolean {\n        const searcher = cacheGetContentSearcher(event, this.editor);\n        const inlineElementBefore = searcher.getInlineElementBefore();\n        const nodeBeforeCursor = inlineElementBefore\n            ? inlineElementBefore.getContainerNode()\n            : null;\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\n        const inlineElementAfter = searcher.getInlineElementAfter();\n\n        if (\n            nodeId &&\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\n        ) {\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\n            if (replacementNode) {\n                this.replaceNode(nodeBeforeCursor, replacementNode);\n                if (this.isPendingInputEventHandling) {\n                    this.editor.runAsync(() => {\n                        this.editor.select(replacementNode, PositionType.After);\n                    });\n                } else {\n                    this.editor.select(replacementNode, PositionType.After);\n                }\n            } else {\n                this.editor.deleteNode(nodeBeforeCursor);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getWord(event: PluginKeyboardEvent) {\n        let wordFromRange = this.getRangeUntilAt(event).toString();\n        let wordFromCache = this.getWordBeforeCursor(event);\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\n        // so wordFromCache is what we want to return.\n        if (\n            wordFromRange == this.pickerOptions.triggerCharacter &&\n            wordFromRange != wordFromCache\n        ) {\n            return wordFromCache;\n        }\n        return wordFromRange;\n    }\n\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\n        if (nodeOffset > -1) {\n            rangeNode.setStart(node, nodeOffset);\n            return true;\n        }\n        return false;\n    }\n\n    private setAriaOwns(isSuggesting: boolean) {\n        this.editor.setEditorDomAttribute(\n            'aria-owns',\n            isSuggesting && this.pickerOptions.suggestionsLabel\n                ? this.pickerOptions.suggestionsLabel\n                : null\n        );\n    }\n\n    private setAriaActiveDescendant(selectedIndex: number) {\n        this.editor.setEditorDomAttribute(\n            'aria-activedescendant',\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\n                : null\n        );\n    }\n\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\n        const searcher = cacheGetContentSearcher(event, this.editor);\n        const element = searcher ? searcher.getInlineElementBefore() : null;\n        return element ? element.getTextContent() : null;\n    }\n\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\n        // Check keyboard events on Android for further handling.\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\n        // so using the charCode property, which is 0 or 229.\n        return (\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\n            (event.rawEvent.key == undefined &&\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\n        );\n    }\n}\n","export * from './plugins/TableResize/index';\n","export { default as TableResize } from './TableResize';\n","import { contains, fromHtml, isNode, isRtl, VTable } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\nimport {\n    ContentPosition,\n    PluginEvent,\n    PluginEventType,\n    PluginMouseEvent,\n    ChangeSource,\n} from 'roosterjs-editor-types';\n\nconst TABLE_RESIZE_HANDLE_KEY = 'TABLE_RESIZE_HANDLE';\nconst HANDLE_WIDTH = 6;\nconst CONTAINER_HTML = `<div style=\"position: fixed; cursor: col-resize; width: ${HANDLE_WIDTH}px; border: solid 0 #C6C6C6;\"></div>`;\n\n/**\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\n */\nexport default class TableResize implements EditorPlugin {\n    private editor: Editor;\n    private onMouseOverDisposer: () => void;\n    private td: HTMLTableCellElement;\n    private pageX = -1;\n    private initialPageX: number;\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.onMouseOverDisposer = this.editor.addDomEventHandler('mouseover', this.onMouseOver);\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'TableResize';\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.detachMouseEvents();\n        this.editor = null;\n        this.onMouseOverDisposer();\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (\n            this.td &&\n            (event.eventType == PluginEventType.KeyDown ||\n                event.eventType == PluginEventType.ContentChanged ||\n                (event.eventType == PluginEventType.MouseDown && !this.clickIntoCurrentTd(event)))\n        ) {\n            this.td = null;\n            this.calcAndShowHandle();\n        }\n    }\n\n    private clickIntoCurrentTd(event: PluginMouseEvent) {\n        let mouseEvent = event.rawEvent;\n        let target = mouseEvent.target;\n        return isNode(target) && contains(this.td, <Node>target, true /*treatSameNodeAsContain*/);\n    }\n\n    private onMouseOver = (e: MouseEvent) => {\n        let node = <HTMLElement>(e.srcElement || e.target);\n        if (\n            this.pageX < 0 &&\n            node &&\n            (node.tagName == 'TD' || node.tagName == 'TH') &&\n            node != this.td\n        ) {\n            this.td = <HTMLTableCellElement>node;\n            this.calcAndShowHandle();\n        }\n    };\n\n    private calcAndShowHandle() {\n        if (this.td) {\n            let tr = <HTMLTableRowElement>this.editor.getElementAtCursor('TR', this.td);\n            let table = <HTMLTableElement>this.editor.getElementAtCursor('TABLE', tr);\n            if (tr && table) {\n                let [left, top] = this.getPosition(table);\n                let handle = this.getResizeHandle();\n\n                left +=\n                    this.td.offsetLeft + (isRtl(table) ? 0 : this.td.offsetWidth - HANDLE_WIDTH);\n                handle.style.display = '';\n                handle.style.top = top + 'px';\n                handle.style.height = table.offsetHeight + 'px';\n                handle.style.left = left + 'px';\n            }\n        } else {\n            this.getResizeHandle().style.display = 'none';\n        }\n    }\n\n    private adjustHandle(pageX: number) {\n        let handle = this.getResizeHandle();\n        handle.style.left = handle.offsetLeft + pageX - this.pageX + 'px';\n        this.pageX = pageX;\n    }\n\n    private getPosition(e: HTMLElement): [number, number] {\n        let parent = <HTMLElement>e.offsetParent;\n        let [left, top] = parent ? this.getPosition(parent) : [0, 0];\n        return [left + e.offsetLeft - e.scrollLeft, top + e.offsetTop - e.scrollTop];\n    }\n\n    private getResizeHandle() {\n        return this.editor.getCustomData(\n            TABLE_RESIZE_HANDLE_KEY,\n            () => {\n                let document = this.editor.getDocument();\n                let handle = fromHtml(CONTAINER_HTML, document)[0] as HTMLElement;\n                this.editor.insertNode(handle, {\n                    position: ContentPosition.Outside,\n                    updateCursor: false,\n                    replaceSelection: false,\n                    insertOnNewLine: false,\n                });\n                handle.addEventListener('mousedown', this.onMouseDown);\n                return handle;\n            },\n            handle => {\n                handle.removeEventListener('mousedown', this.onMouseDown);\n                handle.parentNode.removeChild(handle);\n            }\n        );\n    }\n\n    private cancelEvent(e: MouseEvent) {\n        e.stopPropagation();\n        e.preventDefault();\n    }\n\n    private onMouseDown = (e: MouseEvent) => {\n        if (!this.editor || this.editor.isDisposed()) {\n            return;\n        }\n\n        this.pageX = e.pageX;\n        this.initialPageX = e.pageX;\n        this.attachMouseEvents();\n\n        let handle = this.getResizeHandle();\n        handle.style.borderWidth = '0 1px';\n\n        this.cancelEvent(e);\n    };\n\n    private onMouseMove = (e: MouseEvent) => {\n        this.adjustHandle(e.pageX);\n        this.cancelEvent(e);\n    };\n\n    private onMouseUp = (e: MouseEvent) => {\n        this.detachMouseEvents();\n\n        let handle = this.getResizeHandle();\n        handle.style.borderWidth = '0';\n\n        let table = this.editor.getElementAtCursor('TABLE', this.td) as HTMLTableElement;\n        let cellPadding = parseInt(table.cellPadding);\n        cellPadding = isNaN(cellPadding) ? 0 : cellPadding;\n\n        if (e.pageX != this.initialPageX) {\n            let newWidth =\n                this.td.clientWidth -\n                cellPadding * 2 +\n                (e.pageX - this.initialPageX) * (isRtl(table) ? -1 : 1);\n            this.editor.addUndoSnapshot((start, end) => {\n                this.setTableColumnWidth(newWidth + 'px');\n                this.editor.select(start, end);\n            }, ChangeSource.Format);\n        }\n\n        this.pageX = -1;\n        this.calcAndShowHandle();\n        this.editor.focus();\n        this.cancelEvent(e);\n    };\n\n    private attachMouseEvents() {\n        if (this.editor && !this.editor.isDisposed()) {\n            let document = this.editor.getDocument();\n            document.addEventListener('mousemove', this.onMouseMove, true);\n            document.addEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private detachMouseEvents() {\n        if (this.editor && !this.editor.isDisposed()) {\n            let document = this.editor.getDocument();\n            document.removeEventListener('mousemove', this.onMouseMove, true);\n            document.removeEventListener('mouseup', this.onMouseUp, true);\n        }\n    }\n\n    private setTableColumnWidth(width: string) {\n        let vtable = new VTable(this.td);\n        vtable.table.style.width = '';\n        vtable.table.width = '';\n        vtable.forEachCellOfCurrentColumn(cell => {\n            if (cell.td) {\n                cell.td.style.width = cell.td == this.td ? width : '';\n            }\n        });\n        vtable.writeBack();\n        return this.editor.contains(this.td) ? this.td : vtable.getCurrentTd();\n    }\n}\n","export * from './plugins/Watermark/index';\n","export { default as Watermark } from './Watermark';\n","import { applyFormat, getTagOfNode, wrap } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin } from 'roosterjs-editor-core';\nimport {\n    ChangeSource,\n    PluginEvent,\n    PluginEventType,\n    ContentPosition,\n    ExtractContentEvent,\n    DefaultFormat,\n} from 'roosterjs-editor-types';\n\nconst WATERMARK_SPAN_ID = '_rooster_watermarkSpan';\nconst WATERMARK_REGEX = new RegExp(\n    `<span[^>]*id=['\"]?${WATERMARK_SPAN_ID}['\"]?[^>]*>[^<]*</span>`,\n    'ig'\n);\nconst SPELLCHECK_ATTR_NAME = 'spellcheck';\n\n/**\n * A watermark plugin to manage watermark string for roosterjs\n */\nexport default class Watermark implements EditorPlugin {\n    private editor: Editor;\n    private isWatermarkShowing: boolean;\n    private disposer: () => void;\n    private spellcheckInitialValue: string;\n\n    /**\n     * Create an instance of Watermark plugin\n     * @param watermark The watermark string\n     */\n    constructor(private watermark: string, private format?: DefaultFormat) {\n        this.format = this.format || {\n            fontSize: '14px',\n            textColor: '#aaa',\n        };\n    }\n\n    /**\n     * Get a friendly name of  this plugin\n     */\n    getName() {\n        return 'Watermark';\n    }\n\n    /**\n     * Initialize this plugin. This should only be called from Editor\n     * @param editor Editor instance\n     */\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            focus: this.handleWatermark,\n            blur: this.handleWatermark,\n        });\n        this.spellcheckInitialValue = this.editor.getEditorDomAttribute(SPELLCHECK_ATTR_NAME);\n    }\n\n    /**\n     * Dispose this plugin\n     */\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.hideWatermark();\n        this.editor = null;\n    }\n\n    /**\n     * Handle events triggered from editor\n     * @param event PluginEvent object\n     */\n    onPluginEvent(event: PluginEvent) {\n        if (event.eventType == PluginEventType.EditorReady) {\n            this.showHideWatermark(false /*ignoreCachedState*/);\n        } else if (event.eventType == PluginEventType.ContentChanged) {\n            // When content is changed from setContent() API, current cached state\n            // may not be accurate, so we ignore it\n            this.showHideWatermark(event.source == ChangeSource.SetContent);\n        } else if (event.eventType == PluginEventType.ExtractContent && this.isWatermarkShowing) {\n            this.removeWartermarkFromHtml(event as ExtractContentEvent);\n        }\n    }\n\n    private handleWatermark = () => {\n        this.showHideWatermark(false /*ignoreCachedState*/);\n    };\n\n    private showHideWatermark(ignoreCachedState: boolean) {\n        if (this.editor.hasFocus() && (ignoreCachedState || this.isWatermarkShowing)) {\n            this.hideWatermark();\n            this.editor.focus();\n        } else if (\n            !this.editor.hasFocus() &&\n            (ignoreCachedState || !this.isWatermarkShowing) &&\n            this.editor.isEmpty(true /*trim*/)\n        ) {\n            this.showWatermark();\n        }\n    }\n\n    private showWatermark() {\n        let document = this.editor.getDocument();\n        let watermarkNode = wrap(\n            document.createTextNode(this.watermark),\n            `<span id=\"${WATERMARK_SPAN_ID}\"></span>`\n        ) as HTMLElement;\n        applyFormat(watermarkNode, this.format, this.editor.isDarkMode());\n        this.editor.insertNode(watermarkNode, {\n            position: ContentPosition.Begin,\n            updateCursor: false,\n            replaceSelection: false,\n            insertOnNewLine: false,\n        });\n        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, 'false');\n        this.isWatermarkShowing = true;\n    }\n\n    private hideWatermark() {\n        this.editor.queryElements(`span[id=\"${WATERMARK_SPAN_ID}\"]`, span => {\n            let parentNode = span.parentNode;\n            this.editor.deleteNode(span);\n\n            // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\n            if (\n                this.editor.contains(parentNode) &&\n                getTagOfNode(parentNode) == 'DIV' &&\n                !parentNode.firstChild\n            ) {\n                parentNode.appendChild(this.editor.getDocument().createElement('BR'));\n            }\n        });\n\n        this.editor.setEditorDomAttribute(SPELLCHECK_ATTR_NAME, this.spellcheckInitialValue);\n        this.isWatermarkShowing = false;\n    }\n\n    private removeWartermarkFromHtml(event: ExtractContentEvent) {\n        let content = event.content;\n        content = content.replace(WATERMARK_REGEX, '');\n        event.content = content;\n    }\n}\n","export * from './plugins/Entity/index';\n","export { default as EntityPlugin } from './EntityPlugin';\nexport { default as insertEntity } from './insertEntity';\nexport { default as getEntityFromElement } from './getEntityFromElement';\nexport { default as getEntities } from './getEntities';\nexport { default as getEntityElement } from './getEntityElement';\nexport { default as createEntityWrapper } from './createEntityWrapper';\n","import getEntityElement from './getEntityElement';\nimport getEntityFromElement from './getEntityFromElement';\nimport tryTriggerEntityEvent from './tryTriggerEntityEvent';\nimport { Browser, toArray } from 'roosterjs-editor-dom';\nimport { Editor, EditorPlugin, isCharacterValue, Keys } from 'roosterjs-editor-core';\nimport {\n    getAllEntityIds,\n    getEntitySelector,\n    serializeEntityInfo,\n    ALLOWED_CSS_CLASSES,\n} from './EntityInfo';\nimport {\n    ContentPosition,\n    EntityOperation,\n    PluginEvent,\n    PluginEventType,\n    QueryScope,\n    ChangeSource,\n    HtmlSanitizerOptions,\n} from 'roosterjs-editor-types';\nimport {\n    ClickOnEntityFeature,\n    EscapeFromEntityFeature,\n    EnterBeforeReadonlyEntityFeature,\n    BackspaceAfterEntityFeature,\n    DeleteBeforeEntityFeature,\n} from './EntityFeatures';\n\n/**\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\n */\nexport default class EntityPlugin implements EditorPlugin {\n    private editor: Editor;\n    private disposer: () => void;\n    private clickingPoint: { pageX: number; pageY: number };\n    private knownEntityElements: Node[];\n\n    getName() {\n        return 'Entity';\n    }\n\n    initialize(editor: Editor) {\n        this.editor = editor;\n        this.disposer = this.editor.addDomEventHandler({\n            contextmenu: this.handleContextMenuEvent,\n            cut: this.handleCutEvent,\n        });\n\n        this.knownEntityElements = [];\n\n        [\n            ClickOnEntityFeature,\n            EscapeFromEntityFeature,\n            EnterBeforeReadonlyEntityFeature,\n            BackspaceAfterEntityFeature,\n            DeleteBeforeEntityFeature,\n        ].forEach(feature => this.editor.addContentEditFeature(feature));\n    }\n\n    dispose() {\n        this.disposer();\n        this.disposer = null;\n        this.editor = null;\n        this.knownEntityElements = null;\n    }\n\n    onPluginEvent(event: PluginEvent) {\n        switch (event.eventType) {\n            case PluginEventType.MouseDown:\n                this.handleMouseDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.MouseUp:\n                this.handleMouseUpEvent(event.rawEvent);\n                break;\n            case PluginEventType.KeyDown:\n                this.handleKeyDownEvent(event.rawEvent);\n                break;\n            case PluginEventType.BeforePaste:\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\n                break;\n            case PluginEventType.ContentChanged:\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\n                break;\n            case PluginEventType.EditorReady:\n                this.handleContentChangedEvent(true /*resetAll*/);\n                break;\n            case PluginEventType.ExtractContentWithDom:\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\n                break;\n        }\n    }\n\n    private handleContextMenuEvent = (event: UIEvent) => {\n        const target = event.target as Node;\n        const entityElement = getEntityElement(this.editor, target);\n\n        if (entityElement) {\n            event.preventDefault();\n            tryTriggerEntityEvent(this.editor, entityElement, EntityOperation.ContextMenu, event);\n        }\n    };\n\n    private handleCutEvent = (event: UIEvent) => {\n        const range = this.editor.getSelectionRange();\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(event);\n        }\n    };\n\n    private handleMouseDownEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        const entityElement = getEntityElement(this.editor, target as Node);\n        if (entityElement && !entityElement.isContentEditable) {\n            event.preventDefault();\n            this.clickingPoint = { pageX, pageY };\n        }\n    }\n\n    private handleMouseUpEvent(event: MouseEvent) {\n        const { target, pageX, pageY } = event;\n        let entityElement: HTMLElement;\n\n        if (\n            this.clickingPoint &&\n            this.clickingPoint.pageX == pageX &&\n            this.clickingPoint.pageY == pageY &&\n            !!(entityElement = getEntityElement(this.editor, target as Node))\n        ) {\n            event.preventDefault();\n            tryTriggerEntityEvent(this.editor, entityElement, EntityOperation.Click, event);\n\n            workaroundSelectionIssueForIE(this.editor);\n        }\n\n        this.clickingPoint = null;\n    }\n\n    private handleKeyDownEvent(event: KeyboardEvent) {\n        if (\n            isCharacterValue(event) ||\n            event.which == Keys.BACKSPACE ||\n            event.which == Keys.DELETE\n        ) {\n            const range = this.editor.getSelectionRange();\n            if (!range.collapsed) {\n                this.checkRemoveEntityForRange(event);\n            }\n        }\n    }\n\n    private handleBeforePasteEvent(\n        fragment: DocumentFragment,\n        sanitizingOption: HtmlSanitizerOptions\n    ) {\n        const range = this.editor.getSelectionRange();\n\n        if (!range.collapsed) {\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\n        }\n\n        const entityElements = toArray<HTMLElement>(fragment.querySelectorAll(getEntitySelector()));\n        if (entityElements.length > 0) {\n            const knownIds = getAllEntityIds(this.editor);\n            entityElements.forEach(element => {\n                const entity = getEntityFromElement(element);\n                if (entity) {\n                    element.className = serializeEntityInfo(\n                        this.editor,\n                        entity.type,\n                        entity.isReadonly,\n                        entity.id,\n                        knownIds\n                    );\n                }\n            });\n\n            Array.prototype.push.apply(\n                sanitizingOption.additionalAllowedCssClasses,\n                ALLOWED_CSS_CLASSES\n            );\n        }\n    }\n\n    private handleContentChangedEvent(resetAll: boolean) {\n        this.knownEntityElements = resetAll\n            ? []\n            : this.knownEntityElements.filter(node => this.editor.contains(node));\n\n        this.editor.queryElements(getEntitySelector(), element => {\n            if (this.knownEntityElements.indexOf(element) < 0) {\n                this.knownEntityElements.push(element);\n\n                tryTriggerEntityEvent(this.editor, element, EntityOperation.NewEntity);\n            }\n        });\n    }\n\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\n            element.removeAttribute('contentEditable');\n\n            tryTriggerEntityEvent(\n                this.editor,\n                element as HTMLElement,\n                EntityOperation.ReplaceTemporaryContent\n            );\n        });\n    }\n\n    private checkRemoveEntityForRange(event: UIEvent) {\n        const editableEntityElements: HTMLElement[] = [];\n        const selector = getEntitySelector();\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\n            if (element.isContentEditable) {\n                editableEntityElements.push(element);\n            } else {\n                tryTriggerEntityEvent(this.editor, element, EntityOperation.Overwrite, event);\n            }\n        });\n\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\n        // and trigger different events;\n        if (editableEntityElements.length > 0) {\n            const inSelectionEntityElements = this.editor.queryElements(\n                selector,\n                QueryScope.InSelection\n            );\n            editableEntityElements.forEach(element => {\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\n                tryTriggerEntityEvent(\n                    this.editor,\n                    element,\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\n                    event\n                );\n            });\n        }\n    }\n}\n\n/**\n * IE will show a resize border around the readonly content within content editable DIV\n * This is a workaround to remove it by temporarily move focus out of editor\n */\nconst workaroundSelectionIssueForIE = Browser.isIE\n    ? (editor: Editor) => {\n          editor.runAsync(() => {\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\n                  const button = editor.getDocument().createElement('button');\n                  button.style.overflow = 'hidden';\n                  button.style.position = 'fixed';\n                  button.style.width = '0';\n                  button.style.height = '0';\n                  button.style.left = '0';\n                  button.style.top = '-1000px';\n                  button.onblur = () => {\n                      button.style.display = 'none';\n                  };\n\n                  editor.insertNode(button, {\n                      position: ContentPosition.Outside,\n                  });\n\n                  return button;\n              });\n\n              workaroundButton.style.display = '';\n              const range = editor.getDocument().createRange();\n              range.setStart(workaroundButton, 0);\n              try {\n                  window.getSelection().removeAllRanges();\n                  window.getSelection().addRange(range);\n              } catch {}\n          });\n      }\n    : () => {};\n","import getEntityElement from './getEntityElement';\nimport tryTriggerEntityEvent from './tryTriggerEntityEvent';\nimport { cacheGetEventData, ContentEditFeature, Editor, Keys } from 'roosterjs-editor-core';\nimport { Position } from 'roosterjs-editor-dom';\nimport {\n    EntityOperation,\n    NodeType,\n    PluginKeyboardEvent,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * @internal\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\n * clicks on a readonly entity.\n */\nexport const ClickOnEntityFeature: ContentEditFeature = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: cacheGetReadonlyEntityElement,\n    handleEvent: (event, editor) => {\n        const entityElement = cacheGetReadonlyEntityElement(event, editor);\n        tryTriggerEntityEvent(editor, entityElement, EntityOperation.Click, event.rawEvent);\n    },\n};\n\n/**\n * @internal\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\n * presses ESC on a readonly entity.\n */\nexport const EscapeFromEntityFeature: ContentEditFeature = {\n    keys: [Keys.ESCAPE],\n    shouldHandleEvent: cacheGetReadonlyEntityElement,\n    handleEvent: (event, editor) => {\n        const entityElement = cacheGetReadonlyEntityElement(event, editor);\n        tryTriggerEntityEvent(editor, entityElement, EntityOperation.Escape, event.rawEvent);\n    },\n};\n\n/**\n * @internal\n * A content edit feature to split current line into two lines at the cursor when user presses\n * ENTER right before a readonly entity.\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\n * empty line. So we override the default behavior here.\n */\nexport const EnterBeforeReadonlyEntityFeature: ContentEditFeature = {\n    keys: [Keys.ENTER],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            false /*collapseOnly*/,\n            true /*checkForSameLine*/\n        ),\n    handleEvent: (event, editor) => {\n        event.rawEvent.preventDefault();\n\n        const range = editor.getSelectionRange();\n        const node = Position.getEnd(range).normalize().node;\n        const br = editor.getDocument().createElement('BR');\n        node.parentNode.insertBefore(br, node.nextSibling);\n\n        const block = editor.getBlockElementAtNode(node);\n        let newContainer: HTMLElement;\n\n        if (block) {\n            newContainer = block.collapseToSingleElement();\n            br.parentNode?.removeChild(br);\n        }\n\n        editor.getSelectionRange().deleteContents();\n\n        if (newContainer.nextSibling) {\n            editor.select(newContainer.nextSibling, PositionType.Begin);\n        }\n    },\n};\n\n/**\n * @internal\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\n * press BACKSPACE right after an entity\n */\nexport const BackspaceAfterEntityFeature: ContentEditFeature = {\n    keys: [Keys.BACKSPACE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        const element = cacheGetNeighborEntityElement(\n            event,\n            editor,\n            false /*isNext*/,\n            true /*collapseOnly*/\n        );\n        tryTriggerEntityEvent(editor, element, EntityOperation.RemoveFromEnd, event.rawEvent);\n    },\n};\n\n/**\n * @internal\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\n * press DELETE right after an entity\n */\nexport const DeleteBeforeEntityFeature: ContentEditFeature = {\n    keys: [Keys.DELETE],\n    shouldHandleEvent: (event, editor) =>\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\n    handleEvent: (event, editor) => {\n        const element = cacheGetNeighborEntityElement(\n            event,\n            editor,\n            true /*isNext*/,\n            true /*collapseOnly*/\n        );\n        tryTriggerEntityEvent(editor, element, EntityOperation.RemoveFromStart, event.rawEvent);\n    },\n};\n\nfunction cacheGetReadonlyEntityElement(event: PluginKeyboardEvent, editor: Editor) {\n    return cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\n        const entityElement = getEntityElement(editor, event.rawEvent.target as Node);\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\n    });\n}\n\nfunction cacheGetNeighborEntityElement(\n    event: PluginKeyboardEvent,\n    editor: Editor,\n    isNext: boolean,\n    collapseOnly: boolean,\n    checkForSameLine?: boolean\n): HTMLElement {\n    return cacheGetEventData(\n        event,\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly + '_' + !!checkForSameLine,\n        () => {\n            const range = editor.getSelectionRange();\n\n            if (collapseOnly && !range.collapsed) {\n                return null;\n            }\n\n            const pos = Position.getEnd(range);\n            const lookForPrev = !isNext && (pos.node.nodeType != NodeType.Text || pos.offset == 0);\n            const lookForNext = isNext && (pos.node.nodeType != NodeType.Text || pos.isAtEnd);\n            let entityNode: HTMLElement = null;\n\n            if (lookForNext || lookForPrev) {\n                const traverser = editor.getBodyTraverser(pos.node);\n                const sibling = lookForPrev\n                    ? traverser.getPreviousInlineElement()\n                    : traverser.getNextInlineElement();\n                let node = sibling && sibling.getContainerNode();\n\n                if (checkForSameLine) {\n                    const block = editor.getBlockElementAtNode(pos.node);\n                    if (!block || !block.contains(node)) {\n                        node = null;\n                    }\n                }\n\n                entityNode = getEntityElement(editor, node);\n            }\n\n            return entityNode;\n        }\n    );\n}\n","import createEntityWrapper from './createEntityWrapper';\nimport getEntityElement from './getEntityElement';\nimport getEntityFromElement from './getEntityFromElement';\nimport { Editor } from 'roosterjs-editor-core';\nimport { Position } from 'roosterjs-editor-dom';\nimport {\n    ChangeSource,\n    ContentPosition,\n    Entity,\n    NodePosition,\n    PositionType,\n} from 'roosterjs-editor-types';\n\n/**\n * Insert an entity into editor.\n * @param editor The editor to insert entity into.\n * @param type Type of the entity\n * @param contentNode Root element of the entity\n * @param isBlock Whether the entity will be shown as a block\n * @param isReadonly Whether the entity will be a readonly entity\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\n * If isBlock is true, entity will be insert below this position\n */\nexport default function insertEntity(\n    editor: Editor,\n    type: string,\n    contentNode: Node,\n    isBlock: boolean,\n    isReadonly: boolean,\n    position?: NodePosition\n): Entity {\n    const wrapper = createEntityWrapper(editor, type, contentNode, isBlock, isReadonly);\n\n    let currentRange: Range;\n\n    if (position) {\n        currentRange = editor.getSelectionRange();\n        const node = position.normalize().node;\n        const existingEntity = getEntityElement(editor, node);\n\n        // Do not insert entity into another entity\n        if (existingEntity) {\n            position = new Position(existingEntity, PositionType.After);\n        }\n\n        editor.select(position);\n    }\n\n    editor.insertNode(wrapper, {\n        updateCursor: false,\n        insertOnNewLine: isBlock,\n        replaceSelection: true,\n        position: ContentPosition.SelectionStart,\n    });\n\n    if (isBlock) {\n        // Insert an extra empty line for block entity to make sure\n        // user can still put cursor below the entity.\n        const br = editor.getDocument().createElement('BR');\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\n    }\n\n    if (currentRange) {\n        editor.select(currentRange);\n    } else if (!isBlock) {\n        editor.select(wrapper, PositionType.After);\n    }\n\n    const entity = getEntityFromElement(wrapper);\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\n\n    return entity;\n}\n"],"sourceRoot":""}