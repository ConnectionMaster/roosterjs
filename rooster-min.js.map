{"version":3,"sources":["webpack://roosterjs/webpack/bootstrap","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTagOfNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/contains.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/Position.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/safeInstanceOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/toArray.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getBlockElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafSibling.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/execCommand.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/createRange.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/applyInlineStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/wrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementAtNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/queryElements.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/collapseNodes.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitParentNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/findClosestElementAncestor.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/shouldSkipNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/isNodeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/fromHtml.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/ContentTraverser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/NodeInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/PartialInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/Browser.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/changeElementTag.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyTextStyle.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/splitTextNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getComputedStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getInlineElementBeforeAfter.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/arrayPush.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isNodeEmpty.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/unwrap.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VList.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getListTypeFromNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectionRangeInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/getStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/style/setStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canMoveCurrentSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/processList.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentToggleListType.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/getAllFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/NodeBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/isVoidHtmlElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/getFirstLastBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/ImageInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/LinkInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/getFirstLastInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getLeafNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/inlineElements/EmptyInlineElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/normalizeRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/getRootListNode.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getSelectedBlockElementsInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/getRegionsFromRange.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/collapseNodesInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/mergeBlocksInRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getPredefinedCssForElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/clearProceedingSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getInheritableStyles.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/cloneObject.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isModifierKey.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentCommitListChains.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setBackgroundColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontName.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setTextColor.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBold.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleItalic.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleUnderline.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/blockWrap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/hasFocus.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordCustomData.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/LevelLists.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/constants.ts","webpack://roosterjs/./packages/roosterjs/lib/index.ts","webpack://roosterjs/./packages/roosterjs/lib/createEditor.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/ContentEdit.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/autoLinkFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeFontSize.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/blockElements/StartEndBlockElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/BodyScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionBlockScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/SelectionScoper.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/contentTraverser/PositionContentSearcher.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/applyFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/extractClipboardEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getPendableFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/matchLink.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/getTextContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/utils/readFile.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/table/VTable.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListItem.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/createVListFromRegion.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/list/VListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/region/regionTypeData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getPositionRect.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/isPositionAtBeginningOf.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/getHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/setHtmlWithSelectionPath.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/addRangeToSelection.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/selection/deleteSelectedContent.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/addSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/moveCurrentSnapsnot.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/createSnapshots.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/snapshots/canUndoAutoComplete.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/HtmlSanitizer.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/getAllowedValues.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/createDefaultHtmlSanitizerOptions.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/htmlSanitizer/chainSanitizerCallback.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/commitEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntityFromElement.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/entity/getEntitySelector.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/cacheGetEventData.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/clearEventDataCache.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCharacterValue.ts","webpack://roosterjs/./packages/roosterjs-editor-dom/lib/event/isCtrlOrMetaPressed.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearBlockFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/clearFormat.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/createLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/getFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertEntity.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/insertImage.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/insertTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/editTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/table/formatTable.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/removeLink.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/replaceWithNode.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/rotateElement.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setAlignment.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setDirection.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/utils/collapseSelectedBlocks.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setImageAltText.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/setIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/experiment/experimentSetIndentation.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/changeCapitalization.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBullet.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleNumbering.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleBlockQuote.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleCodeBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleStrikethrough.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSubscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleSuperscript.ts","webpack://roosterjs/./packages/roosterjs-editor-api/lib/format/toggleHeader.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/cursorFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/entityFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/listFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/markdownFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/quoteFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/shortcutFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/structuredNodeFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContentEdit/features/tableFeatures.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/editor/Editor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/coreApiMap.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/addUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/attachDomEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/createPasteFragment.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/ensureTypeInContainer.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/focus.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getSelectionRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/getStyleBasedFormatState.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/insertNode.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/restoreUndoSnapshot.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/selectRange.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/setContent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/transformColor.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/coreApi/triggerEvent.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/createCorePlugins.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/CopyPastePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/DOMEventPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EditPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/EntityPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/LifecyclePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/MouseUpPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/PendingFormatStatePlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeAfterLinkPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/TypeInContainerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-core/lib/corePlugins/UndoPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/HyperLink/HyperLink.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/Paste.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/excelConverter/convertPastedContentFromExcel.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/convertPastedContentFromWord.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/wordConverter.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/WordConverterArguments.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/wordConverter/converterUtils.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/lineMerge/handleLineMerge.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/convertPastedContentFromWordOnline.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Paste/officeOnlineConverter/ListItemBlock.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ContextMenu/ContextMenu.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CustomReplace/CustomReplace.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/CutPasteListChain/CutPasteListChain.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/ImageResize/ImageResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Picker.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Picker/PickerPlugin.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/TableResize/TableResize.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/Watermark.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/index.ts","webpack://roosterjs/./packages/roosterjs-editor-plugins/lib/plugins/Watermark/Watermark.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","default","Browser","getBrowserInfo","getComputedStyle","PendableFormatCommandMap","splitBalancedNodeRange","getNextLeafSibling","getPreviousLeafSibling","getFirstLeafNode","getLastLeafNode","node","nodeType","tagName","toUpperCase","container","contained","treatSameNodeAsContain","commonAncestorContainer","parentNode","contains","internalContains","nodeOrPosition","offsetOrPosType","isFromEndOfRange","this","offset","getIndexOfNode","isAtEnd","nextSibling","getEndOffset","endOffset","Math","max","min","element","normalize","firstChild","newOffset","nextNode","lastChild","childNodes","Position","equalTo","position","isAfter","move","getStart","range","startContainer","startOffset","getEnd","collapsed","endContainer","previousSibling","nodeValue","length","getTargetWindow","source","document","ownerDocument","toString","apply","defaultView","window","obj","typeName","targetWindow","targetType","mainWindow","mainWindowType","collection","slice","FONT_SIZES","getElementBasedFormatState","findHeadTailLeafNode","containerBlockNode","isTail","result","sibling","rootNode","getBlockContext","headNode","tailNode","nodes","getLeafSibling","startNode","isNext","skipTags","ignoreSpace","getSibling","getChild","curNode","shouldContinue","indexOf","pendableFormatCommands","editor","command","focus","formatter","getDocument","execCommand","getSelectionRange","addUndoSnapshot","keys","map","isPendableFormatCommand","triggerPluginEvent","formatState","getPendableFormatState","getFocusablePosition","isNodePosition","arg","getPositionFromPath","path","arg1","arg2","arg3","arg4","start","end","Array","isArray","createRange","setStart","setEnd","callback","getTagOfNode","createTextNode","insertNode","applyTextStyle","select","firstNode","lastNode","contentTraverser","getSelectionTraverser","inlineElement","currentInlineElement","nextInlineElement","getNextInlineElement","applyStyle","isInnerNode","node1","node2","compareDocumentPosition","wrapper","test","createElement","insertBefore","appendChild","parent","parentBlock","nodeChain","push","currentNode","tag","resolveInlineElement","checkPosition","targets","some","target","selector","forEachCallback","scope","elements","querySelectorAll","child","filter","endNode","nodeContainedByRangeOnly","startPosition","endPosition","targetPositions","isIntersectWithNodeRange","forEach","collapse","root","ref","isStart","canSplitParent","startIndex","endIndex","splitParentNode","splitBefore","newParent","cloneNode","removeAttribute","innerHTML","temp","BLOCK_ELEMENT_TAGS","split","BLOCK_DISPLAY_STYLES","style","display","closest","matches","msMatchesSelector","parentElement","CRLF","CRLFSPACE","shouldSkipNode","textContent","replace","region","nodeBefore","nodeAfter","html","scoper","createBodyTraverser","ContentTraverser","createSelectionTraverser","createBlockTraverser","currentBlock","getStartBlockElement","getNextBlockElement","getPreviousNextBlockElement","getPreviousBlockElement","current","currentBlockElement","leaf","getEndNode","getStartNode","newBlock","isBlockInScope","currentInline","getStartInlineElement","getPreviousNextInlineElement","getPreviousInlineElement","newInline","getInlineElementBeforeAfter","getStartPosition","getParentBlock","getContainerNode","previousInlineElement","getNextPreviousInlineElement","trimInlineElement","containerNode","getTextContent","getEndPosition","isTextualInlineElement","pos","styler","getDecoratedInline","PartialInlineElement","thisStart","otherEnd","from","to","previousNode","userAgent","appVersion","isIE11OrGreater","isIE","isChrome","isFirefox","isSafari","isEdge","isWebKit","isMac","isWin","isIEOrEdge","navigator","newTag","newElement","attributes","attr","setAttribute","marginTop","marginBottom","replaceChild","beforeRunCallback","regions","getSelectedRegions","isFeatureEnabled","VListChain","createListChains","STYLETAGS","callStylerWithInnerNode","formatNodes","formatNode","parentTag","every","shift","removeChild","textNode","returnFirstPart","firstPart","substr","secondPart","newNode","getComputedStyles","styleNames","styles","getPropertyValue","toLowerCase","px2Pt","px","round","parseFloat","styleName","isPartial","mainArray","itemsArray","VISIBLE_ELEMENT_TAGS","VISIBLE_CHILD_ELEMENT_SELECTOR","join","ZERO_WIDTH_SPACE","trim","trimContent","rootList","items","Error","moveChildNodesToLi","moveLiToList","populateItems","item","getLastItemNumber","undefined","getListType","getLevel","writeBack","lastList","doc","listStack","createDocumentFragment","placeholder","topList","setIndentation","indentation","findListItems","outdent","indent","changeListType","needChangeType","appendItem","type","nodeTag","mergeVList","list","originalLength","splice","mergeOrphanNodesAfter","isOrphanItem","canMerge","mergeItems","listStartPos","getNode","listEndPos","index","listTypes","newListTypes","isListElement","currentItem","li","furtherNodes","getListTypeFromNode","regionBase","regionRange","fullSelectionEnd","fullSelectionStart","isRegion","regionStart","regionEnd","getAttribute","pair","valueIndex","x","snapshots","step","newIndex","currentIndex","existingList","getElementAtCursor","parentLINode","currentRange","currentSelectionPath","getSelectionPath","listParent","nextElementSibling","insertAdjacentElement","wrappedContents","wrap","toArray","wrappedRange","wrappedSelectionPath","deleteNode","newRange","childElementCount","newList","listType","startNumber","chains","chain","canAppendAtCursor","vList","createVListAtBlock","getBlockElementAtNode","collapseToSingleElement","createVListFromRegion","allFeatures","ListFeatures","QuoteFeatures","TableFeatures","StructuredNodeFeatures","AutoLinkFeatures","ShortcutFeatures","CursorFeatures","MarkdownFeatures","EntityFeatures","equals","blockElement","HTML_VOID_ELEMENTS","isFirst","getLeafNode","clientRect","left","right","top","bottom","ancestor","createBlockIfEmpty","blocks","traverser","block","getRegionCreator","fullRange","firstNodeOfRegion","lastNodeOfRegion","firstNodeValid","lastNodeValid","bothValid","areNodesValid","innerSelector","boundaryTree","allBoundaries","innerNode","children","outerSelector","inSelectionOuterNode","thisInnerNode","thisOuterNode","boundary","outerNode","boundaries","buildBoundaryTree","iterateNodes","creator","started","ended","previousOuterNode","newRegions","concat","nodesOrBlockElements","refNode","targetNode","blockRoot","commonContainer","safeInstanceOf","nodeToRemove","nodeToMerge","PREDEFINED_CSS_FOR_ELEMENT","B","EM","I","U","P","PRE","S","STRIKE","SUB","SUP","additionalPredefinedCssForElement","getPositionPath","unshift","isPreviousText","removedSize","totalSize","autoCompleteIndex","INHERITABLE_PROPERTIES","win","cloneObject","assign","existingObj","event","isCtrlKey","ctrlKey","isAltKey","altKey","isMetaKey","metaKey","commit","color","backgroundColor","isDarkMode","darkModeColor","lightModeColor","dataset","fontName","fontFamily","fontSize","lineHeight","wrapFunction","getSelectedBlockElementsInRegion","collapseNodesInRegion","NodeTag","isNodeInRegion","hasFocus","core","activeElement","contentDiv","getAndSetNodeId","wordCustomData","id","nextNodeId","dict","listsMetadata","currentUniqueListId","WORD_ORDERED_LIST_SELECTOR","WORD_UNORDERED_LIST_SELECTOR","WORD_ONLINE_IDENTIFYING_SELECTOR","LIST_CONTAINER_ELEMENT_CLASS_NAME","UNORDERED_LIST_TAG_NAME","ORDERED_LIST_TAG_NAME","WAC_IDENTIFING_SELECTOR","additionalPlugins","initialContent","plugins","HyperLink","Paste","ContentEdit","options","defaultFormat","textColor","Editor","settingsOverride","additionalFeatures","getName","initialize","features","feature","hasSettingForKey","defaultDisabled","addContentEditFeature","dispose","TRAILING_PUNCTUATION_REGEX","AutoLink","shouldHandleEvent","cacheGetLinkData","handleEvent","anchor","linkData","searcher","getContentSearcherOfCursor","originalUrl","href","normalizedUrl","runAsync","replaceWithNode","clearEventDataCache","UnlinkWhenBackspaceAfterLink","getInlineElementBefore","LinkInlineElement","rawEvent","preventDefault","removeLink","eventType","cacheGetEventData","clipboardData","data","link","matchLink","text","getRangeFromText","word","getWordBefore","trailingPunctuation","match","substring","str","autoLink","unlinkWhenBackspaceAfterLink","getNewFontSize","pt","changeBase","fontSizes","floor","ceil","last","change","STRUCTURE_NODE_TAGS","StartEndBlockElement","blockContext","getFirstInlineElement","startFrom","blockNode","getLastInlineElement","getFirstLastInlineElementFromBlockElement","startInline","getInlineElementAfter","startBlock","inScope","selStartBlock","selEndBlock","inline","startPartial","endPartial","WHITESPACE_REGEX","inlineElements","traverse","inlineBefore","inlineAfter","getSubStringBefore","exactMatch","textIndex","forEachTextInlineElement","textInline","nodeContent","nodeIndex","charCodeAt","getNearestNonTextInlineElement","nearestNonTextInlineElement","traversingComplete","previousInline","exec","format","elementStyle","textColors","backgroundColors","bold","italic","underline","fontWeight","fontStyle","textDecoration","CLIPBOARD_HTML_HEADER_REGEX","getImage","dataTransfer","fileCount","getAsFile","files","file","workaroundForEdge","headerValues","parseInt","getAsString","Promise","resolve","types","getData","image","rawHtml","handlers","promise","allowLinkPreview","linkPreview","JSON","parse","all","handler","then","values","isBold","isItalic","isUnderline","isStrikeThrough","isSubscript","isSuperscript","reduce","state","queryCommandState","httpExcludeRegEx","domainPortWithUrlRegEx","domainPortRegEx","linkMatchRules","http","RegExp","except","normalizeUrl","url","https","mailto","notes","unc","ftp","news","telnet","gopher","wais","schema","rule","scheme","FileReader","onload","onerror","readAsDataURL","trs","table","td","getTableFromTd","rows","cells","row","tr","rowIndex","sourceCol","targetCol","col","colSpan","rowSpan","spanLeft","spanAbove","moveChildren","cell","recalcSpans","applyFormat","borderCollapse","bgColorOdd","bgColorEven","borderTop","getBorderStyle","topBorderColor","borderBottom","bottomBorderColor","borderLeft","verticalBorderColor","borderRight","edit","operation","currentRow","currentCell","cloneCell","countSpanAbove","colIndex","nextCell","getCell","newCell","getTd","forEachCellOfCurrentColumn","countSpanLeft","forEachCellOfColumn","forEachCellOfCurrentRow","rowStep","aboveCell","belowCell","colStep","leftCell","rightCell","splitRow","forEachCellOfRow","getCurrentTd","isNaN","fromNode","toNode","orderListStyles","wrapIfNotBlockNode","pop","originalRoot","nextLevel","createListElement","newRoot","listStyleType","checkFirst","checkLast","tryIncludeSiblingNode","includeSiblingLists","nodeForItem","listNode","createVListFromItemNode","lastChainIndex","lastNumber","lastNumberBeforeCursor","nameGenerator","ol","canAppendToTail","createListChainName","afterCurrentNode","append","applyChainName","lists","getLists","vlist","isAfterCurrentNode","regionTypeData","rect","getBoundingClientRect","rects","getClientRects","span","areAllPrevousNodesEmpty","isDOMChanged","tbody","content","selectionPath","stringify","pathComment","skipSameRange","selection","getSelection","needAddRange","rangeCount","getRangeAt","removeAllRanges","e","addRange","ensureBeforeAndAfter","emptyNode","nodesToDelete","nodesPairToMerge","beforeEnd","afterEnd","beforeStart","afterStart","snapshot","isAutoCompleteSnapshot","removeCount","maxSize","elementCallbacks","styleCallbacks","getStyleCallbacks","cssStyleCallbacks","attributeCallbacks","tagReplacements","getTagReplacement","additionalTagReplacements","allowedAttributes","getAllowedAttributes","additionalAllowedAttributes","allowedCssClassesRegex","getAllowedCssClassesRegex","additionalAllowedCssClasses","defaultStyleValues","getDefaultStyleValues","additionalDefaultStyleValues","additionalGlobalStyleNodes","unknownTagReplacement","convertInlineCss","additionalStyleNodes","HtmlSanitizer","sanitizeHtml","sanitizer","currentStyles","currentElementOrStyle","convertCssOnly","DOMParser","parseFromString","body","convertGlobalCssToInlineCss","sanitize","processNode","styleNodes","reverse","sheet","styleSheet","j","styleRule","cssRules","cssText","CSSRule","STYLE_RULE","selectorText","currentStyle","context","isElement","isText","isFragment","shouldKeep","replacement","whiteSpace","thisStyle","processAttributes","preprocessCss","processCss","next","predefinedStyles","isInheritable","keep","attribute","newValue","processCssClass","originalValue","calculatedValue","originalClasses","calculatedClasses","className","HTML_TAG_REPLACEMENT","a","abbr","address","area","article","aside","b","bdi","bdo","blockquote","br","button","canvas","caption","center","cite","code","colgroup","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","fieldset","figcaption","figure","font","footer","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","img","input","ins","kbd","label","legend","main","mark","menu","menuitem","meter","nav","optgroup","option","output","picture","pre","progress","q","rp","rt","ruby","samp","section","small","strike","strong","sub","summary","sup","template","textarea","tfoot","th","thead","time","tt","u","ul","var","wbr","xmp","form","applet","audio","base","basefont","embed","frame","frameset","iframe","meta","noscript","param","script","slot","title","track","video","ALLOWED_HTML_ATTRIBUTES","DEFAULT_STYLE_VALUES","overflow","padding","border","float","ALLOWED_CSS_CLASSES","removeValue","removeWidthForLiAndDiv","additionalReplacements","replacements","additionalAttributes","array","self","toLocaleLowerCase","additionalCssClasses","patterns","additionalDefaultStyles","callbacks","width","newCallback","args","isReadonly","contentEditable","isEntity","eventDataCache","isCtrlOrMetaPressed","TAGS_TO_UNWRAP","ATTRIBUTES_TO_PRESERVE","TAGS_TO_STOP_UNWRAP","clearNodeFormat","areAllChildrenBlock","returnBlockElement","isBlockElement","isVoidHtmlElement","unwrap","isTableCell","removeNonBorderStyles","clearAttribute","getStyles","setStyles","nonborderStyles","STYLES_TO_REMOVE","queryElements","getDefaultFormat","isDefaultFormatEmpty","removeProperty","URI_REGEX","MAILTO_REGEX","FTP_REGEX","getAnchorNodeAtCursor","updateAnchorDisplayText","displayText","altText","santizer","checkXss","prefix","search","applyLinkPrefix","listTag","headerTag","isBullet","isNumbering","headerLevel","canUnlink","canAddImageAltText","isBlockQuote","getStyleBasedFormatState","getUndoState","contentNode","isBlock","commitEntity","contentPosition","existingEntity","getEntitySelector","updateCursor","insertOnNewLine","replaceSelection","entity","getEntityFromElement","triggerContentChangedEvent","insertImageWithSrc","src","maxWidth","imageFile","readFile","dataUrl","isDisposed","getTableCellWidth","columns","fragment","cellSpacing","cellPadding","vtable","VTable","cellToSelect","currentCol","newRow","newCol","calculateCellToSelect","textOrRange","backupRange","angle","transform","alignment","align","textAlign","direction","isEmptyBlockUnderTR","quote","findClosestElementAncestor","blockGroups","group","capitalization","language","getCapitalizedText","originalText","toLocaleUpperCase","wordArray","charAt","regex","DEFAULT_STYLER","borderColor","paddingLeft","PRE_TAG","level","wrapped","replaceNode","NoCycleCursorMove","allowFunctionKeys","ctrlOrMeta","isPositionAtBeginning","rtl","which","noCycleCursorMove","ClickOnEntityFeature","cacheGetReadonlyEntityElement","EscapeFromEntityFeature","entityElement","isContentEditable","EnterBeforeReadonlyEntityFeature","cacheGetNeighborEntityElement","newContainer","deleteContents","BackspaceAfterEntityFeature","DeleteBeforeEntityFeature","collapseOnly","entityNode","getBodyTraverser","clickOnEntity","escapeFromEntity","enterBeforeReadonlyEntity","backspaceAfterEntity","deleteBeforeEntity","IndentWhenTab","shiftKey","cacheGetListElement","OutdentWhenShiftTab","MergeInNewLine","isPositionAtBeginningOf","getListChains","experimentCommitListChains","toggleListAndPreventDefault","OutdentWhenBackOn1stEmptyLine","isNodeEmpty","OutdentWhenEnterOnEmptyLine","AutoBullet","textBeforeCursor","rangeToDelete","prepareAutoBullet","toggleBullet","toggleNumbering","num","MaintainListChain","listInfo","listElement","autoBullet","indentWhenTab","outdentWhenShiftTab","outdentWhenBackspaceOnEmptyFirstLine","outdentWhenEnterOnEmptyLine","mergeInNewLineWhenBackspaceOnFirstChar","maintainListChain","generateBasicMarkdownFeature","triggerCharacter","elementTag","useShiftKey","cacheGetRangeForMarkdownOperation","textContentRange","cloneRange","elementToWrap","extractContents","nonPrintedSpaceTextNode","handleMarkdownEvent","textInlineElement","inlineTextContent","contentIndex","MarkdownBold","MarkdownItalic","MarkdownStrikethru","MarkdownInlineCode","markdownBold","markdownItalic","markdownStrikethru","markdownInlineCode","QUOTE_TAG","STRUCTURED_TAGS","UnquoteWhenBackOnEmpty1stLine","childOfQuote","cacheGetQuoteChild","splitQuote","UnquoteWhenEnterOnEmptyLine","getFocusedPosition","unquoteWhenBackspaceOnEmptyFirstLine","unquoteWhenEnterOnEmptyLine","createCommand","winKey","macKey","action","commands","toggleBold","toggleItalic","toggleUnderline","undo","redo","changeFontSize","DefaultShortcut","cacheGetCommand","stopPropagation","cmd","defaultShortcut","NEWLINE_HTML","CHILD_PARENT_TAG_MAP","TD","TH","LI","CHILD_SELECTOR","InsertLineBeforeStructuredNodeFeature","cacheGetStructuredElement","fromHtml","insertLineBeforeStructuredNodeFeature","TabInTable","cacheGetTableCell","editTable","UpDownInTable","isUp","targetTd","hasShiftKey","anchorNode","anchorOffset","newPos","setBaseAndExtent","firstTd","tabInTable","upDownInTable","corePlugins","PLACEHOLDER_PLUGIN_NAME","arrayPush","api","coreApiMap","coreApiOverride","getPluginState","plugin","ensureTypeInContainer","existingNode","transformColorForDarkMode","transformColor","scopeOrCallback","Function","collapseNodes","isEmpty","getContent","setContent","insertContent","allNodes","deleteSelectedContent","paste","pasteAsText","applyCurrentFormat","snapshotBeforePaste","createPasteFragment","tryGetFromCache","selectRange","sel","focusNode","focusOffset","getRegionsFromRange","addDomEventHandler","nameOrMap","eventsToMap","attachDomEvent","broadcast","triggerEvent","restoreUndoSnapshot","changeSource","canUndoByBackspace","hasNewContent","snapshotsService","canUndo","canMove","canRedo","getScrollContainer","domEvent","scrollContainer","getCustomData","disposer","lifecycle","customData","isInIME","getBlockTraverser","PositionContentSearcher","requestAnimationFrame","setEditorDomAttribute","getEditorDomAttribute","keyboardEvent","setDarkModeState","nextDarkMode","currentContent","experimentalFeatures","undoState","isNested","addSnapshot","autoCompletePosition","eventMap","disposers","eventName","handlerObj","pluginEventType","beforeDispatch","onEvent","addEventListener","removeEventListener","processStyles","applyCurrentStyle","sanitizingOption","createDefaultHtmlSanitizerOptions","htmlBefore","htmlAfter","htmlAttributes","createBeforePasteEvent","imageDataUri","querySelector","attrs","lastIndexOf","pendableFormat","styleBasedForamt","getCurrentFormat","line","lines","getInheritableStyles","shouldSetNodeStyles","innerText","wasNodeJustCreatedByKeyboardEvent","selectionRange","triggerExtractContentEvent","includeSelectionMarker","clonedRoot","originalRange","getHtmlWithSelectionPath","ogTextColorNode","ogBackgroundColorNode","adjustSteps","nodeToInsert","safeRemove","normalizedPosition","splitTextNode","splitter","rootNodeToInsert","rootNodes","hasBrNextToRoot","listItem","tdNode","trNode","newTable","currentTable","shouldInsertListAsText","changeElementTag","isBegin","getFirstLastBlockElement","insertedNode","rangeToRestore","nodeForCursor","isRestoring","addRangeToSelection","pendingFormatState","pendableFormatState","pendableFormatPosition","restorePendingFormatState","contentChanged","setHtmlWithSelectionPath","STYLE_DATASET_MAP","ATTR_DATASET_MAP","getValueOrDefault","defualtValue","includeSelf","elementsToTransform","allChildren","getElementsByTagName","getAll","onExternalContentTransform","pluginEvent","onPluginEvent","willHandleEventExclusively","handledExclusively","corePluginOverride","typeInContainer","_placeholder","typeAfterLink","mouseUp","copyPaste","getState","onPaste","extractClipboardEvent","getTempDiv","cleanUpAndRestoreSelection","copy","onCutCopy","cut","isCut","forceInLightMode","tempDiv","onDrop","onFocus","onBlur","onScroll","onKeybaordEvent","isCharacterValue","onInputEvent","onContextMenuEvent","allItems","elementBeforeCursor","eventTargetNode","contextMenuProviders","provider","getContextMenuItems","stopPrintableKeyboardEventPropagation","allowKeyboardEventPropagation","isContextMenuProvider","keypress","getEventHandler","keydown","keyup","mousedown","contextmenu","compositionstart","compositionend","drop","hasFunctionKey","ENTITY_ID_REGEX","handleCutEvent","checkRemoveEntityForRange","clickingPoint","knownEntityElements","handleMouseDownEvent","handleMouseUpEvent","handleKeyDownEvent","handleBeforePasteEvent","handleContentChangedEvent","handleExtractContentWithDomEvent","handleContextMenuEvent","pageX","pageY","workaroundSelectionIssueForIE","resetAll","allId","hydrateEntity","editableEntityElements","isFullyCovered","knownIds","baseId","newId","workaroundButton","height","onblur","COMMANDS","DARK_MODE_DEFAULT_FORMAT","contentDivFormat","initializer","setSelectStyle","inDarkMode","recalculateDefaultFormat","adjustBrowserBehavior","userSelect","msUserSelect","webkitUserSelect","baseFormat","onMouseUp","removeMouseUpEventListener","mouseUpEventListerAdded","clear","getCurrentPosition","undoSnapshotService","createSnapshots","delta","canMoveCurrentSnapshot","moveCurrentSnapsnot","clearRedo","clearProceedingSnapshots","canUndoAutoComplete","onKeyDown","onKeyPress","clearRedoForInput","evt","lastKeyPress","getTooltipCallback","onLinkClick","trackedLink","onMouse","tryGetHref","updateLinkHrefIfShouldUpdate","resetLinkTracking","mouseover","mouseout","blur","isContentEditValue","shouldCheckUpdateLink","originalHref","doesLinkDisplayMatchHref","srcElement","open","updateLinkHref","escapedDisplay","wacListElements","el","margin","isWordOnlineWithList","LAST_TD_END_REGEX","LAST_TR_END_REGEX","LAST_TR_REGEX","LAST_TABLE_REGEX","excelHandler","trMatch","tableMatch","chainSanitizerCallback","borderStyle","wordConverter","createWordConverter","wordConverterArgs","createWordConverterArguments","processNodesDiscovery","processNodeConvert","nextUniqueId","numBulletsConverted","numNumberedConverted","createCustomData","listItems","currentListIdsByLevels","createLevelLists","lastProcessedItem","LINE_BREAKS","getOrCreateListForNode","metadata","listMetadata","recurringGetOrCreateListAtNode","possibleList","getRealPreviousSibling","listId","getObject","uniqueListId","setObject","convertListIfNeeded","cleanupListIgnore","levels","nodesToRemove","isEmptySpan","fixWordListComments","isIgnoreNode","getListItemMetadata","listatt","getStyleValue","listprops","wordListId","originalNode","isFakeBullet","fakeBullet","getFakeBulletText","removeComments","nextElement","endComment","getRealNextSibling","newSpan","prevSibling","isEmptyTextNode","resetCurrentLists","ll","itemMetadata","levelInfo","ignore","numberOfItems","secondFakeBullet","firstFakeBullet","processBlock","checkAndAddBr","insertConvertedListToDoc","convertedListElement","listItemBlock","insertPositionNode","startElement","replaceRegex","prevParent","nextParent","sanitizeListItemContainer","curListItemBlock","listElements","curItem","listItemContainers","lastItemInCurBlock","endElement","createListItemBlock","getListItemBlocks","itemBlock","flattenListBlock","listItemContainer","getContainerListType","itemLevel","listRootElement","itemToInsert","curListLevel","lastElementChild","lastChildTag","firstElementChild","insertListItem","parentContainer","onDismiss","isMenuShowing","dismiss","allowDefaultMenu","initContainer","render","y","makeReplacement","sourceString","replacementHTML","matchSourceCaseSensitive","defaultReplacements","updateReplacements","newReplacements","longestReplacementLength","replacementEndCharacters","endChars","Set","lastChar","add","getReplacementEndCharacters","has","stringToSearch","getMatchingReplacement","matchingText","matchingRange","parsingSpan","lowerCaseStringToSearch","sourceMatch","replacementMatch","cacheListChains","expectedChangeSource","ENTITY_TYPE","CORNER_HANDLE_POSITIONS","ALL_HANDLE_POSITIONS","minWidth","minHeight","selectionBorderColor","forcePreserveRatio","resizableImageSelector","startResize","getSelectedImage","startPageX","startPageY","startWidth","clientWidth","startHeight","clientHeight","doResize","finishResize","stopEvent","widthChange","heightChange","newWidth","calculateNewWidth","newHeight","calculateNewHeight","shouldPreserveRatio","isSingleDirectionNS","isSingleDirectionWE","ratio","resizeDiv","removeResizeDiv","hideResizeHandle","onDragStart","dragstart","currentImg","showResizeHandle","createResizeDiv","selectImageAfterUnSelect","isWest","isNorth","selectedImage","divWithImage","ESC_CHARCODE","LEFT_ARROW_CHARCODE","UP_ARROW_CHARCODE","RIGHT_ARROW_CHARCODE","DOWN_ARROW_CHARCODE","DELETE_CHARCODE","UNIDENTIFIED_CODE","dataProvider","pickerOptions","isPendingInputEventHandling","onInitalize","htmlNode","wordToReplace","getWord","lastKnownRange","setIsSuggesting","handleAutoComplete","isSuggesting","onDispose","onContentChanged","elementIdPrefix","eventHandledOnKeyDown","isAndroidKeyboardEvent","currentInputLength","calcInputLength","onKeyDownEvent","onAndroidInputEvent","shouldHandleKeyUpEvent","onKeyUpDomEvent","setLastKnownRange","onIsSuggestingChanged","setAriaOwns","setAriaActiveDescendant","cancelDefaultKeyDownEvent","stopImmediatePropagation","getIdValue","getNamedItem","getWordBeforeCursor","replacementNode","getRangeUntilAt","startPos","endPos","hasMatched","isModifierKey","trimmedWordBeforeCursor","wordBeforeCursorWithoutTriggerChar","wordBeforeCursor","queryStringUpdated","blockSuggestions","setCursorPoint","rangeNode","nodeBeforeCursor","setRangeStart","nodeBeforeNodeBeforeCursor","detach","targetPoint","bufferZone","shiftHighlight","isHorizontal","getSelectedIndex","selectOption","tryRemoveNode","nodeAfterCursor","nodeId","onRemove","newInputLength","inputType","wordBeforCursor","getInlineElementBeforeCursor","inlineElementBefore","inlineElementAfter","wordFromRange","wordFromCache","nodeOffset","suggestionsLabel","selectedIndex","suggestionLabelPrefix","charCode","tableRectMap","resizingState","insertingState","onMouseMove","cacheRects","setCurrentTable","tdRect","normalizeRect","setCurrentTd","setCurrentInsertTd","insertTd","currentInsertTd","startHorizontalResizeTable","startResizeTable","startVerticalResizeTable","frameAnimateResizeTable","resizeTable","currentTd","endResizeTable","setupResizerContainer","onMouseMoveDisposer","destoryRectMap","removeResizerContainer","resizerContainer","tableRect","inserter","createInserter","inserterBackgroundColor","HORIZONTAL_INSERTER_HTML","VERTICAL_INSERTER_HTML","horizontalResizer","verticalResizer","createResizer","horizontal","watermark","showHideWatermark","watermarks","isShowing","removeWatermark","insertEntity","spellcheck"],"mappings":"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","file":"rooster-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 82);\n","export { default as getBlockElementAtNode } from './blockElements/getBlockElementAtNode';\r\nexport { default as getFirstLastBlockElement } from './blockElements/getFirstLastBlockElement';\r\n\r\nexport { default as ContentTraverser } from './contentTraverser/ContentTraverser';\r\nexport { default as PositionContentSearcher } from './contentTraverser/PositionContentSearcher';\r\n\r\nexport { default as getInlineElementAtNode } from './inlineElements/getInlineElementAtNode';\r\nexport { default as ImageInlineElement } from './inlineElements/ImageInlineElement';\r\nexport { default as LinkInlineElement } from './inlineElements/LinkInlineElement';\r\nexport { default as NodeInlineElement } from './inlineElements/NodeInlineElement';\r\nexport { default as PartialInlineElement } from './inlineElements/PartialInlineElement';\r\n\r\nexport { default as arrayPush } from './utils/arrayPush';\r\nexport { default as applyTextStyle } from './utils/applyTextStyle';\r\nexport { Browser, getBrowserInfo } from './utils/Browser';\r\nexport { default as applyFormat } from './utils/applyFormat';\r\nexport { default as changeElementTag } from './utils/changeElementTag';\r\nexport { default as collapseNodes } from './utils/collapseNodes';\r\nexport { default as contains } from './utils/contains';\r\nexport { default as extractClipboardEvent } from './utils/extractClipboardEvent';\r\nexport { default as findClosestElementAncestor } from './utils/findClosestElementAncestor';\r\nexport { default as fromHtml } from './utils/fromHtml';\r\nexport { default as getComputedStyles, getComputedStyle } from './utils/getComputedStyles';\r\nexport {\r\n    default as getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from './utils/getPendableFormatState';\r\nexport { default as getTagOfNode } from './utils/getTagOfNode';\r\nexport { default as isBlockElement } from './utils/isBlockElement';\r\nexport { default as isNodeEmpty } from './utils/isNodeEmpty';\r\nexport { default as isVoidHtmlElement } from './utils/isVoidHtmlElement';\r\nexport { default as matchLink } from './utils/matchLink';\r\nexport { default as queryElements } from './utils/queryElements';\r\nexport { default as splitParentNode, splitBalancedNodeRange } from './utils/splitParentNode';\r\nexport { default as unwrap } from './utils/unwrap';\r\nexport { default as wrap } from './utils/wrap';\r\nexport { getNextLeafSibling, getPreviousLeafSibling } from './utils/getLeafSibling';\r\nexport { getFirstLeafNode, getLastLeafNode } from './utils/getLeafNode';\r\nexport { default as getTextContent } from './utils/getTextContent';\r\nexport { default as splitTextNode } from './utils/splitTextNode';\r\nexport { default as normalizeRect } from './utils/normalizeRect';\r\nexport { default as toArray } from './utils/toArray';\r\nexport { default as safeInstanceOf } from './utils/safeInstanceOf';\r\nexport { default as readFile } from './utils/readFile';\r\n\r\nexport { default as VTable } from './table/VTable';\r\nexport { default as VList } from './list/VList';\r\nexport { default as createVListFromRegion } from './list/createVListFromRegion';\r\nexport { default as VListChain } from './list/VListChain';\r\n\r\nexport { default as getRegionsFromRange } from './region/getRegionsFromRange';\r\nexport { default as getSelectedBlockElementsInRegion } from './region/getSelectedBlockElementsInRegion';\r\nexport { default as collapseNodesInRegion } from './region/collapseNodesInRegion';\r\nexport { default as isNodeInRegion } from './region/isNodeInRegion';\r\nexport { default as getSelectionRangeInRegion } from './region/getSelectionRangeInRegion';\r\nexport { default as mergeBlocksInRegion } from './region/mergeBlocksInRegion';\r\n\r\nexport { default as Position } from './selection/Position';\r\nexport { default as createRange } from './selection/createRange';\r\nexport { default as getPositionRect } from './selection/getPositionRect';\r\nexport { default as isPositionAtBeginningOf } from './selection/isPositionAtBeginningOf';\r\nexport { default as getSelectionPath } from './selection/getSelectionPath';\r\nexport { default as getHtmlWithSelectionPath } from './selection/getHtmlWithSelectionPath';\r\nexport { default as setHtmlWithSelectionPath } from './selection/setHtmlWithSelectionPath';\r\nexport { default as addRangeToSelection } from './selection/addRangeToSelection';\r\nexport { default as deleteSelectedContent } from './selection/deleteSelectedContent';\r\n\r\nexport { default as addSnapshot } from './snapshots/addSnapshot';\r\nexport { default as canMoveCurrentSnapshot } from './snapshots/canMoveCurrentSnapshot';\r\nexport { default as clearProceedingSnapshots } from './snapshots/clearProceedingSnapshots';\r\nexport { default as moveCurrentSnapsnot } from './snapshots/moveCurrentSnapsnot';\r\nexport { default as createSnapshots } from './snapshots/createSnapshots';\r\nexport { default as canUndoAutoComplete } from './snapshots/canUndoAutoComplete';\r\n\r\nexport { default as HtmlSanitizer } from './htmlSanitizer/HtmlSanitizer';\r\nexport { default as getInheritableStyles } from './htmlSanitizer/getInheritableStyles';\r\nexport { default as createDefaultHtmlSanitizerOptions } from './htmlSanitizer/createDefaultHtmlSanitizerOptions';\r\nexport { default as chainSanitizerCallback } from './htmlSanitizer/chainSanitizerCallback';\r\n\r\nexport { default as commitEntity } from './entity/commitEntity';\r\nexport { default as getEntityFromElement } from './entity/getEntityFromElement';\r\nexport { default as getEntitySelector } from './entity/getEntitySelector';\r\n\r\nexport { default as cacheGetEventData } from './event/cacheGetEventData';\r\nexport { default as clearEventDataCache } from './event/clearEventDataCache';\r\nexport { default as isModifierKey } from './event/isModifierKey';\r\nexport { default as isCharacterValue } from './event/isCharacterValue';\r\nexport { default as isCtrlOrMetaPressed } from './event/isCtrlOrMetaPressed';\r\n\r\nexport { default as getStyles } from './style/getStyles';\r\nexport { default as setStyles } from './style/setStyles';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the html tag of a node, or empty if it is not an element\r\n * @param node The node to get tag of\r\n * @returns Tag name in upper case if the given node is an Element, or empty string otherwise\r\n */\r\nexport default function getTagOfNode(node: Node): string {\r\n    return node && node.nodeType == NodeType.Element ? (<Element>node).tagName.toUpperCase() : '';\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Test if a node contains another node\r\n * @param container The container node\r\n * @param contained The node to check if it is inside container\r\n * @param treatSameNodeAsContain When container and contained are the same node,\r\n * return true if this param is set to true, otherwise return false. Default value is false\r\n * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.\r\n * Otherwise false.\r\n */\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean;\r\n\r\n/**\r\n * Test if a node contains a given range\r\n * @param container The container node\r\n * @param contained The range to check if it is inside container\r\n * @returns True if contained is insied container, otherwise false\r\n */\r\nexport default function contains(container: Node, contained: Range): boolean;\r\n\r\nexport default function contains(\r\n    container: Node,\r\n    contained: Node | Range,\r\n    treatSameNodeAsContain?: boolean\r\n): boolean {\r\n    if (!container || !contained) {\r\n        return false;\r\n    }\r\n\r\n    if (treatSameNodeAsContain && container == contained) {\r\n        return true;\r\n    }\r\n\r\n    if (safeInstanceOf(contained, 'Range')) {\r\n        contained = contained && contained.commonAncestorContainer;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (contained && contained.nodeType == NodeType.Text) {\r\n        contained = contained.parentNode;\r\n        treatSameNodeAsContain = true;\r\n    }\r\n\r\n    if (container.nodeType != NodeType.Element && container.nodeType != NodeType.DocumentFragment) {\r\n        return !!treatSameNodeAsContain && container == contained;\r\n    }\r\n\r\n    return (\r\n        !!(treatSameNodeAsContain || container != contained) &&\r\n        internalContains(container, contained)\r\n    );\r\n}\r\n\r\nfunction internalContains(container: Node, contained: Node): boolean {\r\n    if (container.contains) {\r\n        return container.contains(contained);\r\n    } else {\r\n        while (contained) {\r\n            if (contained == container) {\r\n                return true;\r\n            }\r\n\r\n            contained = contained.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a position in DOM tree by the node and its offset index\r\n */\r\nexport default class Position implements NodePosition {\r\n    readonly node: Node;\r\n    readonly element: HTMLElement;\r\n    readonly offset: number;\r\n    readonly isAtEnd: boolean;\r\n\r\n    /**\r\n     * Clone and validate a position from existing position.\r\n     * If the given position has invalid offset, this function will return a corrected value.\r\n     * @param position The original position to clone from\r\n     */\r\n    constructor(position: NodePosition);\r\n\r\n    /**\r\n     * Create a Position from node and an offset number\r\n     * @param node The node of this position\r\n     * @param offset Offset of this position\r\n     * @param isFromEndOfRange Whether this position is created from end of a range. An position\r\n     * created from end of range has different behavior when normalize, it will use the child node\r\n     * before current position if any as a deeper level node and set isAtEnd to true.\r\n     */\r\n    constructor(node: Node, offset: number, isFromEndOfRange?: boolean);\r\n\r\n    /**\r\n     * Create a Position from node and a type of position\r\n     * @param node The node of this position\r\n     * @param positionType Type of the postion, can be Begin, End, Before, After\r\n     */\r\n    constructor(node: Node, positionType: PositionType);\r\n\r\n    constructor(\r\n        nodeOrPosition: Node | NodePosition,\r\n        offsetOrPosType?: number,\r\n        private readonly isFromEndOfRange?: boolean\r\n    ) {\r\n        if ((<NodePosition>nodeOrPosition).node) {\r\n            this.node = (<NodePosition>nodeOrPosition).node;\r\n            offsetOrPosType = (<NodePosition>nodeOrPosition).offset;\r\n        } else {\r\n            this.node = <Node>nodeOrPosition;\r\n        }\r\n\r\n        switch (offsetOrPosType) {\r\n            case PositionType.Before:\r\n                this.offset = getIndexOfNode(this.node);\r\n                this.node = this.node.parentNode;\r\n                this.isAtEnd = false;\r\n                break;\r\n\r\n            case PositionType.After:\r\n                this.offset = getIndexOfNode(this.node) + 1;\r\n                this.isAtEnd = !this.node.nextSibling;\r\n                this.node = this.node.parentNode;\r\n                break;\r\n\r\n            case PositionType.End:\r\n                this.offset = getEndOffset(this.node);\r\n                this.isAtEnd = true;\r\n                break;\r\n\r\n            default:\r\n                let endOffset = getEndOffset(this.node);\r\n                this.offset = Math.max(0, Math.min(<number>offsetOrPosType, endOffset));\r\n                this.isAtEnd = offsetOrPosType > 0 && offsetOrPosType >= endOffset;\r\n                break;\r\n        }\r\n\r\n        this.element = findClosestElementAncestor(this.node);\r\n    }\r\n\r\n    /**\r\n     * Normalize this position to the leaf node, return the normalize result.\r\n     * If current position is already using leaf node, return this position object itself\r\n     */\r\n    normalize(): NodePosition {\r\n        if (this.node.nodeType == NodeType.Text || !this.node.firstChild) {\r\n            return this;\r\n        }\r\n\r\n        let node = this.node;\r\n        let newOffset: number | PositionType.Begin | PositionType.End = this.isAtEnd\r\n            ? PositionType.End\r\n            : this.offset;\r\n        while (node.nodeType == NodeType.Element || node.nodeType == NodeType.DocumentFragment) {\r\n            const nextNode = this.isFromEndOfRange\r\n                ? newOffset == PositionType.End\r\n                    ? node.lastChild\r\n                    : node.childNodes[<number>newOffset - 1]\r\n                : newOffset == PositionType.Begin\r\n                ? node.firstChild\r\n                : newOffset == PositionType.End\r\n                ? node.lastChild\r\n                : node.childNodes[<number>newOffset];\r\n\r\n            if (nextNode) {\r\n                node = nextNode;\r\n                newOffset =\r\n                    this.isAtEnd || this.isFromEndOfRange ? PositionType.End : PositionType.Begin;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return new Position(node, newOffset, this.isFromEndOfRange);\r\n    }\r\n\r\n    /**\r\n     * Check if this position is equal to the given position\r\n     * @param position The position to check\r\n     */\r\n    equalTo(position: NodePosition): boolean {\r\n        return (\r\n            position &&\r\n            (this == position ||\r\n                (this.node == position.node &&\r\n                    this.offset == position.offset &&\r\n                    this.isAtEnd == position.isAtEnd))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if this position is after the given position\r\n     */\r\n    isAfter(position: NodePosition): boolean {\r\n        return this.node == position.node\r\n            ? (this.isAtEnd && !position.isAtEnd) || this.offset > position.offset\r\n            : isNodeAfter(this.node, position.node);\r\n    }\r\n\r\n    /**\r\n     * Move this position with offset, returns a new position with a valid offset in the same node\r\n     * @param offset Offset to move with\r\n     */\r\n    move(offset: number) {\r\n        return new Position(this.node, Math.max(this.offset + offset, 0));\r\n    }\r\n\r\n    /**\r\n     * Get start position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getStart(range: Range) {\r\n        return new Position(range.startContainer, range.startOffset);\r\n    }\r\n\r\n    /**\r\n     * Get end position of the given Range\r\n     * @param range The range to get position from\r\n     */\r\n    static getEnd(range: Range) {\r\n        // For collapsed range, always return the same value of start container to make sure\r\n        // end position is not before start position\r\n        return range.collapsed\r\n            ? Position.getStart(range)\r\n            : new Position(range.endContainer, range.endOffset, true /*isFromEndOfRange*/);\r\n    }\r\n}\r\n\r\nfunction getIndexOfNode(node: Node): number {\r\n    let i = 0;\r\n    while ((node = node.previousSibling)) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\n\r\nfunction getEndOffset(node: Node): number {\r\n    if (node.nodeType == NodeType.Text) {\r\n        return node.nodeValue.length;\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        return node.childNodes.length;\r\n    } else {\r\n        return 1;\r\n    }\r\n}\r\n","import { TargetWindow } from 'roosterjs-editor-types';\r\n\r\n// NOTE: Type TargetWindow is an auto-generated type.\r\n// Run node ./tools/generateTargetWindow.js to generate it.\r\n\r\n/**\r\n * @internal Export for test only\r\n * Try get window from the given node or range\r\n * @param source Source node or range\r\n */\r\nexport function getTargetWindow(source: Node | Range): TargetWindow {\r\n    const node = source && ((<Range>source).commonAncestorContainer || <Node>source);\r\n    const document =\r\n        node &&\r\n        (node.ownerDocument ||\r\n            (Object.prototype.toString.apply(node) == '[object HTMLDocument]'\r\n                ? <Document>node\r\n                : null));\r\n\r\n    // If document exists but document.defaultView doesn't exist, it is a detached object, just use current window instead\r\n    const targetWindow = document && ((document.defaultView || window) as any);\r\n    return targetWindow as TargetWindow;\r\n}\r\n\r\n/**\r\n * Check if the given object is instance of the target type\r\n * @param obj Object to check\r\n * @param typeName Target type name\r\n */\r\nexport default function safeInstanceOf<T extends keyof TargetWindow>(\r\n    obj: any,\r\n    typeName: T\r\n): obj is TargetWindow[T] {\r\n    const targetWindow = getTargetWindow(obj);\r\n    const targetType = targetWindow && (targetWindow[typeName] as any);\r\n    const mainWindow = (window as any) as TargetWindow;\r\n    const mainWindowType = mainWindow && (mainWindow[typeName] as any);\r\n    return (\r\n        (mainWindowType && obj instanceof mainWindowType) ||\r\n        (targetType && obj instanceof targetType)\r\n    );\r\n}\r\n","/**\r\n * Convert a named node map to an array\r\n * @param collection The map to convert\r\n */\r\nexport default function toArray(collection: NamedNodeMap): Attr[];\r\n\r\n/**\r\n * Convert a collection to an array\r\n * @param collection The collection to convert\r\n */\r\nexport default function toArray<T extends Node>(collection: NodeListOf<T>): T[];\r\n\r\n/**\r\n * Convert a collection to an array\r\n * @param collection The collection to convert\r\n */\r\nexport default function toArray<T extends Element>(collection: HTMLCollectionOf<T>): T[];\r\n\r\n/**\r\n * Convert an array to an array.\r\n * This is to satisfy typescript compiler. For some cases the object can be a collection at runtime,\r\n * but the declaration is an array. e.g. ClipboardData.types\r\n * @param array The array to convert\r\n */\r\nexport default function toArray<T>(array: readonly T[]): T[];\r\n\r\nexport default function toArray(collection: any): any[] {\r\n    return [].slice.call(collection);\r\n}\r\n","export { default as changeFontSize, FONT_SIZES } from './format/changeFontSize';\r\nexport { default as clearBlockFormat } from './format/clearBlockFormat';\r\nexport { default as clearFormat } from './format/clearFormat';\r\nexport { default as createLink } from './format/createLink';\r\nexport { default as getFormatState, getElementBasedFormatState } from './format/getFormatState';\r\nexport { default as insertEntity } from './format/insertEntity';\r\nexport { default as insertImage } from './format/insertImage';\r\nexport { default as insertTable } from './table/insertTable';\r\nexport { default as editTable } from './table/editTable';\r\nexport { default as formatTable } from './table/formatTable';\r\nexport { default as removeLink } from './format/removeLink';\r\nexport { default as replaceWithNode } from './format/replaceWithNode';\r\nexport { default as rotateElement } from './format/rotateElement';\r\nexport { default as setAlignment } from './format/setAlignment';\r\nexport { default as setBackgroundColor } from './format/setBackgroundColor';\r\nexport { default as setTextColor } from './format/setTextColor';\r\nexport { default as setDirection } from './format/setDirection';\r\nexport { default as setFontName } from './format/setFontName';\r\nexport { default as setFontSize } from './format/setFontSize';\r\nexport { default as setImageAltText } from './format/setImageAltText';\r\nexport { default as setIndentation } from './format/setIndentation';\r\nexport { default as changeCapitalization } from './format/changeCapitalization';\r\nexport { default as toggleBold } from './format/toggleBold';\r\nexport { default as toggleBullet } from './format/toggleBullet';\r\nexport { default as toggleItalic } from './format/toggleItalic';\r\nexport { default as toggleNumbering } from './format/toggleNumbering';\r\nexport { default as toggleBlockQuote } from './format/toggleBlockQuote';\r\nexport { default as toggleCodeBlock } from './format/toggleCodeBlock';\r\nexport { default as toggleStrikethrough } from './format/toggleStrikethrough';\r\nexport { default as toggleSubscript } from './format/toggleSubscript';\r\nexport { default as toggleSuperscript } from './format/toggleSuperscript';\r\nexport { default as toggleUnderline } from './format/toggleUnderline';\r\nexport { default as toggleHeader } from './format/toggleHeader';\r\n\r\nexport { default as experimentCommitListChains } from './experiment/experimentCommitListChains';\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport NodeBlockElement from './NodeBlockElement';\r\nimport StartEndBlockElement from './StartEndBlockElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This produces a block element from a a node\r\n * It needs to account for various HTML structure. Examples:\r\n * 1) &lt;root&gt;&lt;div&gt;abc&lt;/div&gt;&lt;/root&gt;\r\n *   This is most common the case, user passes in a node pointing to abc, and get back a block representing &lt;div&gt;abc&lt;/div&gt;\r\n * 2) &lt;root&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/root&gt;\r\n *   Common content for empty block, user passes node pointing to &lt;br&gt;, and get back a block representing &lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n * 3) &lt;root&gt;abc&lt;/root&gt;\r\n *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc\r\n *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node\r\n * 4) &lt;root&gt;&lt;div&gt;abc&lt;br&gt;123&lt;/div&gt;&lt;/root&gt;\r\n *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a &lt;BR&gt; to create a link break. There're two blocks:\r\n *   block1: 1) abc&lt;br&gt; block2: 123\r\n * 5) &lt;root&gt;&lt;div&gt;abc&lt;div&gt;123&lt;/div&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) &lt;div&gt;123&lt;/div&gt;\r\n * 6) &lt;root&gt;&lt;div&gt;abc&lt;span&gt;123&lt;br&gt;456&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;\r\n *   This is really tricky. Essentially there is a &lt;BR&gt; in middle of a span breaking the span into two blocks;\r\n *   block1: abc&lt;span&gt;123&lt;br&gt; block2: 456\r\n * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:\r\n * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered\r\n * 2) same for identifying tail\r\n * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node\r\n * @param rootNode Root node of the scope, the block element will be inside of this node\r\n * @param node The node to get BlockElement start from\r\n */\r\nexport default function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement {\r\n    if (!contains(rootNode, node)) {\r\n        return null;\r\n    }\r\n\r\n    // Identify the containing block. This serves as ceiling for traversing down below\r\n    // NOTE: this container block could be just the rootNode,\r\n    // which cannot be used to create block element. We will special case handle it later on\r\n    let containerBlockNode = StartEndBlockElement.getBlockContext(node);\r\n    if (containerBlockNode == node) {\r\n        return new NodeBlockElement(containerBlockNode);\r\n    }\r\n\r\n    // Find the head and leaf node in the block\r\n    let headNode = findHeadTailLeafNode(node, containerBlockNode, false /*isTail*/);\r\n    let tailNode = findHeadTailLeafNode(node, containerBlockNode, true /*isTail*/);\r\n\r\n    // At this point, we have the head and tail of a block, here are some examples and where head and tail point to\r\n    // 1) &lt;root&gt;&lt;div&gt;hello&lt;br&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: &lt;br&gt;\r\n    // 2) &lt;root&gt;&lt;div&gt;hello&lt;span style=\"font-family: Arial\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;/root&gt;, head: hello, tail: world\r\n    // Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block\r\n    // So we shall try to collapse as much as we can to the nearest common ancester\r\n    let nodes = collapseNodes(rootNode, headNode, tailNode, false /*canSplitParent*/);\r\n    headNode = nodes[0];\r\n    tailNode = nodes[nodes.length - 1];\r\n\r\n    if (headNode.parentNode != tailNode.parentNode) {\r\n        // Un-Balanced start and end, create a start-end block\r\n        return new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    } else {\r\n        // Balanced start and end (point to same parent), need to see if further collapsing can be done\r\n        while (!headNode.previousSibling && !tailNode.nextSibling) {\r\n            let parentNode = headNode.parentNode;\r\n            if (parentNode == containerBlockNode) {\r\n                // Has reached the container block\r\n                if (containerBlockNode != rootNode) {\r\n                    // If the container block is not the root, use the container block\r\n                    headNode = tailNode = parentNode;\r\n                }\r\n                break;\r\n            } else if (parentNode != rootNode) {\r\n                // Continue collapsing to parent\r\n                headNode = tailNode = parentNode;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block\r\n        return headNode == tailNode && isBlockElement(headNode)\r\n            ? new NodeBlockElement(headNode as HTMLElement)\r\n            : new StartEndBlockElement(rootNode, headNode, tailNode);\r\n    }\r\n}\r\n\r\n/**\r\n * Given a node and container block, identify the first/last leaf node\r\n * A leaf node is defined as deepest first/last node in a block\r\n * i.e. &lt;div&gt;&lt;span style=\"font-family: Arial\"&gt;abc&lt;/span&gt;&lt;/div&gt;, abc is the head leaf of the block\r\n * Often &lt;br&gt; or a child &lt;div&gt; is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf\r\n * i.e. &lt;div&gt;123&lt;br&gt;abc&lt;/div&gt;, abc is the head of a block because of a previous sibling &lt;br&gt;\r\n * i.e. &lt;div&gt;&lt;div&gt;123&lt;/div&gt;abc&lt;/div&gt;, abc is also the head of a block because of a previous sibling &lt;div&gt;\r\n */\r\nfunction findHeadTailLeafNode(node: Node, containerBlockNode: Node, isTail: boolean): Node {\r\n    let result = node;\r\n\r\n    if (getTagOfNode(result) == 'BR' && isTail) {\r\n        return result;\r\n    }\r\n\r\n    while (result) {\r\n        let sibling = node;\r\n        while (!(sibling = isTail ? node.nextSibling : node.previousSibling)) {\r\n            node = node.parentNode;\r\n            if (node == containerBlockNode) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        while (sibling) {\r\n            if (isBlockElement(sibling)) {\r\n                return result;\r\n            } else if (getTagOfNode(sibling) == 'BR') {\r\n                return isTail ? sibling : result;\r\n            }\r\n\r\n            node = sibling;\r\n            sibling = isTail ? node.firstChild : node.lastChild;\r\n        }\r\n\r\n        result = node;\r\n    }\r\n    return result;\r\n}\r\n","import contains from './contains';\r\nimport getTagOfNode from './getTagOfNode';\r\nimport shouldSkipNode from './shouldSkipNode';\r\n\r\n/**\r\n * This walks forwards/backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param isNext True to get next leaf sibling node, false to get previous leaf sibling node\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n * @param ignoreSpace (Optional) Ignore pure space text node when check if the node should be skipped\r\n */\r\nexport function getLeafSibling(\r\n    rootNode: Node,\r\n    startNode: Node,\r\n    isNext: boolean,\r\n    skipTags?: string[],\r\n    ignoreSpace?: boolean\r\n): Node {\r\n    let result = null;\r\n    let getSibling = isNext\r\n        ? (node: Node) => node.nextSibling\r\n        : (node: Node) => node.previousSibling;\r\n    let getChild = isNext ? (node: Node) => node.firstChild : (node: Node) => node.lastChild;\r\n    if (contains(rootNode, startNode)) {\r\n        let curNode = startNode;\r\n        let shouldContinue = true;\r\n\r\n        while (shouldContinue) {\r\n            // Find next/previous node, starting from next/previous sibling, then one level up to find next/previous sibling from parent\r\n            // till a non-null nextSibling/previousSibling is found or the ceiling is encountered (rootNode)\r\n            let parentNode = curNode.parentNode;\r\n            curNode = getSibling(curNode);\r\n            while (!curNode && parentNode != rootNode) {\r\n                curNode = getSibling(parentNode);\r\n                parentNode = parentNode.parentNode;\r\n            }\r\n\r\n            // Now traverse down to get first/last child\r\n            while (\r\n                curNode &&\r\n                (!skipTags || skipTags.indexOf(getTagOfNode(curNode)) < 0) &&\r\n                getChild(curNode)\r\n            ) {\r\n                curNode = getChild(curNode);\r\n            }\r\n\r\n            // Check special nodes (i.e. node that has a display:none etc.) and continue looping if so\r\n            shouldContinue = curNode && shouldSkipNode(curNode, ignoreSpace);\r\n            if (!shouldContinue) {\r\n                // Found a good leaf node, assign and exit\r\n                result = curNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This walks forwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getNextLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, true /*isNext*/, skipTags);\r\n}\r\n\r\n/**\r\n * This walks backwards DOM tree to get next meaningful node\r\n * @param rootNode Root node to scope the leaf sibling node\r\n * @param startNode current node to get sibling node from\r\n * @param skipTags (Optional) tags that child elements will be skipped\r\n */\r\nexport function getPreviousLeafSibling(rootNode: Node, startNode: Node, skipTags?: string[]): Node {\r\n    return getLeafSibling(rootNode, startNode, false /*isNext*/, skipTags);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, PluginEventType } from 'roosterjs-editor-types';\r\nimport {\r\n    getPendableFormatState,\r\n    PendableFormatCommandMap,\r\n    PendableFormatNames,\r\n} from 'roosterjs-editor-dom';\r\n\r\nlet pendableFormatCommands: string[] = null;\r\n\r\n/**\r\n * @internal\r\n * Execute a document command\r\n * @param editor The editor instance\r\n * @param command The command to execute\r\n * @param addUndoSnapshotWhenCollapsed Optional, set to true to always add undo snapshot even current selection is collapsed.\r\n * Default value is false.\r\n * @param doWorkaroundForList Optional, set to true to do workaround for list in order to keep current format.\r\n * Default value is false.\r\n */\r\nexport default function execCommand(editor: IEditor, command: DocumentCommand) {\r\n    editor.focus();\r\n    let formatter = () => editor.getDocument().execCommand(command, false, null);\r\n\r\n    let range = editor.getSelectionRange();\r\n    if (range && range.collapsed) {\r\n        editor.addUndoSnapshot();\r\n        formatter();\r\n\r\n        if (isPendableFormatCommand(command)) {\r\n            // Trigger PendingFormatStateChanged event since we changed pending format state\r\n            editor.triggerPluginEvent(PluginEventType.PendingFormatStateChanged, {\r\n                formatState: getPendableFormatState(editor.getDocument()),\r\n            });\r\n        }\r\n    } else {\r\n        editor.addUndoSnapshot(formatter, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction isPendableFormatCommand(command: DocumentCommand): boolean {\r\n    if (!pendableFormatCommands) {\r\n        pendableFormatCommands = Object.keys(PendableFormatCommandMap).map(\r\n            key => PendableFormatCommandMap[key as PendableFormatNames]\r\n        );\r\n    }\r\n    return pendableFormatCommands.indexOf(command) >= 0;\r\n}\r\n","import isVoidHtmlElement from '../utils/isVoidHtmlElement';\r\nimport Position from './Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create a range around the given node(s)\r\n * @param startNode The start node to create range from\r\n * @param endNode The end node to create range from. If specified, the range will start before startNode and\r\n * end after endNode, otherwise, the range will start before and end after the start node\r\n * @returns A range start before the given node and end after the given node\r\n */\r\nexport default function createRange(startNode: Node, endNode?: Node): Range;\r\n\r\n/**\r\n * Create a collapsed range at the given node and offset\r\n * @param node The container node of the range\r\n * @param offset The offset of the range, can be a number or value of PositionType\r\n * @returns A range at the given node and offset\r\n */\r\nexport default function createRange(node: Node, offset: number | PositionType): Range;\r\n\r\n/**\r\n * Create a range with the given start/end container node and offset\r\n * @param startNode The start container node of the range\r\n * @param startOffset The start offset of the range\r\n * @param endNode The end container node of the range\r\n * @param endOffset The end offset of the range\r\n * @returns A range at the given start/end container node and offset\r\n */\r\nexport default function createRange(\r\n    startNode: Node,\r\n    startOffset: number | PositionType,\r\n    endNode: Node,\r\n    endOffset: number | PositionType\r\n): Range;\r\n\r\n/**\r\n * Create a range under the given rootNode with start and end selection paths\r\n * @param rootNode The root node that the selection paths start from\r\n * @param startPath The selection path of the start position of the range\r\n * @param endPath The selection path of the end position of the range\r\n * @returns A range with the given start and end selection paths\r\n */\r\nexport default function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n\r\n/**\r\n * Create a range with the start and end position\r\n * @param startPosition The start position of the range\r\n * @param endPosition The end position of the range, if not specified, the range will be collapsed at start position\r\n * @returns A range start at startPosition, end at endPosition, or startPosition when endPosition is not specified\r\n */\r\nexport default function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n\r\nexport default function createRange(\r\n    arg1: Node | NodePosition,\r\n    arg2?: number | number[] | Node | NodePosition,\r\n    arg3?: Node | number[],\r\n    arg4?: number\r\n): Range {\r\n    let start: NodePosition;\r\n    let end: NodePosition;\r\n\r\n    if (isNodePosition(arg1)) {\r\n        // function createRange(startPosition: NodePosition, endPosition?: NodePosition): Range;\r\n        start = arg1;\r\n        end = isNodePosition(arg2) ? arg2 : null;\r\n    } else if (safeInstanceOf(arg1, 'Node')) {\r\n        if (Array.isArray(arg2)) {\r\n            // function createRange(rootNode: Node, startPath: number[], endPath?: number[]): Range;\r\n            start = getPositionFromPath(arg1, arg2);\r\n            end = Array.isArray(arg3) ? getPositionFromPath(arg1, arg3) : null;\r\n        } else if (typeof arg2 == 'number') {\r\n            // function createRange(node: Node, offset: number | PositionType): Range;\r\n            // function createRange(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): Range;\r\n            start = new Position(arg1, arg2);\r\n            end = safeInstanceOf(arg3, 'Node') ? new Position(arg3, arg4) : null;\r\n        } else if (safeInstanceOf(arg2, 'Node') || !arg2) {\r\n            // function createRange(startNode: Node, endNode?: Node): Range;\r\n            start = new Position(arg1, PositionType.Before);\r\n            end = new Position(<Node>arg2 || arg1, PositionType.After);\r\n        }\r\n    }\r\n\r\n    if (start && start.node) {\r\n        let range = start.node.ownerDocument.createRange();\r\n        start = getFocusablePosition(start);\r\n        end = getFocusablePosition(end || start);\r\n        range.setStart(start.node, start.offset);\r\n        range.setEnd(end.node, end.offset);\r\n\r\n        return range;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Convert to focusable position\r\n * If current node is a void element, we need to move up one level to put cursor outside void element\r\n */\r\nfunction getFocusablePosition(position: NodePosition) {\r\n    return position.node.nodeType == NodeType.Element && isVoidHtmlElement(position.node)\r\n        ? new Position(position.node, position.isAtEnd ? PositionType.After : PositionType.Before)\r\n        : position;\r\n}\r\n\r\nfunction isNodePosition(arg: any): arg is NodePosition {\r\n    return arg && arg.node;\r\n}\r\n\r\nfunction getPositionFromPath(node: Node, path: number[]): NodePosition {\r\n    if (!node || !path) {\r\n        return null;\r\n    }\r\n\r\n    // Iterate with a for loop to avoid mutating the passed in element path stack\r\n    // or needing to copy it.\r\n    let offset: number;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        offset = path[i];\r\n        if (\r\n            i < path.length - 1 &&\r\n            node &&\r\n            node.nodeType == NodeType.Element &&\r\n            node.childNodes.length > offset\r\n        ) {\r\n            node = node.childNodes[offset];\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return new Position(node, offset);\r\n}\r\n","import { applyTextStyle, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { ChangeSource, IEditor, NodeType, PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\n/**\r\n * @internal\r\n * Apply inline style to current selection\r\n * @param editor The editor instance\r\n * @param callback The callback function to apply style\r\n */\r\nexport default function applyInlineStyle(\r\n    editor: IEditor,\r\n    callback: (element: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    editor.focus();\r\n    let range = editor.getSelectionRange();\r\n\r\n    if (range && range.collapsed) {\r\n        let node = range.startContainer;\r\n        let isEmptySpan =\r\n            getTagOfNode(node) == 'SPAN' &&\r\n            (!node.firstChild ||\r\n                (getTagOfNode(node.firstChild) == 'BR' && !node.firstChild.nextSibling));\r\n        if (isEmptySpan) {\r\n            editor.addUndoSnapshot();\r\n            callback(node as HTMLElement);\r\n        } else {\r\n            let isZWSNode =\r\n                node &&\r\n                node.nodeType == NodeType.Text &&\r\n                node.nodeValue == ZERO_WIDTH_SPACE &&\r\n                getTagOfNode(node.parentNode) == 'SPAN';\r\n\r\n            if (!isZWSNode) {\r\n                editor.addUndoSnapshot();\r\n                // Create a new text node to hold the selection.\r\n                // Some content is needed to position selection into the span\r\n                // for here, we inject ZWS - zero width space\r\n                node = editor.getDocument().createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(node);\r\n            }\r\n\r\n            applyTextStyle(node, callback);\r\n            editor.select(node, PositionType.End);\r\n        }\r\n    } else {\r\n        // This is start and end node that get the style. The start and end needs to be recorded so that selection\r\n        // can be re-applied post-applying style\r\n        editor.addUndoSnapshot(() => {\r\n            let firstNode: Node;\r\n            let lastNode: Node;\r\n            let contentTraverser = editor.getSelectionTraverser();\r\n            let inlineElement = contentTraverser && contentTraverser.currentInlineElement;\r\n            while (inlineElement) {\r\n                let nextInlineElement = contentTraverser.getNextInlineElement();\r\n                inlineElement.applyStyle((element, isInnerNode) => {\r\n                    callback(element, isInnerNode);\r\n                    firstNode = firstNode || element;\r\n                    lastNode = element;\r\n                });\r\n                inlineElement = nextInlineElement;\r\n            }\r\n            if (firstNode && lastNode) {\r\n                editor.select(firstNode, PositionType.Before, lastNode, PositionType.After);\r\n            }\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { DocumentPosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Checks if node1 is after node2\r\n * @param node1 The node to check if it is after another node\r\n * @param node2 The node to check if another node is after this one\r\n * @returns True if node1 is after node2, otherwise false\r\n */\r\nexport default function isNodeAfter(node1: Node, node2: Node): boolean {\r\n    return !!(\r\n        node1 &&\r\n        node2 &&\r\n        (node2.compareDocumentPosition(node1) & DocumentPosition.Following) ==\r\n            DocumentPosition.Following\r\n    );\r\n}\r\n","import fromHtml from './fromHtml';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML tag name\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap<T extends keyof HTMLElementTagNameMap>(\r\n    nodes: Node | Node[],\r\n    wrapper?: T\r\n): HTMLElementTagNameMap[T];\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML string, default value is DIV\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string): HTMLElement;\r\n\r\n/**\r\n * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node\r\n * @param nodes The node or node array to wrap\r\n * @param wrapper The wrapper HTML element, default value is a new DIV element\r\n * @returns The wrapper element\r\n */\r\nexport default function wrap(nodes: Node | Node[], wrapper?: HTMLElement): HTMLElement;\r\n\r\nexport default function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement): HTMLElement {\r\n    nodes = !nodes ? [] : safeInstanceOf(nodes, 'Node') ? [nodes] : nodes;\r\n    if (nodes.length == 0 || !nodes[0]) {\r\n        return null;\r\n    }\r\n\r\n    if (!safeInstanceOf(wrapper, 'HTMLElement')) {\r\n        let document = nodes[0].ownerDocument;\r\n        wrapper = wrapper || 'div';\r\n        wrapper = /^\\w+$/.test(wrapper)\r\n            ? document.createElement(wrapper)\r\n            : (fromHtml(wrapper, document)[0] as HTMLElement);\r\n    }\r\n\r\n    let parentNode = nodes[0].parentNode;\r\n\r\n    if (parentNode) {\r\n        parentNode.insertBefore(wrapper, nodes[0]);\r\n    }\r\n\r\n    for (let node of nodes) {\r\n        wrapper.appendChild(node);\r\n    }\r\n\r\n    return wrapper;\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport ImageInlineElement from './ImageInlineElement';\r\nimport LinkInlineElement from './LinkInlineElement';\r\nimport NodeInlineElement from './NodeInlineElement';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param rootNode The root node of current scope\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(rootNode: Node, node: Node): InlineElement;\r\n\r\n/**\r\n * Get the inline element at a node\r\n * @param parentBlock Parent BlockElement of this node\r\n * @param node The node to get InlineElement from\r\n */\r\nexport default function getInlineElementAtNode(\r\n    parentBlock: BlockElement,\r\n    node: Node\r\n): InlineElement;\r\n\r\nexport default function getInlineElementAtNode(\r\n    parent: Node | BlockElement,\r\n    node: Node\r\n): InlineElement {\r\n    // An inline element has to be in a block element, get the block first and then resolve through the factory\r\n    let parentBlock = safeInstanceOf(parent, 'Node') ? getBlockElementAtNode(parent, node) : parent;\r\n    return node && parentBlock && resolveInlineElement(node, parentBlock);\r\n}\r\n\r\n/**\r\n * Resolve an inline element by a leaf node\r\n * @param node The node to resolve from\r\n * @param parentBlock The parent block element\r\n */\r\nfunction resolveInlineElement(node: Node, parentBlock: BlockElement): InlineElement {\r\n    let nodeChain = [node];\r\n    for (\r\n        let parent = node.parentNode;\r\n        parent && parentBlock.contains(parent);\r\n        parent = parent.parentNode\r\n    ) {\r\n        nodeChain.push(parent);\r\n    }\r\n\r\n    let inlineElement: InlineElement;\r\n\r\n    for (let i = nodeChain.length - 1; i >= 0 && !inlineElement; i--) {\r\n        let currentNode = nodeChain[i];\r\n        let tag = getTagOfNode(currentNode);\r\n        if (tag == 'A') {\r\n            inlineElement = new LinkInlineElement(currentNode, parentBlock);\r\n        } else if (tag == 'IMG') {\r\n            inlineElement = new ImageInlineElement(currentNode, parentBlock);\r\n        }\r\n    }\r\n\r\n    return inlineElement || new NodeInlineElement(node, parentBlock);\r\n}\r\n","import toArray from './toArray';\r\nimport { DocumentPosition, NodeType, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Query HTML elements in the container by a selector string\r\n * @param container Container element to query from\r\n * @param selector Selector string to query\r\n * @param forEachCallback An optional callback to be invoked on each node in query result\r\n * @param scope The scope of the query, default value is QueryScope.Body\r\n * @param range The selection range to query with. This is required when scope is not Body\r\n * @returns HTML Element array of the query result\r\n */\r\nexport default function queryElements(\r\n    container: HTMLElement,\r\n    selector: string,\r\n    forEachCallback?: (node: HTMLElement) => any,\r\n    scope: QueryScope = QueryScope.Body,\r\n    range?: Range\r\n): HTMLElement[] {\r\n    if (!container || !selector) {\r\n        return [];\r\n    }\r\n\r\n    let elements = toArray(container.querySelectorAll<HTMLElement>(selector));\r\n\r\n    if (scope != QueryScope.Body && range) {\r\n        let { startContainer, startOffset, endContainer, endOffset } = range;\r\n        if (startContainer.nodeType == NodeType.Element && startContainer.firstChild) {\r\n            const child = startContainer.childNodes[startOffset];\r\n\r\n            // range.startOffset can give a value of child.length+1 when selection is after the last child\r\n            // In that case we will use the last child instead\r\n            startContainer = child || startContainer.lastChild;\r\n        }\r\n\r\n        endContainer =\r\n            endContainer.nodeType == NodeType.Element && endContainer.firstChild && endOffset > 0\r\n                ? endContainer.childNodes[endOffset - 1]\r\n                : endContainer;\r\n\r\n        elements = elements.filter(element =>\r\n            isIntersectWithNodeRange(\r\n                element,\r\n                startContainer,\r\n                endContainer,\r\n                scope == QueryScope.InSelection\r\n            )\r\n        );\r\n    }\r\n\r\n    if (forEachCallback) {\r\n        elements.forEach(forEachCallback);\r\n    }\r\n    return elements;\r\n}\r\n\r\nfunction isIntersectWithNodeRange(\r\n    node: Node,\r\n    startNode: Node,\r\n    endNode: Node,\r\n    nodeContainedByRangeOnly: boolean\r\n): boolean {\r\n    let startPosition = node.compareDocumentPosition(startNode);\r\n    let endPosition = node.compareDocumentPosition(endNode);\r\n    let targetPositions = [DocumentPosition.Same, DocumentPosition.Contains];\r\n\r\n    if (!nodeContainedByRangeOnly) {\r\n        targetPositions.push(DocumentPosition.ContainedBy);\r\n    }\r\n\r\n    return (\r\n        checkPosition(startPosition, targetPositions) || // intersectStart\r\n        checkPosition(endPosition, targetPositions) || // intersectEnd\r\n        (checkPosition(startPosition, [DocumentPosition.Preceding]) && // Contains\r\n            checkPosition(endPosition, [DocumentPosition.Following]) &&\r\n            !checkPosition(endPosition, [DocumentPosition.ContainedBy]))\r\n    );\r\n}\r\n\r\nfunction checkPosition(position: DocumentPosition, targets: DocumentPosition[]): boolean {\r\n    return targets.some(target =>\r\n        target == DocumentPosition.Same\r\n            ? position == DocumentPosition.Same\r\n            : (position & target) == target\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport splitParentNode from './splitParentNode';\r\nimport toArray from './toArray';\r\n\r\n/**\r\n * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n * split parent nodes if necessary\r\n * @param root The root node of the scope\r\n * @param start The start node\r\n * @param end The end node\r\n * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n * and the returned nodes will be all nodes from start trhough end after splitting\r\n * False to disallow split parent\r\n * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n * otherwise just return start and end\r\n */\r\nexport default function collapseNodes(\r\n    root: Node,\r\n    start: Node,\r\n    end: Node,\r\n    canSplitParent: boolean\r\n): Node[] {\r\n    if (!contains(root, start) || !contains(root, end)) {\r\n        return [];\r\n    }\r\n\r\n    start = collapse(root, start, end, true /*isStart*/, canSplitParent);\r\n    end = collapse(root, end, start, false /*isStart*/, canSplitParent);\r\n\r\n    if (contains(start, end, true /*treateSameNodeAsContain*/)) {\r\n        return [start];\r\n    } else if (contains(end, start)) {\r\n        return [end];\r\n    } else if (start.parentNode == end.parentNode) {\r\n        let nodes: Node[] = toArray(start.parentNode.childNodes);\r\n        let startIndex = nodes.indexOf(start);\r\n        let endIndex = nodes.indexOf(end);\r\n        return nodes.slice(startIndex, endIndex + 1);\r\n    } else {\r\n        return [start, end];\r\n    }\r\n}\r\n\r\n/**\r\n * Collapse a node by traversing its parent nodes until we get the common ancestor node of node and ref node\r\n * @param root Root node, traversing will be limited under this scope\r\n * @param node The node to collapse\r\n * @param ref Ref node. The result will be the nearest common ancestor node of the given node and this ref node\r\n * @param isStart Whether the given node is start of the sequence of nodes to collapse\r\n * @param canSplitParent Whether splitting parent node is allowed\r\n * @returns The common ancestor node of the given node ref node\r\n */\r\nexport function collapse(\r\n    root: Node,\r\n    node: Node,\r\n    ref: Node,\r\n    isStart: boolean,\r\n    canSplitParent: boolean\r\n): Node {\r\n    while (node.parentNode != root && !contains(node.parentNode, ref)) {\r\n        if ((isStart && node.previousSibling) || (!isStart && node.nextSibling)) {\r\n            if (!canSplitParent) {\r\n                break;\r\n            }\r\n            splitParentNode(node, isStart);\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return node;\r\n}\r\n","import isNodeAfter from './isNodeAfter';\r\n\r\n/**\r\n * Split parent node of the given node before/after the given node.\r\n * When a parent node contains [A,B,C] and pass B as the given node,\r\n * If split before, the new nodes will be [A][B,C] and returns [A];\r\n * otherwise, it will be [A,B][C] and returns [C].\r\n * @param node The node to split before/after\r\n * @param splitBefore Whether split before or after\r\n * @param removeEmptyNewNode If the new node is empty (even then only child is space or ZER_WIDTH_SPACE),\r\n * we remove it. @default false\r\n * @returns The new parent node\r\n */\r\nexport default function splitParentNode(node: Node, splitBefore: boolean): Node {\r\n    if (!node || !node.parentNode) {\r\n        return null;\r\n    }\r\n\r\n    let parentNode = node.parentNode;\r\n    let newParent = parentNode.cloneNode(false /*deep*/) as HTMLElement;\r\n    newParent.removeAttribute('id');\r\n    if (splitBefore) {\r\n        while (parentNode.firstChild && parentNode.firstChild != node) {\r\n            newParent.appendChild(parentNode.firstChild);\r\n        }\r\n    } else {\r\n        while (node.nextSibling) {\r\n            newParent.appendChild(node.nextSibling);\r\n        }\r\n    }\r\n\r\n    // When the only child of new parent is ZERO_WIDTH_SPACE, we can still prevent keeping it by set removeEmptyNewNode to true\r\n    if (newParent.firstChild && newParent.innerHTML != '') {\r\n        parentNode.parentNode.insertBefore(\r\n            newParent,\r\n            splitBefore ? parentNode : parentNode.nextSibling\r\n        );\r\n    } else {\r\n        newParent = null;\r\n    }\r\n\r\n    return newParent;\r\n}\r\n\r\n/**\r\n * Split parent node by a balanced node range\r\n * @param nodes The nodes to split from. If only one node is passed, split it from all its siblings.\r\n * If two or nodes are passed, will split before the first one and after the last one, all other nodes will be ignored\r\n * @returns The parent node of the given node range if the given nodes are balanced, otherwise null\r\n */\r\nexport function splitBalancedNodeRange(nodes: Node | Node[]): HTMLElement {\r\n    let start = Array.isArray(nodes) ? nodes[0] : nodes;\r\n    let end = Array.isArray(nodes) ? nodes[nodes.length - 1] : nodes;\r\n    let parentNode = start && end && start.parentNode == end.parentNode ? start.parentNode : null;\r\n    if (parentNode) {\r\n        if (isNodeAfter(start, end)) {\r\n            let temp = end;\r\n            end = start;\r\n            start = temp;\r\n        }\r\n        splitParentNode(start, true /*splitBefore*/);\r\n        splitParentNode(end, false /*splitBefore*/);\r\n    }\r\n\r\n    return parentNode as HTMLElement;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\nconst BLOCK_ELEMENT_TAGS = 'ADDRESS,ARTICLE,ASIDE,BLOCKQUOTE,CANVAS,DD,DIV,DL,DT,FIELDSET,FIGCAPTION,FIGURE,FOOTER,FORM,H1,H2,H3,H4,H5,H6,HEADER,HR,LI,MAIN,NAV,NOSCRIPT,OL,OUTPUT,P,PRE,SECTION,TABLE,TD,TH,TFOOT,UL,VIDEO'.split(\r\n    ','\r\n);\r\nconst BLOCK_DISPLAY_STYLES = ['block', 'list-item', 'table-cell'];\r\n\r\n/**\r\n * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.\r\n * @param node The node to check\r\n * @returns True if the node is a block element, otherwise false\r\n */\r\nexport default function isBlockElement(node: Node): node is HTMLElement {\r\n    let tag = getTagOfNode(node);\r\n    return !!(\r\n        tag &&\r\n        (BLOCK_DISPLAY_STYLES.indexOf((<HTMLElement>node).style.display) >= 0 ||\r\n            BLOCK_ELEMENT_TAGS.indexOf(tag) >= 0)\r\n    );\r\n}\r\n","import contains from './contains';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\ninterface HTMLElementForIE extends HTMLElement {\r\n    msMatchesSelector: (selector: string) => boolean;\r\n}\r\n\r\n/**\r\n * Find closest element ancestor start from the given node which matches the given selector\r\n * @param node Find ancestor start from this node\r\n * @param root Root node where the search should stop at. The return value can never be this node\r\n * @param selector The expected selector. If null, return the first HTML Element found from start node\r\n * @returns An HTML element which matches the given selector. If the given start node matches the selector,\r\n * returns the given node\r\n */\r\nexport default function findClosestElementAncestor(\r\n    node: Node,\r\n    root?: Node,\r\n    selector?: string\r\n): HTMLElement {\r\n    node = !node ? null : node.nodeType == NodeType.Element ? node : node.parentNode;\r\n    let element = node && node.nodeType == NodeType.Element ? <HTMLElement>node : null;\r\n\r\n    if (element && selector) {\r\n        if (element.closest) {\r\n            element = element.closest(selector) as HTMLElement;\r\n        } else {\r\n            while (\r\n                element &&\r\n                element != root &&\r\n                !(element.matches || (<HTMLElementForIE>element).msMatchesSelector).call(\r\n                    element,\r\n                    selector\r\n                )\r\n            ) {\r\n                element = element.parentElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    return !root || contains(root, element) ? element : null;\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { getComputedStyle } from './getComputedStyles';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst CRLF = /^[\\r\\n]+$/gm;\r\nconst CRLFSPACE = /[\\t\\r\\n\\u0020\\u200B]/gm; // We should only find new line, real space or ZeroWidthSpace (TAB, %20, but not &nbsp;)\r\n\r\n/**\r\n * Skip a node when any of following conditions are true\r\n * - it is neither Element nor Text\r\n * - it is a text node but is empty\r\n * - it is a text node but contains just CRLF (noisy text node that often comes in-between elements)\r\n * - has a display:none\r\n * - it is just <div></div>\r\n * @param node The node to check\r\n * @param ignoreSpace (Optional) True to ignore pure space text node of the node when check.\r\n * If the value of a node value is only space, set this to true will treat this node as skippable.\r\n * Default value is false\r\n */\r\nexport default function shouldSkipNode(node: Node, ignoreSpace?: boolean): boolean {\r\n    if (node.nodeType == NodeType.Text) {\r\n        if (!node.nodeValue || node.textContent == '' || CRLF.test(node.nodeValue)) {\r\n            return true;\r\n        } else if (ignoreSpace && node.nodeValue.replace(CRLFSPACE, '') == '') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        if (getComputedStyle(node, 'display') == 'none') {\r\n            return true;\r\n        }\r\n\r\n        const tag = getTagOfNode(node);\r\n\r\n        if (tag == 'DIV' || tag == 'SPAN') {\r\n            // Empty SPAN/DIV or SPAN/DIV with only unmeaningful children is unmeaningful,\r\n            // because it can render nothing. If we keep them here, there may be unexpected\r\n            // LI elements added for those unmeaningful nodes.\r\n            for (let child = node.firstChild; !!child; child = child.nextSibling) {\r\n                if (!shouldSkipNode(child, ignoreSpace)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            // There may still be other cases that the node is not meaningful.\r\n            // We can add those cases here once we hit them.\r\n            return false;\r\n        }\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport { DocumentPosition, RegionBase } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if a given node is contained by the given region\r\n * @param region The region to check from\r\n * @param node The node or block element to check\r\n */\r\nexport default function isNodeInRegion(region: RegionBase, node: Node): boolean {\r\n    return !!(\r\n        region &&\r\n        contains(region.rootNode, node) &&\r\n        (!region.nodeBefore ||\r\n            region.nodeBefore.compareDocumentPosition(node) == DocumentPosition.Following) &&\r\n        (!region.nodeAfter ||\r\n            region.nodeAfter.compareDocumentPosition(node) == DocumentPosition.Preceding)\r\n    );\r\n}\r\n","import toArray from './toArray';\r\n\r\n/**\r\n * Creates an HTML node array from html\r\n * @param html the html string to create HTML elements from\r\n * @param ownerDocument Owner document of the result HTML elements\r\n * @returns An HTML node array to represent the given html string\r\n */\r\nexport default function fromHtml(html: string, ownerDocument: HTMLDocument): Node[] {\r\n    let element = ownerDocument.createElement('DIV');\r\n    element.innerHTML = html;\r\n\r\n    return toArray(element.childNodes);\r\n}\r\n","import BodyScoper from './BodyScoper';\r\nimport EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport SelectionBlockScoper from './SelectionBlockScoper';\r\nimport SelectionScoper from './SelectionScoper';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { getInlineElementBeforeAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport {\r\n    BlockElement,\r\n    ContentPosition,\r\n    IContentTraverser,\r\n    InlineElement,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * The provides traversing of content inside editor.\r\n * There are two ways to traverse, block by block, or inline element by inline element\r\n * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change\r\n * the current inline element position\r\n */\r\nexport default class ContentTraverser implements IContentTraverser {\r\n    private currentInline: InlineElement;\r\n    private currentBlock: BlockElement;\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param scoper Traversing scoper object to help scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    private constructor(private scoper: TraversingScoper, private skipTags?: string[]) {}\r\n\r\n    /**\r\n     * Create a content traverser for the whole body of given root node\r\n     * @param rootNode The root node to traverse in\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBodyTraverser(\r\n        rootNode: Node,\r\n        startNode?: Node,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new BodyScoper(rootNode, startNode));\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for the given selection\r\n     * @param rootNode The root node to traverse in\r\n     * @param range The selection range to scope the traversing\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createSelectionTraverser(\r\n        rootNode: Node,\r\n        range: Range,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionScoper(rootNode, range), skipTags);\r\n    }\r\n\r\n    /**\r\n     * Create a content traverser for a block element which contains the given position\r\n     * @param rootNode The root node to traverse in\r\n     * @param position A position inside a block, traversing will be scoped within this block.\r\n     * If passing a range, the start position of this range will be used\r\n     * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart\r\n     * @param skipTags (Optional) tags that child elements will be skipped\r\n     */\r\n    public static createBlockTraverser(\r\n        rootNode: Node,\r\n        position: NodePosition | Range,\r\n        start: ContentPosition = ContentPosition.SelectionStart,\r\n        skipTags?: string[]\r\n    ): IContentTraverser {\r\n        return new ContentTraverser(new SelectionBlockScoper(rootNode, position, start));\r\n    }\r\n\r\n    /**\r\n     * Get current block\r\n     */\r\n    public get currentBlockElement(): BlockElement {\r\n        // Prepare currentBlock from the scoper\r\n        if (!this.currentBlock) {\r\n            this.currentBlock = this.scoper.getStartBlockElement();\r\n        }\r\n\r\n        return this.currentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get next block element\r\n     */\r\n    public getNextBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous block element\r\n     */\r\n    public getPreviousBlockElement(): BlockElement {\r\n        return this.getPreviousNextBlockElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextBlockElement(isNext: boolean): BlockElement {\r\n        let current = this.currentBlockElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        let leaf = getLeafSibling(\r\n            this.scoper.rootNode,\r\n            isNext ? current.getEndNode() : current.getStartNode(),\r\n            isNext,\r\n            this.skipTags\r\n        );\r\n        let newBlock = leaf ? getBlockElementAtNode(this.scoper.rootNode, leaf) : null;\r\n\r\n        // Make sure this is right block:\r\n        // 1) the block is in scope per scoper\r\n        // 2) the block is after (for next) or before (for previous) the current block\r\n        // Then:\r\n        // 1) Re-position current block to newly found block\r\n        if (\r\n            newBlock &&\r\n            this.scoper.isBlockInScope(newBlock) &&\r\n            ((isNext && newBlock.isAfter(current)) || (!isNext && current.isAfter(newBlock)))\r\n        ) {\r\n            this.currentBlock = newBlock;\r\n            return this.currentBlock;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current inline element getter\r\n     */\r\n    public get currentInlineElement(): InlineElement {\r\n        // Retrieve a start inline from scoper\r\n        if (!this.currentInline) {\r\n            this.currentInline = this.scoper.getStartInlineElement();\r\n        }\r\n\r\n        return this.currentInline instanceof EmptyInlineElement ? null : this.currentInline;\r\n    }\r\n\r\n    /**\r\n     * Get next inline element\r\n     */\r\n    public getNextInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(true /*isNext*/);\r\n    }\r\n\r\n    /**\r\n     * Get previous inline element\r\n     */\r\n    public getPreviousInlineElement(): InlineElement {\r\n        return this.getPreviousNextInlineElement(false /*isNext*/);\r\n    }\r\n\r\n    private getPreviousNextInlineElement(isNext: boolean): InlineElement {\r\n        let current = this.currentInlineElement || this.currentInline;\r\n        let newInline: InlineElement;\r\n\r\n        if (!current) {\r\n            return null;\r\n        }\r\n\r\n        if (current instanceof EmptyInlineElement) {\r\n            newInline = getInlineElementBeforeAfter(\r\n                this.scoper.rootNode,\r\n                current.getStartPosition(),\r\n                isNext\r\n            );\r\n            if (newInline && !current.getParentBlock().contains(newInline.getContainerNode())) {\r\n                newInline = null;\r\n            }\r\n        } else {\r\n            newInline = getNextPreviousInlineElement(this.scoper.rootNode, current, isNext);\r\n            newInline =\r\n                newInline &&\r\n                current &&\r\n                ((isNext && newInline.isAfter(current)) || (!isNext && current.isAfter(newInline)))\r\n                    ? newInline\r\n                    : null;\r\n        }\r\n\r\n        // For inline, we need to make sure:\r\n        // 1) it is really next/previous to current\r\n        // 2) pass on the new inline to this.scoper to do the triming and we still get back an inline\r\n        // Then\r\n        // 1) re-position current inline\r\n        if (newInline && (newInline = this.scoper.trimInlineElement(newInline))) {\r\n            this.currentInline = newInline;\r\n            return this.currentInline;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getNextPreviousInlineElement(\r\n    rootNode: Node,\r\n    current: InlineElement,\r\n    isNext: boolean\r\n): InlineElement {\r\n    if (!current) {\r\n        return null;\r\n    }\r\n    if (current instanceof PartialInlineElement) {\r\n        // if current is partial, get the the othe half of the inline unless it is no more\r\n        let result = isNext ? current.nextInlineElement : current.previousInlineElement;\r\n\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get a leaf node after startNode and use that base to find next inline\r\n    let startNode = current.getContainerNode();\r\n    startNode = getLeafSibling(rootNode, startNode, isNext);\r\n    return getInlineElementAtNode(rootNode, startNode);\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport Position from '../selection/Position';\r\nimport {\r\n    BlockElement,\r\n    InlineElement,\r\n    NodePosition,\r\n    NodeType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This presents an inline element that can be reprented by a single html node.\r\n * This serves as base for most inline element as it contains most implentation\r\n * of all operations that can happen on an inline element. Other sub inline elements mostly\r\n * just identify themself for a certain type\r\n */\r\nexport default class NodeInlineElement implements InlineElement {\r\n    constructor(private containerNode: Node, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * The text content for this inline element\r\n     */\r\n    public getTextContent(): string {\r\n        // nodeValue is better way to retrieve content for a text. Others, just use textContent\r\n        return this.containerNode.nodeType == NodeType.Text\r\n            ? this.containerNode.nodeValue\r\n            : this.containerNode.textContent;\r\n    }\r\n\r\n    /**\r\n     * Get the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.containerNode;\r\n    }\r\n\r\n    // Get the parent block\r\n    public getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of the inline element\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest first child node from the container\r\n        return new Position(this.containerNode, 0).normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the end position of the inline element\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        // For a position, we always want it to point to a leaf node\r\n        // We should try to go get the lowest last child node from the container\r\n        return new Position(this.containerNode, PositionType.End).normalize();\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.containerNode && this.containerNode.nodeType == NodeType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks if an inline element is after the current inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && isNodeAfter(this.containerNode, inlineElement.getContainerNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if the given position is contained in the inline element\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        let start = this.getStartPosition();\r\n        let end = this.getEndPosition();\r\n        return pos && pos.isAfter(start) && end.isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to an inline element\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any): void {\r\n        applyTextStyle(this.containerNode, styler);\r\n    }\r\n}\r\n","import applyTextStyle from '../utils/applyTextStyle';\r\nimport createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { BlockElement, InlineElement, NodePosition, PositionType } from 'roosterjs-editor-types';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\n\r\n/**\r\n * This is a special version of inline element that identifies a section of an inline element\r\n * We often have the need to cut an inline element in half and perform some operation only on half of an inline element\r\n * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element\r\n * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter\r\n * It also offers some special methods that others don't have, i.e. nextInlineElement etc.\r\n */\r\nexport default class PartialInlineElement implements InlineElement {\r\n    constructor(\r\n        private inlineElement: InlineElement,\r\n        private start?: NodePosition,\r\n        private end?: NodePosition\r\n    ) {}\r\n\r\n    /**\r\n     * Get the full inline element that this partial inline decorates\r\n     */\r\n    public getDecoratedInline(): InlineElement {\r\n        return this.inlineElement;\r\n    }\r\n\r\n    /**\r\n     * Gets the container node\r\n     */\r\n    public getContainerNode(): Node {\r\n        return this.inlineElement.getContainerNode();\r\n    }\r\n\r\n    /**\r\n     * Gets the parent block\r\n     */\r\n    public getParentBlock(): BlockElement {\r\n        return this.inlineElement.getParentBlock();\r\n    }\r\n\r\n    /**\r\n     * Gets the text content\r\n     */\r\n    public getTextContent(): string {\r\n        let range = createRange(this.getStartPosition(), this.getEndPosition());\r\n\r\n        return range.toString();\r\n    }\r\n\r\n    /**\r\n     * Get start position of this inline element.\r\n     */\r\n    public getStartPosition(): NodePosition {\r\n        return this.start || this.inlineElement.getStartPosition();\r\n    }\r\n\r\n    /**\r\n     * Get end position of this inline element.\r\n     */\r\n    public getEndPosition(): NodePosition {\r\n        return this.end || this.inlineElement.getEndPosition();\r\n    }\r\n\r\n    /**\r\n     * Get next partial inline element if it is not at the end boundary yet\r\n     */\r\n    public get nextInlineElement(): PartialInlineElement {\r\n        return this.end && new PartialInlineElement(this.inlineElement, this.end, null);\r\n    }\r\n\r\n    /**\r\n     * Get previous partial inline element if it is not at the begin boundary yet\r\n     */\r\n    public get previousInlineElement(): PartialInlineElement {\r\n        return this.start && new PartialInlineElement(this.inlineElement, null, this.start);\r\n    }\r\n\r\n    /**\r\n     * Checks if it contains a position\r\n     */\r\n    public contains(pos: NodePosition): boolean {\r\n        return pos && pos.isAfter(this.getStartPosition()) && this.getEndPosition().isAfter(pos);\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    public isTextualInlineElement(): boolean {\r\n        return this.inlineElement && this.inlineElement.isTextualInlineElement();\r\n    }\r\n\r\n    /**\r\n     * Check if this inline element is after the other inline element\r\n     */\r\n    public isAfter(inlineElement: InlineElement): boolean {\r\n        let thisStart = this.getStartPosition();\r\n        let otherEnd = inlineElement && inlineElement.getEndPosition();\r\n        return otherEnd && (thisStart.isAfter(otherEnd) || thisStart.equalTo(otherEnd));\r\n    }\r\n\r\n    /**\r\n     * apply style\r\n     */\r\n    public applyStyle(styler: (element: HTMLElement, isInnerNode?: boolean) => any) {\r\n        let from = this.getStartPosition().normalize();\r\n        let to = this.getEndPosition().normalize();\r\n        let container = this.getContainerNode();\r\n\r\n        if (from.isAtEnd) {\r\n            let nextNode = getNextLeafSibling(container, from.node);\r\n            from = nextNode ? new Position(nextNode, PositionType.Begin) : null;\r\n        }\r\n        if (to.offset == 0) {\r\n            let previousNode = getPreviousLeafSibling(container, to.node);\r\n            to = previousNode ? new Position(previousNode, PositionType.End) : null;\r\n        }\r\n\r\n        applyTextStyle(container, styler, from, to);\r\n    }\r\n}\r\n","import { BrowserInfo } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get current browser information from user agent string\r\n * @param userAgent The userAgent string of a browser\r\n * @param appVersion The appVersion string of a browser\r\n * @returns The BrowserInfo object calculated from the given userAgent and appVersion\r\n */\r\nexport function getBrowserInfo(userAgent: string, appVersion: string): BrowserInfo {\r\n    // checks whether the browser is running in IE\r\n    // IE11 will use rv in UA instead of MSIE. Unfortunately Firefox also uses this. We should also look for \"Trident\" to confirm this.\r\n    // There have been cases where companies using older version of IE and custom UserAgents have broken this logic (e.g. IE 10 and KellyServices)\r\n    // therefore we should check that the Trident/rv combo is not just from an older IE browser\r\n    let isIE11OrGreater = userAgent.indexOf('rv:') != -1 && userAgent.indexOf('Trident') != -1;\r\n    let isIE = userAgent.indexOf('MSIE') != -1 || isIE11OrGreater;\r\n\r\n    // IE11+ may also have 'Chrome', 'Firefox' and 'Safari' in user agent. But it will have 'trident' as well\r\n    let isChrome = false;\r\n    let isFirefox = false;\r\n    let isSafari = false;\r\n    let isEdge = false;\r\n    let isWebKit = userAgent.indexOf('WebKit') != -1;\r\n\r\n    if (!isIE) {\r\n        isChrome = userAgent.indexOf('Chrome') != -1;\r\n        isFirefox = userAgent.indexOf('Firefox') != -1;\r\n        if (userAgent.indexOf('Safari') != -1) {\r\n            // Android and Chrome have Safari in the user string\r\n            isSafari = userAgent.indexOf('Chrome') == -1 && userAgent.indexOf('Android') == -1;\r\n        }\r\n\r\n        // Sample Edge UA: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10121\r\n        isEdge = userAgent.indexOf('Edge') != -1;\r\n\r\n        // When it is edge, it should not be chrome or firefox. and it is also not webkit\r\n        if (isEdge) {\r\n            isWebKit = isChrome = isFirefox = false;\r\n        }\r\n    }\r\n\r\n    let isMac = appVersion.indexOf('Mac') != -1;\r\n    let isWin = appVersion.indexOf('Win') != -1 || appVersion.indexOf('NT') != -1;\r\n\r\n    return {\r\n        isMac,\r\n        isWin,\r\n        isWebKit,\r\n        isIE,\r\n        isIE11OrGreater,\r\n        isSafari,\r\n        isChrome,\r\n        isFirefox,\r\n        isEdge,\r\n        isIEOrEdge: isIE || isEdge,\r\n    };\r\n}\r\n\r\n/**\r\n * Browser object contains browser and operating system informations of current environment\r\n */\r\nexport const Browser = window\r\n    ? getBrowserInfo(window.navigator.userAgent, window.navigator.appVersion)\r\n    : {};\r\n","import getComputedStyles from './getComputedStyles';\r\nimport getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag<K extends keyof HTMLElementTagNameMap>(\r\n    element: HTMLElement,\r\n    newTag: K\r\n): HTMLElementTagNameMap[K];\r\n\r\n/**\r\n * Change tag of an HTML Element to a new one, and replace it from DOM tree\r\n * @param element The element to change tag\r\n * @param newTag New tag to change to\r\n * @returns The new element with new tag\r\n */\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;\r\n\r\nexport default function changeElementTag(element: HTMLElement, newTag: string): HTMLElement {\r\n    if (!element || !newTag) {\r\n        return null;\r\n    }\r\n\r\n    let newElement = element.ownerDocument.createElement(newTag);\r\n\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n        let attr = element.attributes[i];\r\n        newElement.setAttribute(attr.name, attr.value);\r\n    }\r\n\r\n    while (element.firstChild) {\r\n        newElement.appendChild(element.firstChild);\r\n    }\r\n\r\n    if (getTagOfNode(element) == 'P' || getTagOfNode(newElement) == 'P') {\r\n        [newElement.style.marginTop, newElement.style.marginBottom] = getComputedStyles(element, [\r\n            'margin-top',\r\n            'margin-bottom',\r\n        ]);\r\n    }\r\n\r\n    if (element.parentNode) {\r\n        element.parentNode.replaceChild(newElement, element);\r\n    }\r\n\r\n    return newElement;\r\n}\r\n","import experimentCommitListChains from '../experiment/experimentCommitListChains';\r\nimport { VListChain } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    IEditor,\r\n    NodePosition,\r\n    Region,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Split selection into regions, and perform a block-wise formatting action for each region.\r\n */\r\nexport default function blockFormat(\r\n    editor: IEditor,\r\n    callback: (\r\n        region: Region,\r\n        start: NodePosition,\r\n        end: NodePosition,\r\n        chains: VListChain[]\r\n    ) => void,\r\n    beforeRunCallback?: () => boolean\r\n) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        if (!beforeRunCallback || beforeRunCallback()) {\r\n            const regions = editor.getSelectedRegions();\r\n            const chains = editor.isFeatureEnabled(ExperimentalFeatures.ListChain)\r\n                ? VListChain.createListChains(regions, start?.node)\r\n                : [];\r\n            regions.forEach(region => callback(region, start, end, chains));\r\n            experimentCommitListChains(editor, chains);\r\n        }\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport Position from '../selection/Position';\r\nimport splitTextNode from './splitTextNode';\r\nimport wrap from './wrap';\r\nimport { getNextLeafSibling } from './getLeafSibling';\r\nimport { NodePosition, NodeType, PositionType } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from './splitParentNode';\r\n\r\nconst STYLETAGS = 'SPAN,B,I,U,EM,STRONG,STRIKE,S,SMALL'.split(',');\r\n\r\n/**\r\n * Apply style using a styler function to the given container node in the given range\r\n * @param container The container node to apply style to\r\n * @param styler The styler function\r\n * @param from From position\r\n * @param to To position\r\n */\r\nexport default function applyTextStyle(\r\n    container: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any,\r\n    from: NodePosition = new Position(container, PositionType.Begin).normalize(),\r\n    to: NodePosition = new Position(container, PositionType.End).normalize()\r\n) {\r\n    let formatNodes: Node[] = [];\r\n\r\n    while (from && to && to.isAfter(from)) {\r\n        let formatNode = from.node;\r\n        let parentTag = getTagOfNode(formatNode.parentNode);\r\n\r\n        // The code below modifies DOM. Need to get the next sibling first otherwise you won't be able to reliably get a good next sibling node\r\n        let nextNode = getNextLeafSibling(container, formatNode);\r\n\r\n        if (formatNode.nodeType == NodeType.Text && ['TR', 'TABLE'].indexOf(parentTag) < 0) {\r\n            if (formatNode == to.node && !to.isAtEnd) {\r\n                formatNode = splitTextNode(<Text>formatNode, to.offset, true /*returnFirstPart*/);\r\n            }\r\n\r\n            if (from.offset > 0) {\r\n                formatNode = splitTextNode(\r\n                    <Text>formatNode,\r\n                    from.offset,\r\n                    false /*returnFirstPart*/\r\n                );\r\n            }\r\n\r\n            formatNodes.push(formatNode);\r\n        }\r\n\r\n        from = nextNode && new Position(nextNode, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNodes.length > 0) {\r\n        if (formatNodes.every(node => node.parentNode == formatNodes[0].parentNode)) {\r\n            let newNode = formatNodes.shift();\r\n            formatNodes.forEach(node => {\r\n                newNode.nodeValue += node.nodeValue;\r\n                node.parentNode.removeChild(node);\r\n            });\r\n            formatNodes = [newNode];\r\n        }\r\n\r\n        formatNodes.forEach(node => {\r\n            // When apply style within style tags like B/I/U/..., we split the tag and apply outside them\r\n            // So that the inner style tag such as U, STRIKE can inherit the style we added\r\n            while (\r\n                getTagOfNode(node) != 'SPAN' &&\r\n                STYLETAGS.indexOf(getTagOfNode(node.parentNode)) >= 0\r\n            ) {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (getTagOfNode(node) != 'SPAN') {\r\n                callStylerWithInnerNode(node, styler);\r\n                node = wrap(node, 'SPAN');\r\n            }\r\n            styler(<HTMLElement>node);\r\n        });\r\n    }\r\n}\r\n\r\nfunction callStylerWithInnerNode(\r\n    node: Node,\r\n    styler: (node: HTMLElement, isInnerNode?: boolean) => any\r\n) {\r\n    if (node && node.nodeType == NodeType.Element) {\r\n        styler(node as HTMLElement, true /*isInnerNode*/);\r\n    }\r\n}\r\n","/**\r\n * Split a text node into two parts by an offset number, and return one of them\r\n * @param textNode The text node to split\r\n * @param offset The offset number to split at\r\n * @param returnFirstPart True to return the first part, then the passed in textNode will become the second part.\r\n * Otherwise return the second part, and the passed in textNode will become the first part\r\n */\r\nexport default function splitTextNode(textNode: Text, offset: number, returnFirstPart: boolean) {\r\n    const firstPart = textNode.nodeValue.substr(0, offset);\r\n    const secondPart = textNode.nodeValue.substr(offset);\r\n    const newNode = textNode.ownerDocument.createTextNode(returnFirstPart ? firstPart : secondPart);\r\n    textNode.nodeValue = returnFirstPart ? secondPart : firstPart;\r\n    textNode.parentNode.insertBefore(newNode, returnFirstPart ? textNode : textNode.nextSibling);\r\n    return newNode;\r\n}\r\n","import findClosestElementAncestor from './findClosestElementAncestor';\r\n\r\n/**\r\n * Get computed styles of a node\r\n * @param node The node to get computed styles from\r\n * @param styleNames Names of style to get, can be a single name or an array.\r\n * Default value is font-family, font-size, color, background-color\r\n * @returns An array of the computed styles\r\n */\r\nexport default function getComputedStyles(\r\n    node: Node,\r\n    styleNames: string | string[] = ['font-family', 'font-size', 'color', 'background-color']\r\n): string[] {\r\n    let element = findClosestElementAncestor(node);\r\n    let result: string[] = [];\r\n    styleNames = Array.isArray(styleNames) ? styleNames : [styleNames];\r\n    if (element) {\r\n        let win = element.ownerDocument.defaultView || window;\r\n        let styles = win.getComputedStyle(element);\r\n\r\n        if (styles) {\r\n            for (let style of styleNames) {\r\n                let value = (styles.getPropertyValue(style) || '').toLowerCase();\r\n                value = style == 'font-size' ? px2Pt(value) : value;\r\n                result.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * A shortcut for getComputedStyles() when only one style is to be retrieved\r\n * @param node The node to get style from\r\n * @param styleName The style name\r\n * @returns The style value\r\n */\r\nexport function getComputedStyle(node: Node, styleName: string): string {\r\n    return getComputedStyles(node, styleName)[0] || '';\r\n}\r\n\r\nfunction px2Pt(px: string) {\r\n    if (px && px.indexOf('px') == px.length - 2) {\r\n        // Edge may not handle the floating computing well which causes the calculated value is a little less than actual value\r\n        // So add 0.05 to fix it\r\n        return Math.round(parseFloat(px) * 75 + 0.05) / 100 + 'pt';\r\n    }\r\n    return px;\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport PartialInlineElement from './PartialInlineElement';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { InlineElement, NodePosition, NodeType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get inline element before a position\r\n * This is mostly used when we want to get the inline element before selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement before\r\n */\r\nexport function getInlineElementBefore(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, false /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get inline element after a position\r\n * This is mostly used when we want to get the inline element after selection/cursor\r\n * There is a possible that the cursor is in middle of an inline element (i.e. mid of a text node)\r\n * in this case, we only want to return what is before cursor (a partial of an inline) to indicate\r\n * that we're in middle.\r\n * @param root Root node of current scope, use for create InlineElement\r\n * @param position The position to get InlineElement after\r\n */\r\nexport function getInlineElementAfter(root: Node, position: NodePosition): InlineElement {\r\n    return getInlineElementBeforeAfter(root, position, true /*isAfter*/);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getInlineElementBeforeAfter(root: Node, position: NodePosition, isAfter: boolean) {\r\n    if (!root || !position || !position.node) {\r\n        return null;\r\n    }\r\n\r\n    position = position.normalize();\r\n    let { node, offset, isAtEnd } = position;\r\n    let isPartial = false;\r\n\r\n    if ((!isAfter && offset == 0 && !isAtEnd) || (isAfter && isAtEnd)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    } else if (\r\n        node.nodeType == NodeType.Text &&\r\n        ((!isAfter && !isAtEnd) || (isAfter && offset > 0))\r\n    ) {\r\n        isPartial = true;\r\n    }\r\n\r\n    if (node && shouldSkipNode(node)) {\r\n        node = getLeafSibling(root, node, isAfter);\r\n    }\r\n\r\n    let inlineElement = getInlineElementAtNode(root, node);\r\n\r\n    if (inlineElement && (isPartial || inlineElement.contains(position))) {\r\n        inlineElement = isAfter\r\n            ? new PartialInlineElement(inlineElement, position, null)\r\n            : new PartialInlineElement(inlineElement, null, position);\r\n    }\r\n\r\n    return inlineElement;\r\n}\r\n","/**\r\n * A type-safe wrapper for Array.prototype.push.apply()\r\n * @param mainArray The main array to push items into\r\n * @param itemsArray The items to push to main array\r\n */\r\nexport default function arrayPush<T>(mainArray: T[], itemsArray: T[]) {\r\n    Array.prototype.push.apply(mainArray, itemsArray);\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\nconst VISIBLE_ELEMENT_TAGS = ['IMG'];\r\nconst VISIBLE_CHILD_ELEMENT_SELECTOR = ['TABLE', 'IMG', 'LI'].join(',');\r\nconst ZERO_WIDTH_SPACE = /\\u200b/g;\r\n\r\n/**\r\n * Check if a given node has no visible content\r\n * @param node The node to check\r\n * @param trimContent Whether trim the text content so that spaces will be treated as empty.\r\n * Default value is false\r\n * @returns True if there isn't any visible element inside node, otherwise false\r\n */\r\nexport default function isNodeEmpty(node: Node, trimContent?: boolean) {\r\n    if (!node) {\r\n        return false;\r\n    } else if (node.nodeType == NodeType.Text) {\r\n        return trim(node.nodeValue, trimContent) == '';\r\n    } else if (node.nodeType == NodeType.Element) {\r\n        let element = node as Element;\r\n        let textContent = trim(element.textContent, trimContent);\r\n        if (\r\n            textContent != '' ||\r\n            VISIBLE_ELEMENT_TAGS.indexOf(getTagOfNode(element)) >= 0 ||\r\n            element.querySelectorAll(VISIBLE_CHILD_ELEMENT_SELECTOR)[0]\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction trim(s: string, trim: boolean) {\r\n    s = s.replace(ZERO_WIDTH_SPACE, '');\r\n    return trim ? s.trim() : s;\r\n}\r\n","/**\r\n * Removes the node and keep all children in place, return the parentNode where the children are attached\r\n * @param node the node to remove\r\n */\r\nexport default function unwrap(node: Node): Node {\r\n    // Unwrap requires a parentNode\r\n    let parentNode = node ? node.parentNode : null;\r\n    if (!parentNode) {\r\n        return null;\r\n    }\r\n\r\n    while (node.firstChild) {\r\n        parentNode.insertBefore(node.firstChild, node);\r\n    }\r\n\r\n    parentNode.removeChild(node);\r\n    return parentNode;\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\r\nimport getListTypeFromNode, { isListElement } from './getListTypeFromNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport Position from '../selection/Position';\r\nimport queryElements from '../utils/queryElements';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport splitParentNode from '../utils/splitParentNode';\r\nimport toArray from '../utils/toArray';\r\nimport unwrap from '../utils/unwrap';\r\nimport VListItem from './VListItem';\r\nimport wrap from '../utils/wrap';\r\nimport {\r\n    Indentation,\r\n    ListType,\r\n    NodePosition,\r\n    PositionType,\r\n    NodeType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Represent a bullet or a numbering list\r\n *\r\n * @example\r\n * A VList is a logical representation of list items, it contains an item array with node and list type stack.\r\n * e.g. We have a list like this\r\n * ```html\r\n * <ol>\r\n *   <li>item 1</li>\r\n *   <li>item 2</li>\r\n *   <ul>\r\n *     <li>item 2.1</li>\r\n *     <li>item 2.2</li>\r\n *   <ul>\r\n * </ol>\r\n * ```\r\n *\r\n * A VList of this list will be like this:\r\n * ```javascript\r\n * {\r\n *   rootList: (OL node),\r\n *   items: [{\r\n *       node: (LI node with 'item 1'),\r\n *       listTypes: [null, OL],\r\n *     }, {\r\n *       node: (LI node with 'item 2'),\r\n *       listTypes: [null, OL],\r\n *     }, {\r\n *       node: (LI node with 'item 2.1),\r\n *       listTypes: [null, OL, UL],\r\n *     }, {\r\n *       node: (LI node with 'item 2.2'),\r\n *       listTypes: [null, OL, UL],\r\n *     }\r\n *   ]\r\n * }\r\n * ```\r\n *\r\n * When we want to outdent item 2.1, we just need to remove the last \"UL\" from listTypes of item 2.1, then\r\n * the writeBack() function will handle everything related to DOM change\r\n */\r\nexport default class VList {\r\n    private items: VListItem[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VList class\r\n     * @param rootList The root list element, can be either OL or UL tag\r\n     */\r\n    constructor(private rootList: HTMLOListElement | HTMLUListElement) {\r\n        if (!rootList) {\r\n            throw new Error('rootList must not be null');\r\n        }\r\n\r\n        // Before populate items, we need to normalize the list to make sure it is in a correct format\r\n        // otherwise further action may mass thing up.\r\n        //\r\n        // There are two kinds of normalization to perform.\r\n        // 1. Move nodes directly under OL/UL into a LI node, unless it is an orphan node\r\n        // Please see comment for VListItem.isOrphanItem() for more information about orphan node\r\n        // e.g.:\r\n        // ```HTML\r\n        // <ol>\r\n        //   <li>item 1</li>\r\n        //   <div>item 2</div>\r\n        // </ol>\r\n        // ```\r\n        // After this step, it should become:\r\n        // ```html\r\n        // <ol>\r\n        //   <li>item 1\r\n        //     <div>item 2</div>\r\n        //   <li>\r\n        // </ol>\r\n        // ```\r\n        moveChildNodesToLi(this.rootList);\r\n        queryElements(this.rootList, 'ol,ul', moveChildNodesToLi);\r\n\r\n        // 2. Move LI node embeded into another LI node out to directly under OL/UL node\r\n        // Ideally browser we do this for us automatically when out the HTML into DOM. However after\r\n        // step 1, it is possible that we move some LI node into another one. e.g:\r\n        // ```HTML\r\n        // <ol>\r\n        //   <li>item 1</li>\r\n        //   <div>\r\n        //     item 1.1\r\n        //     <li>item 3</li>\r\n        //   </div>\r\n        // </ol>\r\n        // ```\r\n        // See that the second LI tag is not directly under OL, so after step 1, this will become:\r\n        // ```html\r\n        // <ol>\r\n        //   <li>item 1\r\n        //     <div>\r\n        //       item 1.1\r\n        //       <li>item 2</li>\r\n        //     </div>\r\n        //   <li>\r\n        // </ol>\r\n        // ```\r\n        // Now we have a LI tag embeded into another LI tag. So we need step 2 to move the inner LI tag out to be:\r\n        // ```html\r\n        // <ol>\r\n        //   <li>item1\r\n        //     <div>item 1.1</div>\r\n        //   </li>\r\n        //   <li><div>item2</div></li>\r\n        // </ol>\r\n        // ```\r\n        queryElements(this.rootList, 'li', moveLiToList);\r\n\r\n        this.populateItems(this.rootList);\r\n    }\r\n\r\n    /**\r\n     * Check if this list contains the given node\r\n     * @param node The node to check\r\n     */\r\n    contains(node: Node) {\r\n        // We don't check if the node is contained by this.rootList here, because after some operation,\r\n        // it is possible a node is logically contained by this list but the container list item hasn't\r\n        // been put under this.rootList in DOM tree yet.\r\n        return this.items.some(item => item.contains(node));\r\n    }\r\n\r\n    /**\r\n     * Get list number of the last item in this VList.\r\n     * If there is no order list item, result will be undefined\r\n     */\r\n    getLastItemNumber(): number | undefined {\r\n        const start = getStart(this.rootList);\r\n\r\n        return start === undefined\r\n            ? start\r\n            : start -\r\n                  1 +\r\n                  this.items.filter(\r\n                      item => item.getListType() == ListType.Ordered && item.getLevel() == 1\r\n                  ).length;\r\n    }\r\n\r\n    /**\r\n     * Write the result back into DOM tree\r\n     * After that, this VList becomes unavailable because we set this.rootList to null\r\n     */\r\n    writeBack() {\r\n        if (!this.rootList) {\r\n            throw new Error('rootList must not be null');\r\n        }\r\n\r\n        const doc = this.rootList.ownerDocument;\r\n        const listStack: Node[] = [doc.createDocumentFragment()];\r\n        const placeholder = doc.createTextNode('');\r\n        let start = getStart(this.rootList) || 1;\r\n        let lastList: Node;\r\n\r\n        // Use a placeholder to hold the position since the root list may be moved into document fragment later\r\n        this.rootList.parentNode.replaceChild(placeholder, this.rootList);\r\n\r\n        this.items.forEach(item => {\r\n            item.writeBack(listStack, this.rootList);\r\n            const topList = listStack[1];\r\n\r\n            if (safeInstanceOf(topList, 'HTMLOListElement')) {\r\n                if (lastList != topList) {\r\n                    if (start == 1) {\r\n                        topList.removeAttribute('start');\r\n                    } else {\r\n                        topList.start = start;\r\n                    }\r\n                }\r\n\r\n                if (item.getLevel() == 1) {\r\n                    start++;\r\n                }\r\n            }\r\n\r\n            lastList = topList;\r\n        });\r\n\r\n        // Restore the content to the positioni of placeholder\r\n        placeholder.parentNode.replaceChild(listStack[0], placeholder);\r\n\r\n        // Set rootList to null to avoid this to be called again for the same VList, because\r\n        // after change the rootList may not be available any more (e.g. outdent all items).\r\n        this.rootList = null;\r\n    }\r\n\r\n    /**\r\n     * Set indentation of the given range of this list\r\n     * @param start Start position to operate from\r\n     * @param end End positon to operate to\r\n     * @param indentation Indent or outdent\r\n     */\r\n    setIndentation(start: NodePosition, end: NodePosition, indentation: Indentation) {\r\n        this.findListItems(start, end, item =>\r\n            indentation == Indentation.Decrease ? item.outdent() : item.indent()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Change list type of the given range of this list.\r\n     * If some of the items are not real list item yet, this will make them to be list item with given type\r\n     * If all items in the given range are already in the type to change to, this becomes an outdent operation\r\n     * @param start Start position to operate from\r\n     * @param end End position to operate to\r\n     * @param targetType Target list type\r\n     */\r\n    changeListType(start: NodePosition, end: NodePosition, targetType: ListType) {\r\n        let needChangeType = false;\r\n\r\n        this.findListItems(start, end, item => {\r\n            needChangeType = needChangeType || item.getListType() != targetType;\r\n        });\r\n        this.findListItems(start, end, item =>\r\n            needChangeType ? item.changeListType(targetType) : item.outdent()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a new item to this VList\r\n     * @param node node of the item to append. If it is not wrapped with LI tag, it will be wrapped\r\n     * @param type Type of this list item, can be ListType.None\r\n     */\r\n    appendItem(node: Node, type: ListType) {\r\n        const nodeTag = getTagOfNode(node);\r\n\r\n        // Change DIV tag to SPAN. Otherwise we can create new list item by Enter key in Safari\r\n        if (nodeTag == 'DIV') {\r\n            node = changeElementTag(<HTMLElement>node, 'LI');\r\n        } else if (nodeTag != 'LI') {\r\n            node = wrap(node, 'LI');\r\n        }\r\n\r\n        this.items.push(type == ListType.None ? new VListItem(node) : new VListItem(node, type));\r\n    }\r\n\r\n    /**\r\n     * Merge the given VList into current VList.\r\n     * - All list items will be removed from the given VList and added into this list.\r\n     * - The root node of the given VList will be removed from DOM tree\r\n     * - If there are orphan items in the given VList, they will be merged into the last item\r\n     *   of this list if any.\r\n     * @param list The vList to merge from\r\n     */\r\n    mergeVList(list: VList) {\r\n        if (list && list != this) {\r\n            const originalLength = this.items.length;\r\n            list.items.forEach(item => this.items.push(item));\r\n            list.items.splice(0, list.items.length);\r\n\r\n            this.mergeOrphanNodesAfter(originalLength - 1);\r\n            list.rootList.parentNode?.removeChild(list.rootList);\r\n        }\r\n    }\r\n\r\n    private mergeOrphanNodesAfter(startIndex: number) {\r\n        const item = this.items[startIndex];\r\n\r\n        if (item && !item.isOrphanItem()) {\r\n            for (let i = startIndex + 1; i <= this.items.length; i++) {\r\n                if (!item || !item.canMerge(this.items[i])) {\r\n                    item.mergeItems(this.items.splice(startIndex + 1, i - startIndex - 1));\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private findListItems(\r\n        start: NodePosition,\r\n        end: NodePosition,\r\n        callback?: (item: VListItem) => any\r\n    ): VListItem[] {\r\n        if (this.items.length == 0) {\r\n            return [];\r\n        }\r\n\r\n        const listStartPos = new Position(this.items[0].getNode(), PositionType.Begin);\r\n        const listEndPos = new Position(\r\n            this.items[this.items.length - 1].getNode(),\r\n            PositionType.End\r\n        );\r\n\r\n        let startIndex = listStartPos.isAfter(start) ? 0 : -1;\r\n        let endIndex = this.items.length - (end.isAfter(listEndPos) ? 1 : 0);\r\n\r\n        this.items.forEach((item, index) => {\r\n            startIndex = item.contains(start.node) ? index : startIndex;\r\n            endIndex = item.contains(end.node) ? index : endIndex;\r\n        });\r\n\r\n        startIndex = endIndex < this.items.length ? Math.max(0, startIndex) : startIndex;\r\n        endIndex = startIndex >= 0 ? Math.min(this.items.length - 1, endIndex) : endIndex;\r\n\r\n        const result = startIndex <= endIndex ? this.items.slice(startIndex, endIndex + 1) : [];\r\n\r\n        if (callback) {\r\n            result.forEach(callback);\r\n            this.mergeOrphanNodesAfter(endIndex);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private populateItems(\r\n        list: HTMLOListElement | HTMLUListElement,\r\n        listTypes: (ListType.Ordered | ListType.Unordered)[] = []\r\n    ) {\r\n        const type = getListTypeFromNode(list);\r\n\r\n        for (let item = list.firstChild; !!item; item = item.nextSibling) {\r\n            const newListTypes = [...listTypes, type];\r\n\r\n            if (isListElement(item)) {\r\n                this.populateItems(item as HTMLOListElement | HTMLUListElement, newListTypes);\r\n            } else if (item.nodeType != NodeType.Text || item.nodeValue.trim() != '') {\r\n                this.items.push(new VListItem(item, ...newListTypes));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//Normalization\r\n\r\n// Step 1: Move all non-LI direct children under list into LI\r\n// e.g.\r\n// From: <ul><li>line 1</li>line 2</ul>\r\n// To:   <ul><li>line 1<div>line 2</div></li></ul>\r\nfunction moveChildNodesToLi(list: HTMLOListElement | HTMLUListElement) {\r\n    let currentItem: HTMLLIElement = null;\r\n\r\n    toArray(list.childNodes).forEach(child => {\r\n        if (getTagOfNode(child) == 'LI') {\r\n            currentItem = child as HTMLLIElement;\r\n        } else if (isListElement(child)) {\r\n            currentItem = null;\r\n        } else if (currentItem && !isNodeEmpty(child, true /*trimContent*/)) {\r\n            currentItem.appendChild(isBlockElement(child) ? child : wrap(child));\r\n        }\r\n    });\r\n}\r\n\r\n// Step 2: Move nested LI up to under list directly\r\n// e.g.\r\n// From: <ul><li>line 1<li>line 2</li>line 3</li></ul>\r\n// To:   <ul><li>line 1</li><li>line 2<div>line 3</div></li></ul>\r\nfunction moveLiToList(li: HTMLLIElement) {\r\n    while (!isListElement(li.parentNode)) {\r\n        splitParentNode(li, true /*splitBefore*/);\r\n        let furtherNodes: Node[] = toArray(li.parentNode.childNodes).slice(1);\r\n\r\n        if (furtherNodes.length > 0) {\r\n            if (!isBlockElement(furtherNodes[0])) {\r\n                furtherNodes = [wrap(furtherNodes)];\r\n            }\r\n            furtherNodes.forEach(node => li.appendChild(node));\r\n        }\r\n\r\n        unwrap(li.parentNode);\r\n    }\r\n}\r\n\r\nfunction getStart(list: HTMLOListElement | HTMLUListElement): number | undefined {\r\n    return safeInstanceOf(list, 'HTMLOListElement') ? list.start : undefined;\r\n}\r\n","import getTagOfNode from '../utils/getTagOfNode';\r\nimport { ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get list type from a list element. The result will be either Ordered or Unordered ListType\r\n * @param listElement the element to get list type from\r\n */\r\nexport default function getListTypeFromNode(\r\n    listElement: HTMLOListElement | HTMLUListElement\r\n): ListType.Ordered | ListType.Unordered;\r\n\r\n/**\r\n * Get list type from a DOM node. It is possible to return ListType.None\r\n * @param node the node to get list type from\r\n */\r\nexport default function getListTypeFromNode(node: Node): ListType;\r\n\r\nexport default function getListTypeFromNode(node: Node): ListType {\r\n    switch (getTagOfNode(node)) {\r\n        case 'OL':\r\n            return ListType.Ordered;\r\n        case 'UL':\r\n            return ListType.Unordered;\r\n        default:\r\n            return ListType.None;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * Check if the given DOM node is a list element (OL or UL)\r\n * @param node The node to check\r\n */\r\nexport function isListElement(node: Node): node is HTMLUListElement | HTMLOListElement {\r\n    return getListTypeFromNode(node) != ListType.None;\r\n}\r\n","import createRange from '../selection/createRange';\r\nimport Position from '../selection/Position';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\nimport { Region, RegionBase } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the selection range in the given region.\r\n * The original range can cover multiple regions, this function will narrow the origianl selection\r\n * of a region into current region\r\n * @param regionBase The region to get range from\r\n */\r\nexport default function getSelectionRangeInRegion(regionBase: RegionBase): Range | null {\r\n    if (!regionBase) {\r\n        return null;\r\n    }\r\n\r\n    const { nodeBefore, nodeAfter, rootNode, skipTags } = regionBase;\r\n    const startNode = nodeBefore\r\n        ? getNextLeafSibling(regionBase.rootNode, nodeBefore, regionBase.skipTags)\r\n        : rootNode.firstChild;\r\n    const endNode = nodeAfter\r\n        ? getPreviousLeafSibling(rootNode, nodeAfter, skipTags)\r\n        : rootNode.lastChild;\r\n    const regionRange = startNode && endNode && createRange(startNode, endNode);\r\n\r\n    if (!isRegion(regionBase)) {\r\n        return regionRange;\r\n    } else if (regionRange) {\r\n        const regionStart = Position.getStart(regionRange).normalize();\r\n        const regionEnd = Position.getEnd(regionRange).normalize();\r\n        const { fullSelectionEnd, fullSelectionStart } = regionBase;\r\n\r\n        if (!fullSelectionStart.isAfter(regionEnd) && !regionStart.isAfter(fullSelectionEnd)) {\r\n            const start = fullSelectionStart.isAfter(regionStart)\r\n                ? fullSelectionStart\r\n                : regionStart;\r\n            const end = fullSelectionEnd.isAfter(regionEnd) ? regionEnd : fullSelectionEnd;\r\n\r\n            return createRange(start, end);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nfunction isRegion(regionBase: RegionBase): regionBase is Region {\r\n    const region = regionBase as Region;\r\n    return !!region.fullSelectionEnd && !!region.fullSelectionStart;\r\n}\r\n","/**\r\n * Get CSS styles of a given element in name-value pair format\r\n * @param element The element to get styles from\r\n */\r\nexport default function getStyles(element: HTMLElement): Record<string, string> {\r\n    const result: Record<string, string> = {};\r\n    const style = element?.getAttribute('style') || '';\r\n    style.split(';').forEach(pair => {\r\n        const valueIndex = pair.indexOf(':');\r\n        const name = pair.slice(0, valueIndex);\r\n        const value = pair.slice(valueIndex + 1);\r\n        if (name && value) {\r\n            result[name.trim()] = value.trim();\r\n        }\r\n    });\r\n    return result;\r\n}\r\n","/**\r\n * Set styles to an HTML element. If styles are empty, remove 'style' attribute\r\n * @param element The element to set styles\r\n * @param styles The styles to set, in name-value pair format\r\n */\r\nexport default function setStyles(element: HTMLElement, styles: Record<string, string>) {\r\n    if (element) {\r\n        const style = Object.keys(styles || {})\r\n            .map(name => {\r\n                let value = styles[name];\r\n                name = name ? name.trim() : null;\r\n                value = value ? value.trim() : null;\r\n                return name && value ? `${name}:${value}` : null;\r\n            })\r\n            .filter(x => x)\r\n            .join(';');\r\n        if (style) {\r\n            element.setAttribute('style', style);\r\n        } else {\r\n            element.removeAttribute('style');\r\n        }\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check whether can move current snapshot with the given step\r\n * @param snapshots The snapshots data structure to check\r\n * @param step The step to check, can be positive, negative or 0\r\n * @returns True if can move current snapshot with the given step, otherwise false\r\n */\r\nexport default function canMoveCurrentSnapshot(snapshots: Snapshots, step: number): boolean {\r\n    let newIndex = snapshots.currentIndex + step;\r\n    return newIndex >= 0 && newIndex < snapshots.snapshots.length;\r\n}\r\n","import { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    createRange,\r\n    getSelectionPath,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type ValidProcessListDocumentCommands =\r\n    | DocumentCommand.Outdent\r\n    | DocumentCommand.Indent\r\n    | DocumentCommand.InsertOrderedList\r\n    | DocumentCommand.InsertUnorderedList;\r\n\r\n/**\r\n * @internal\r\n * Browsers don't handle bullet/numbering list well, especially the formats when switching list statue\r\n * So we workaround it by always adding format to list element\r\n */\r\nexport default function processList(\r\n    editor: IEditor,\r\n    command: ValidProcessListDocumentCommands\r\n): Node {\r\n    let existingList = editor.getElementAtCursor('OL,UL');\r\n    if (Browser.isChrome && command !== DocumentCommand.Indent) {\r\n        // Chrome has a bug where certain information about elements are deleted when outdent or enter on empty line occurs.\r\n        // We need to clone our current LI node so we can replace the new LI node with it post outdent / enter.\r\n        const parentLINode = editor.getElementAtCursor('LI');\r\n        // We must first be in an LI node to do something to fix this.\r\n        if (parentLINode) {\r\n            // We also don't want to try to handle the multi select outdent case at this time.\r\n            // These are already pretty stable in Chromium.\r\n            const currentRange = editor.getSelectionRange();\r\n            const currentSelectionPath = getSelectionPath(parentLINode, currentRange);\r\n            if (\r\n                currentRange &&\r\n                (currentRange.collapsed ||\r\n                    (editor.getElementAtCursor('LI', currentRange.startContainer) == parentLINode &&\r\n                        editor.getElementAtCursor('LI', currentRange.endContainer) == parentLINode))\r\n            ) {\r\n                // Handle the case for toggling between the two list types as a special case.\r\n                // We'll let the browser handle this for now.\r\n                if (\r\n                    (existingList.tagName === 'OL' &&\r\n                        command === DocumentCommand.InsertUnorderedList) ||\r\n                    (existingList.tagName === 'UL' && command === DocumentCommand.InsertOrderedList)\r\n                ) {\r\n                    editor.getDocument().execCommand(command, false, null);\r\n                } else {\r\n                    // Get the next highest list element.\r\n                    // In well formed HTML, this should just be the existing list's parent container.\r\n                    const listParent = existingList.parentElement;\r\n                    if (listParent.tagName == 'OL' || listParent.tagName == 'UL') {\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n                        existingList.insertAdjacentElement('afterend', parentLINode);\r\n                        editor.select(\r\n                            createRange(\r\n                                parentLINode,\r\n                                currentSelectionPath.start,\r\n                                currentSelectionPath.end\r\n                            )\r\n                        );\r\n                    } else {\r\n                        // In this case, we're going out to the parent root.\r\n                        if (parentLINode.nextElementSibling) {\r\n                            splitBalancedNodeRange(parentLINode);\r\n                        }\r\n\r\n                        const wrappedContents = wrap(toArray(parentLINode.childNodes));\r\n                        const wrappedRange = createRange(\r\n                            wrappedContents,\r\n                            currentSelectionPath.start,\r\n                            currentSelectionPath.end\r\n                        );\r\n                        const wrappedSelectionPath = getSelectionPath(\r\n                            wrappedContents,\r\n                            wrappedRange\r\n                        );\r\n\r\n                        existingList.insertAdjacentElement('afterend', wrappedContents);\r\n                        editor.deleteNode(parentLINode);\r\n                        let newRange = createRange(\r\n                            wrappedContents,\r\n                            wrappedSelectionPath.start,\r\n                            wrappedSelectionPath.end\r\n                        );\r\n                        editor.select(newRange);\r\n                    }\r\n\r\n                    if (existingList.childElementCount == 0) {\r\n                        editor.deleteNode(existingList);\r\n                    }\r\n                }\r\n            } else {\r\n                editor.getDocument().execCommand(command, false, null);\r\n            }\r\n        } else {\r\n            editor.getDocument().execCommand(command, false, null);\r\n        }\r\n    } else {\r\n        editor.getDocument().execCommand(command, false, null);\r\n    }\r\n    let newList = editor.getElementAtCursor('OL,UL');\r\n    if (newList == existingList) {\r\n        newList = null;\r\n    }\r\n    return newList;\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { createVListFromRegion, getBlockElementAtNode } from 'roosterjs-editor-dom';\r\nimport { IEditor, ListType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default function experimentToggleListType(editor: IEditor, listType: ListType): void;\r\nexport default function experimentToggleListType(\r\n    editor: IEditor,\r\n    listType: ListType.Ordered,\r\n    startNumber: number\r\n): void;\r\n\r\nexport default function experimentToggleListType(\r\n    editor: IEditor,\r\n    listType: ListType,\r\n    startNumber?: number\r\n) {\r\n    blockFormat(editor, (region, start, end, chains) => {\r\n        const chain =\r\n            startNumber > 0 && chains.filter(chain => chain.canAppendAtCursor(startNumber))[0];\r\n        const vList =\r\n            chain && start.equalTo(end)\r\n                ? chain.createVListAtBlock(\r\n                      getBlockElementAtNode(region.rootNode, start.node)?.collapseToSingleElement(),\r\n                      startNumber\r\n                  )\r\n                : createVListFromRegion(region, true /*includeSiblingLists*/);\r\n\r\n        if (vList) {\r\n            vList.changeListType(start, end, listType);\r\n            vList.writeBack();\r\n        }\r\n    });\r\n}\r\n","export * from './plugins/ContentEdit/index';\r\n","import { AutoLinkFeatures } from './features/autoLinkFeatures';\r\nimport { CursorFeatures } from './features/cursorFeatures';\r\nimport { EntityFeatures } from './features/entityFeatures';\r\nimport { ListFeatures } from './features/listFeatures';\r\nimport { MarkdownFeatures } from './features/markdownFeatures';\r\nimport { QuoteFeatures } from './features/quoteFeatures';\r\nimport { ShortcutFeatures } from './features/shortcutFeatures';\r\nimport { StructuredNodeFeatures } from './features/structuredNodeFeatures';\r\nimport { TableFeatures } from './features/tableFeatures';\r\nimport {\r\n    BuildInEditFeature,\r\n    ContentEditFeatureSettings,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst allFeatures = {\r\n    ...ListFeatures,\r\n    ...QuoteFeatures,\r\n    ...TableFeatures,\r\n    ...StructuredNodeFeatures,\r\n    ...AutoLinkFeatures,\r\n    ...ShortcutFeatures,\r\n    ...CursorFeatures,\r\n    ...MarkdownFeatures,\r\n    ...EntityFeatures,\r\n};\r\n\r\n/**\r\n * Get all content edit features provided by roosterjs\r\n */\r\nexport default function getAllFeatures(): Record<\r\n    keyof ContentEditFeatureSettings,\r\n    BuildInEditFeature<PluginEvent>\r\n> {\r\n    return allFeatures;\r\n}\r\n","import contains from '../utils/contains';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * This presents a content block that can be reprented by a single html block type element.\r\n * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.\r\n */\r\nexport default class NodeBlockElement implements BlockElement {\r\n    constructor(private element: HTMLElement) {}\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the start node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Get the end node of the block\r\n     * For NodeBlockElement, start and end essentially refers to same node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.element;\r\n    }\r\n\r\n    /**\r\n     * Checks if it refers to same block\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        // Ideally there is only one unique way to generate a block so we only need to compare the startNode\r\n        return this.element == blockElement.getStartNode();\r\n    }\r\n\r\n    /**\r\n     * Checks if a block is after the current block\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        // if the block's startNode is after current node endEnd, we say it is after\r\n        return isNodeAfter(this.element, blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if a certain html node is within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return contains(this.element, node, true /*treatSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        return this.element ? this.element.textContent : '';\r\n    }\r\n}\r\n","import getTagOfNode from './getTagOfNode';\r\n\r\n/**\r\n * HTML void elements\r\n * Per https://www.w3.org/TR/html/syntax.html#syntax-elements, cannot have child nodes\r\n * This regex is used when we move focus to very begin of editor. We should avoid putting focus inside\r\n * void elements so users don't accidently create child nodes in them\r\n */\r\nconst HTML_VOID_ELEMENTS = 'AREA,BASE,BR,COL,COMMAND,EMBED,HR,IMG,INPUT,KEYGEN,LINK,META,PARAM,SOURCE,TRACK,WBR'.split(\r\n    ','\r\n);\r\n\r\n/**\r\n * Check if the given node is html void element. Void element cannot have childen\r\n * @param node The node to check\r\n */\r\nexport default function isVoidHtmlElement(node: Node): boolean {\r\n    return !!node && HTML_VOID_ELEMENTS.indexOf(getTagOfNode(node)) >= 0;\r\n}\r\n","import getBlockElementAtNode from './getBlockElementAtNode';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get the first/last BlockElement of under the root node.\r\n * If no suitable BlockElement found, returns null\r\n * @param rootNode The root node to get BlockElement from\r\n * @param isFirst True to get first BlockElement, false to get last BlockElement\r\n */\r\nexport default function getFirstLastBlockElement(rootNode: Node, isFirst: boolean): BlockElement {\r\n    let node = rootNode;\r\n    do {\r\n        node = node && (isFirst ? node.firstChild : node.lastChild);\r\n    } while (node && node.firstChild);\r\n    return node && getBlockElementAtNode(rootNode, node);\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is an inline element representing an Html image\r\n */\r\nexport default class ImageInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import NodeInlineElement from './NodeInlineElement';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * This is inline element presenting an html hyperlink\r\n */\r\nexport default class LinkInlineElement extends NodeInlineElement {\r\n    constructor(containerNode: Node, parentBlock: BlockElement) {\r\n        super(containerNode, parentBlock);\r\n    }\r\n}\r\n","import getInlineElementAtNode from './getInlineElementAtNode';\r\nimport { getFirstLeafNode, getLastLeafNode } from '../utils/getLeafNode';\r\nimport { InlineElement } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get the first inline element inside the given node\r\n */\r\nexport function getFirstInlineElement(rootNode: Node): InlineElement {\r\n    // getFirstLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getFirstLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get the last inline element inside the given node\r\n */\r\nexport function getLastInlineElement(rootNode: Node): InlineElement {\r\n    // getLastLeafNode can return null for empty container\r\n    // do check null before passing on to get inline from the node\r\n    let node = getLastLeafNode(rootNode);\r\n    return node ? getInlineElementAtNode(rootNode, node) : null;\r\n}\r\n","import shouldSkipNode from './shouldSkipNode';\r\nimport { getLeafSibling } from './getLeafSibling';\r\n\r\n/**\r\n * Get first/last leaf node of the given root node.\r\n * @param rootNode Root node to get leaf node from\r\n * @param isFirst True to get first leaf node, false to get last leaf node\r\n */\r\nfunction getLeafNode(rootNode: Node, isFirst: boolean): Node {\r\n    let getChild = (node: Node): Node => (isFirst ? node.firstChild : node.lastChild);\r\n    let result = getChild(rootNode);\r\n    while (result && getChild(result)) {\r\n        result = getChild(result);\r\n    }\r\n\r\n    if (result && shouldSkipNode(result)) {\r\n        result = getLeafSibling(rootNode, result, isFirst);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the first meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getFirstLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, true /*isFirst*/);\r\n}\r\n\r\n/**\r\n * Get the last meaningful leaf node\r\n * @param rootNode Root node to get leaf node from\r\n */\r\nexport function getLastLeafNode(rootNode: Node): Node {\r\n    return getLeafNode(rootNode, false /*isFirst*/);\r\n}\r\n","import { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Represents an empty InlineElement.\r\n * This is used for ContentTraverser internally only.\r\n * An empty InlineElement means current position is at the end of a tag so nothing is included inside this element\r\n */\r\nexport default class EmptyInlineElement implements InlineElement {\r\n    constructor(private position: NodePosition, private parentBlock: BlockElement) {}\r\n\r\n    /**\r\n     * Get the text content of this inline element\r\n     */\r\n    getTextContent(): string {\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the container node of this inline element\r\n     */\r\n    getContainerNode(): Node {\r\n        return this.position.node;\r\n    }\r\n\r\n    /**\r\n     * Get the parent block element of this inline element\r\n     */\r\n    getParentBlock(): BlockElement {\r\n        return this.parentBlock;\r\n    }\r\n\r\n    /**\r\n     * Get the start position of this inline element\r\n     */\r\n    getStartPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Get the end position of this inline element\r\n     */\r\n    getEndPosition(): NodePosition {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given inline element is after this inline element\r\n     */\r\n    isAfter(inlineElement: InlineElement): boolean {\r\n        return inlineElement && this.position.isAfter(inlineElement.getEndPosition());\r\n    }\r\n\r\n    /**\r\n     * Checks if this inline element is a textual inline element\r\n     */\r\n    isTextualInlineElement(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given editor position is contained in this inline element\r\n     */\r\n    contains(position: NodePosition): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Apply inline style to a region of an inline element.\r\n     */\r\n    applyStyle(styler: (element: HTMLElement) => any): void {}\r\n}\r\n","import { Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A ClientRect of all 0 is possible. i.e. chrome returns a ClientRect of 0 when the cursor is on an empty p\r\n * We validate that and only return a rect when the passed in ClientRect is valid\r\n */\r\nexport default function normalizeRect(clientRect: ClientRect): Rect {\r\n    let { left, right, top, bottom } =\r\n        clientRect || <ClientRect>{ left: 0, right: 0, top: 0, bottom: 0 };\r\n    return left + right + top + bottom > 0\r\n        ? {\r\n              left: Math.round(left),\r\n              right: Math.round(right),\r\n              top: Math.round(top),\r\n              bottom: Math.round(bottom),\r\n          }\r\n        : null;\r\n}\r\n","import findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport { RegionBase } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * A type map from selector string to HTML element type\r\n */\r\nexport interface SelectorToTypeMap {\r\n    ol: HTMLOListElement;\r\n    ul: HTMLUListElement;\r\n    'ol,ul': HTMLOListElement | HTMLUListElement;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get Root list node from the given node within the given region\r\n * @param region Region to scope the search inot\r\n * @param selector The selector to search\r\n * @param node The start node\r\n */\r\nexport default function getRootListNode<TSelector extends keyof SelectorToTypeMap>(\r\n    region: RegionBase,\r\n    selector: TSelector,\r\n    node: Node\r\n): SelectorToTypeMap[TSelector] {\r\n    let list =\r\n        region &&\r\n        (findClosestElementAncestor(\r\n            node,\r\n            region.rootNode,\r\n            selector\r\n        ) as SelectorToTypeMap[TSelector]);\r\n\r\n    if (list) {\r\n        let ancestor: SelectorToTypeMap[TSelector];\r\n        while (\r\n            (ancestor = findClosestElementAncestor(\r\n                list.parentNode,\r\n                region.rootNode,\r\n                selector\r\n            ) as SelectorToTypeMap[TSelector])\r\n        ) {\r\n            list = ancestor;\r\n        }\r\n    }\r\n\r\n    return list;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\nimport fromHtml from '../utils/fromHtml';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getSelectionRangeInRegion from './getSelectionRangeInRegion';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get all block elements covered by the selection under this region\r\n * @param regionBase The region to get block elements from\r\n * @param createBlockIfEmpty When set to true, a new empty block element will be created if there is not\r\n * any blocks in the region. Default value is false\r\n */\r\nexport default function getSelectedBlockElementsInRegion(\r\n    regionBase: RegionBase,\r\n    createBlockIfEmpty?: boolean\r\n): BlockElement[] {\r\n    const range = getSelectionRangeInRegion(regionBase);\r\n    let blocks: BlockElement[] = [];\r\n\r\n    if (range) {\r\n        const { rootNode, skipTags } = regionBase;\r\n        const traverser = ContentTraverser.createSelectionTraverser(rootNode, range, skipTags);\r\n\r\n        for (\r\n            let block = traverser?.currentBlockElement;\r\n            !!block;\r\n            block = traverser.getNextBlockElement()\r\n        ) {\r\n            blocks.push(block);\r\n        }\r\n\r\n        // Remove unmeaningful nodes\r\n        blocks = blocks.filter(block => {\r\n            const startNode = block.getStartNode();\r\n            const endNode = block.getEndNode();\r\n\r\n            if (startNode == endNode && shouldSkipNode(startNode, true /*ignoreSpace*/)) {\r\n                startNode.parentNode?.removeChild(startNode);\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    if (blocks.length == 0 && regionBase && !regionBase.rootNode.firstChild && createBlockIfEmpty) {\r\n        const newNode = fromHtml('<div><br></div>', regionBase.rootNode.ownerDocument)[0];\r\n        regionBase.rootNode.appendChild(newNode);\r\n        blocks.push(getBlockElementAtNode(regionBase.rootNode, newNode));\r\n    }\r\n\r\n    return blocks;\r\n}\r\n","import contains from '../utils/contains';\r\nimport findClosestElementAncestor from '../utils/findClosestElementAncestor';\r\nimport Position from '../selection/Position';\r\nimport queryElements from '../utils/queryElements';\r\nimport regionTypeData from './regionTypeData';\r\nimport { getNextLeafSibling, getPreviousLeafSibling } from '../utils/getLeafSibling';\r\nimport { QueryScope, Region, RegionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get regions impacted by the given range under the root node\r\n * @param root Root node to get regions from\r\n * @param range A selection range. Regions will be created acording to this range. Each region will be\r\n * fully or partially covered by this range.\r\n * @param type Type of region. Currently we only support TABLE region.\r\n */\r\nexport default function getRegionsFromRange(\r\n    root: HTMLElement,\r\n    range: Range,\r\n    type: RegionType\r\n): Region[] {\r\n    let regions: Region[] = [];\r\n    if (root && range) {\r\n        const { innerSelector, skipTags } = regionTypeData[type];\r\n        const boundaryTree = buildBoundaryTree(root, range, type);\r\n        const start = findClosestElementAncestor(range.startContainer, root, innerSelector) || root;\r\n        const end = findClosestElementAncestor(range.endContainer, root, innerSelector) || root;\r\n        const creator = getRegionCreator(range, skipTags);\r\n        [regions] = iterateNodes(creator, boundaryTree, start, end);\r\n    }\r\n\r\n    return regions.filter(r => !!r);\r\n}\r\n\r\n/**\r\n * @internal export for test only\r\n */\r\nexport function getRegionCreator(\r\n    fullRange: Range,\r\n    skipTags: string[]\r\n): (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region {\r\n    const fullSelectionStart = Position.getStart(fullRange).normalize();\r\n    const fullSelectionEnd = Position.getEnd(fullRange).normalize();\r\n    return (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => {\r\n        return areNodesValid(rootNode, nodeBefore, nodeAfter, skipTags)\r\n            ? {\r\n                  rootNode,\r\n                  nodeBefore,\r\n                  nodeAfter,\r\n                  skipTags,\r\n                  fullSelectionStart,\r\n                  fullSelectionEnd,\r\n              }\r\n            : null;\r\n    };\r\n}\r\n\r\n/**\r\n * This is a internal data structure used for build regions.\r\n * We firstly split the selection by some boundaries, then we can build region from these bundaries.\r\n */\r\ninterface Boundary {\r\n    /**\r\n     * inner node of this boundary\r\n     */\r\n    innerNode: HTMLElement;\r\n\r\n    /**\r\n     * Children of this boundary\r\n     */\r\n    children: {\r\n        /**\r\n         * Outer node of a boundary child\r\n         */\r\n        outerNode: Node;\r\n\r\n        /**\r\n         * Child bundaries\r\n         */\r\n        boundaries: Boundary[];\r\n    }[];\r\n}\r\n\r\n/**\r\n * Step 1: Build boundary tree\r\n * @param root Root node of the whole scope, normally this will be the root of editable scope\r\n * @param range Existing selected full range\r\n * @param type Type of region to create\r\n */\r\nfunction buildBoundaryTree(root: HTMLElement, range: Range, type: RegionType): Boundary {\r\n    const allBoundaries: Boundary[] = [{ innerNode: root, children: [] }];\r\n    const { outerSelector, innerSelector } = regionTypeData[type];\r\n    const inSelectionOuterNode = queryElements(\r\n        root,\r\n        outerSelector,\r\n        null /*callback*/,\r\n        QueryScope.InSelection,\r\n        range\r\n    );\r\n\r\n    // According to https://www.w3.org/TR/selectors-api/#queryselectorall, the result of querySelectorAll\r\n    // is in document order, which is what we expect. So we don't need to sort the result here.\r\n    queryElements(\r\n        root,\r\n        innerSelector,\r\n        thisInnerNode => {\r\n            const thisOuterNode = findClosestElementAncestor(thisInnerNode, root, outerSelector);\r\n            if (thisOuterNode && inSelectionOuterNode.indexOf(thisOuterNode) < 0) {\r\n                const boundary: Boundary = { innerNode: thisInnerNode, children: [] };\r\n\r\n                for (let i = allBoundaries.length - 1; i >= 0; i--) {\r\n                    const { innerNode, children } = allBoundaries[i];\r\n                    if (contains(innerNode, thisOuterNode)) {\r\n                        let child = children.filter(c => c.outerNode == thisOuterNode)[0];\r\n\r\n                        if (!child) {\r\n                            child = { outerNode: thisOuterNode, boundaries: [] };\r\n                            children.push(child);\r\n                        }\r\n\r\n                        child.boundaries.push(boundary);\r\n                        break;\r\n                    }\r\n                }\r\n                allBoundaries.push(boundary);\r\n            }\r\n        },\r\n        QueryScope.OnSelection,\r\n        range\r\n    );\r\n\r\n    return allBoundaries[0];\r\n}\r\n\r\n/**\r\n * Step 2: Recursively iterate all boundaries and create regions\r\n * @param creator A region creator function to help create region\r\n * @param boundary Current root boundary\r\n * @param start A node where full range start from. This may not be the direct node container of range.startContenter.\r\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\r\n * @param end A node where full range end from. This may not be the direct node container of range.endContenter.\r\n * It is the nearest ancestor which satisfies the InnerSelector of the given region type\r\n * @param started Whether we have already hit the start node\r\n */\r\nfunction iterateNodes(\r\n    creator: (rootNode: HTMLElement, nodeBefore?: Node, nodeAfter?: Node) => Region,\r\n    boundary: Boundary,\r\n    start: Node,\r\n    end: Node,\r\n    started?: boolean\r\n): [Region[], boolean, boolean] {\r\n    started = started || boundary.innerNode == start;\r\n    let ended = false;\r\n    const { children, innerNode } = boundary;\r\n    let regions: Region[] = [];\r\n\r\n    if (children.length == 0) {\r\n        regions.push(creator(innerNode));\r\n    } else {\r\n        // Need to run one more time to add region after all children\r\n        for (let i = 0; i <= children.length && !ended; i++) {\r\n            const { outerNode, boundaries } = children[i] || {};\r\n            const previousOuterNode = children[i - 1]?.outerNode;\r\n            if (started) {\r\n                regions.push(creator(innerNode, previousOuterNode, outerNode));\r\n            }\r\n\r\n            boundaries?.forEach(child => {\r\n                let newRegions: Region[];\r\n                [newRegions, started, ended] = iterateNodes(creator, child, start, end, started);\r\n                regions = regions.concat(newRegions);\r\n            });\r\n        }\r\n    }\r\n\r\n    return [regions, started, ended || innerNode == end];\r\n}\r\n\r\n/**\r\n * Check if the given nodes combination is valid to create a region.\r\n * A combination is valid when:\r\n * 1. Root node is not null and is not empty. And\r\n * 2. For nodeBefore and nodeAfter, each of them should be either null or contained by root node. And\r\n * 3. If none of nodeBefore and nodeAfter is null, the should not contain each other, and there should be\r\n * node between them.\r\n * @param root Root node of region\r\n * @param nodeBefore The boundary node before the region under root\r\n * @param nodeAfter The boundary node after the region under root\r\n * @param skipTags Tags to skip\r\n */\r\nfunction areNodesValid(root: Node, nodeBefore: Node, nodeAfter: Node, skipTags: string[]) {\r\n    if (!root) {\r\n        return false;\r\n    } else {\r\n        const firstNodeOfRegion = nodeBefore && getNextLeafSibling(root, nodeBefore, skipTags);\r\n        const lastNodeOfRegion = nodeAfter && getPreviousLeafSibling(root, nodeAfter, skipTags);\r\n        const firstNodeValid =\r\n            !nodeBefore || (contains(root, nodeBefore) && contains(root, firstNodeOfRegion));\r\n        const lastNodeValid =\r\n            !nodeAfter || (contains(root, nodeAfter) && contains(root, lastNodeOfRegion));\r\n        const bothValid =\r\n            !nodeBefore ||\r\n            !nodeAfter ||\r\n            (!contains(nodeBefore, nodeAfter, true /*treatSameAsContain*/) &&\r\n                !contains(nodeBefore, lastNodeOfRegion, true /*treatSameAsContain*/) &&\r\n                !contains(nodeAfter, nodeBefore, true /*treatSameAsContain*/) &&\r\n                !contains(nodeAfter, firstNodeOfRegion, true /*treatSameAsContain*/));\r\n        return firstNodeValid && lastNodeValid && bothValid;\r\n    }\r\n}\r\n","import collapseNode from '../utils/collapseNodes';\r\nimport isNodeInRegion from './isNodeInRegion';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Collapse nodes within this region to their common ascenstor node under this region\r\n * @param region The region to collapse nodes in.\r\n * @param nodesOrBlockElements Nodes or block elements to collapse. When take BlockElement[] as input,\r\n * start node of the first BlockElement and end node of the last BlockElement will be used as the nodes.\r\n * All nodes not contained by the given region will be ignored.\r\n */\r\nexport default function collapseNodesInRegion(\r\n    region: RegionBase,\r\n    nodesOrBlockElements: Node[] | BlockElement[]\r\n): Node[] {\r\n    if (!nodesOrBlockElements || nodesOrBlockElements.length == 0) {\r\n        return [];\r\n    }\r\n\r\n    let nodes = safeInstanceOf(nodesOrBlockElements[0], 'Node')\r\n        ? <Node[]>nodesOrBlockElements\r\n        : [\r\n              nodesOrBlockElements[0].getStartNode(),\r\n              (<BlockElement>nodesOrBlockElements[nodesOrBlockElements.length - 1]).getEndNode(),\r\n          ];\r\n\r\n    nodes = nodes && nodes.filter(node => isNodeInRegion(region, node));\r\n\r\n    const firstNode = nodes[0];\r\n    const lastNode = nodes[nodes.length - 1];\r\n\r\n    if (isNodeInRegion(region, firstNode) && isNodeInRegion(region, lastNode)) {\r\n        return collapseNode(region.rootNode, firstNode, lastNode, true /*canSplitParent*/);\r\n    } else {\r\n        return [];\r\n    }\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\r\nimport contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getPredefinedCssForElement from '../htmlSanitizer/getPredefinedCssForElement';\r\nimport getStyles from '../style/getStyles';\r\nimport isNodeInRegion from '../region/isNodeInRegion';\r\nimport setStyles from '../style/setStyles';\r\nimport { BlockElement, RegionBase } from 'roosterjs-editor-types';\r\nimport { collapse } from '../utils/collapseNodes';\r\nimport { safeInstanceOf } from '..';\r\n\r\n/**\r\n * Merge a BlockElement of given node after another node\r\n * @param region Region to operate in\r\n * @param refNode The node to merge after\r\n * @param targetNode The node of target block element\r\n */\r\nexport default function mergeBlocksInRegion(region: RegionBase, refNode: Node, targetNode: Node) {\r\n    let block: BlockElement;\r\n\r\n    if (\r\n        !isNodeInRegion(region, refNode) ||\r\n        !isNodeInRegion(region, targetNode) ||\r\n        !(block = getBlockElementAtNode(region.rootNode, targetNode)) ||\r\n        block.contains(refNode)\r\n    ) {\r\n        return;\r\n    }\r\n\r\n    const blockRoot = block.collapseToSingleElement();\r\n    const commonContainer = collapse(\r\n        region.rootNode,\r\n        blockRoot,\r\n        refNode,\r\n        false /*isStart*/,\r\n        true /*canSplitParent*/\r\n    );\r\n\r\n    // Copy styles of parent nodes into blockRoot\r\n    for (let node: Node = blockRoot; contains(commonContainer, node); ) {\r\n        const parent = node.parentNode;\r\n        if (safeInstanceOf(parent, 'HTMLElement')) {\r\n            const styles = {\r\n                ...(getPredefinedCssForElement(parent) || {}),\r\n                ...getStyles(parent),\r\n                ...getStyles(blockRoot),\r\n            };\r\n            setStyles(blockRoot, styles);\r\n        }\r\n        node = parent;\r\n    }\r\n\r\n    let nodeToRemove: Node = null;\r\n    let nodeToMerge =\r\n        blockRoot.childNodes.length == 1 && blockRoot.attributes.length == 0\r\n            ? blockRoot.firstChild\r\n            : changeElementTag(blockRoot, 'SPAN');\r\n\r\n    // Remove empty node\r\n    for (\r\n        let node: Node = nodeToMerge;\r\n        contains(commonContainer, node) && node.parentNode.childNodes.length == 1;\r\n        node = node.parentNode\r\n    ) {\r\n        // If the only child is the one which is about to be removed, this node should also be removed\r\n        nodeToRemove = node.parentNode;\r\n    }\r\n\r\n    // Finally, merge blocks, and remove empty nodes\r\n    refNode.parentNode?.insertBefore(nodeToMerge, refNode.nextSibling);\r\n    nodeToRemove?.parentNode?.removeChild(nodeToRemove);\r\n}\r\n","import getTagOfNode from '../utils/getTagOfNode';\r\nimport { PredefinedCssMap, StringMap } from 'roosterjs-editor-types';\r\n\r\nconst PREDEFINED_CSS_FOR_ELEMENT: PredefinedCssMap = {\r\n    B: {\r\n        'font-weight': 'bold',\r\n    },\r\n    EM: {\r\n        'font-style': 'italic',\r\n    },\r\n    I: {\r\n        'font-style': 'italic',\r\n    },\r\n    U: {\r\n        'text-decoration': 'underline',\r\n    },\r\n    P: {\r\n        'margin-top': '1em',\r\n        'margin-bottom': '1em',\r\n    },\r\n    PRE: {\r\n        'white-space': 'pre',\r\n    },\r\n    S: {\r\n        'text-decoration': 'line-through',\r\n    },\r\n    STRIKE: {\r\n        'text-decoration': 'line-through',\r\n    },\r\n    SUB: {\r\n        'vertical-align': 'sub',\r\n        'font-size': 'smaller',\r\n    },\r\n    SUP: {\r\n        'vertical-align': 'super',\r\n        'font-size': 'smaller',\r\n    },\r\n};\r\n\r\n/**\r\n * @internal\r\n * Get a map for browser built-in CSS definations of elements\r\n */\r\nexport default function getPredefinedCssForElement(\r\n    element: HTMLElement,\r\n    additionalPredefinedCssForElement?: PredefinedCssMap\r\n): StringMap {\r\n    const tag = getTagOfNode(element);\r\n    return PREDEFINED_CSS_FOR_ELEMENT[tag] || (additionalPredefinedCssForElement || {})[tag];\r\n}\r\n","import contains from '../utils/contains';\r\nimport Position from './Position';\r\nimport { NodePosition, NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get path of the given selection range related to the given rootNode\r\n * @param rootNode The root node where the path start from\r\n * @param range The range of selection\r\n */\r\nexport default function getSelectionPath(rootNode: HTMLElement, range: Range): SelectionPath {\r\n    if (!range) {\r\n        return null;\r\n    }\r\n\r\n    let selectionPath: SelectionPath = {\r\n        start: getPositionPath(Position.getStart(range), rootNode),\r\n        end: getPositionPath(Position.getEnd(range), rootNode),\r\n    };\r\n\r\n    return selectionPath;\r\n}\r\n\r\n/**\r\n * Get the path of the node relative to rootNode.\r\n * The path of the node is an array of integer indecies into the childNodes of the given node.\r\n *\r\n * The node path will be what the node path will be on a _normalized_ dom\r\n * (e.g. empty text nodes will be ignored and adjacent text nodes will be concatenated)\r\n *\r\n * @param rootNode the node the path will be relative to\r\n * @param position the position to get indexes from. Follows the same semantics\r\n * as selectionRange (if node is of type Text, it is an offset into the text of that node.\r\n * If node is of type Element, it is the index of a child in that Element node.)\r\n */\r\nfunction getPositionPath(position: NodePosition, rootNode: HTMLElement): number[] {\r\n    if (!position || !rootNode) {\r\n        return [];\r\n    }\r\n\r\n    let { node, offset } = position;\r\n    let result: number[] = [];\r\n    let parent: Node;\r\n\r\n    if (!contains(rootNode, node, true)) {\r\n        return [];\r\n    }\r\n\r\n    if (node.nodeType == NodeType.Text) {\r\n        parent = node.parentNode;\r\n        while (node.previousSibling && node.previousSibling.nodeType == NodeType.Text) {\r\n            offset += node.previousSibling.nodeValue.length;\r\n            node = node.previousSibling;\r\n        }\r\n        result.unshift(offset);\r\n    } else {\r\n        parent = node;\r\n        node = node.childNodes[offset];\r\n    }\r\n\r\n    do {\r\n        offset = 0;\r\n        let isPreviousText = false;\r\n\r\n        for (let c: Node = parent.firstChild; c && c != node; c = c.nextSibling) {\r\n            if (c.nodeType == NodeType.Text) {\r\n                if (c.nodeValue.length == 0 || isPreviousText) {\r\n                    continue;\r\n                }\r\n\r\n                isPreviousText = true;\r\n            } else {\r\n                isPreviousText = false;\r\n            }\r\n\r\n            offset++;\r\n        }\r\n\r\n        result.unshift(offset);\r\n        node = parent;\r\n        parent = parent.parentNode;\r\n    } while (node && node != rootNode);\r\n\r\n    return result;\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear all snapshots after the current one\r\n * @param snapshots The snapshots data structure to clear\r\n */\r\nexport default function clearProceedingSnapshots(snapshots: Snapshots) {\r\n    if (canMoveCurrentSnapshot(snapshots, 1)) {\r\n        let removedSize = 0;\r\n        for (let i = snapshots.currentIndex + 1; i < snapshots.snapshots.length; i++) {\r\n            removedSize += snapshots.snapshots[i].length;\r\n        }\r\n        snapshots.snapshots.splice(snapshots.currentIndex + 1);\r\n        snapshots.totalSize -= removedSize;\r\n        snapshots.autoCompleteIndex = -1;\r\n    }\r\n}\r\n","import { StringMap } from 'roosterjs-editor-types';\r\n\r\n// Inheritable CSS properties\r\n// Ref: https://www.w3.org/TR/CSS21/propidx.html\r\nconst INHERITABLE_PROPERTIES = (\r\n    'border-spacing,caption-side,color,' +\r\n    'cursor,direction,empty-cells,font-family,font-size,font-style,font-variant,font-weight,' +\r\n    'font,letter-spacing,line-height,list-style-image,list-style-position,list-style-type,' +\r\n    'list-style,orphans,quotes,text-align,text-indent,text-transform,visibility,white-space,' +\r\n    'widows,word-spacing'\r\n).split(',');\r\n\r\n/**\r\n * Get inheritable CSS style values from the given element\r\n * @param element The element to get style from\r\n */\r\nexport default function getInheritableStyles(element: HTMLElement): StringMap {\r\n    let win = element && element.ownerDocument && element.ownerDocument.defaultView;\r\n    let styles = win && win.getComputedStyle(element);\r\n    let result: StringMap = {};\r\n    INHERITABLE_PROPERTIES.forEach(\r\n        name => (result[name] = (styles && styles.getPropertyValue(name)) || '')\r\n    );\r\n    return result;\r\n}\r\n","function nativeClone<T>(\r\n    source: Record<string, T>,\r\n    existingObj?: Record<string, T>\r\n): Record<string, T> {\r\n    return Object.assign(existingObj || {}, source);\r\n}\r\n\r\nfunction customClone<T>(\r\n    source: Record<string, T>,\r\n    existingObj?: Record<string, T>\r\n): Record<string, T> {\r\n    let result: Record<string, T> = existingObj || {};\r\n    if (source) {\r\n        for (let key of Object.keys(source)) {\r\n            result[key] = source[key];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const cloneObject = Object.assign ? nativeClone : customClone;\r\n","const CTRL_CHARCODE = 'Control';\r\nconst ALT_CHARCODE = 'Alt';\r\nconst META_CHARCODE = 'Meta';\r\n\r\n/**\r\n * Returns true when the event was fired from a modifier key, otherwise false\r\n * @param event The keyboard event object\r\n */\r\nexport default function isModifierKey(event: KeyboardEvent): boolean {\r\n    const isCtrlKey = event.ctrlKey || event.key === CTRL_CHARCODE;\r\n    const isAltKey = event.altKey || event.key === ALT_CHARCODE;\r\n    const isMetaKey = event.metaKey || event.key === META_CHARCODE;\r\n\r\n    return isCtrlKey || isAltKey || isMetaKey;\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\r\nimport { Position, VListChain } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Commit changes of all list changes when experiment features are allowed\r\n * @param editor The Editor object\r\n * @param chains List chains to commit\r\n */\r\nexport default function experimentCommitListChains(editor: IEditor, chains: VListChain[]) {\r\n    if (chains?.length > 0) {\r\n        const range = editor.getSelectionRange();\r\n        const start = range && Position.getStart(range);\r\n        const end = range && Position.getEnd(range);\r\n        chains.forEach(chain => chain.commit());\r\n        editor.select(start, end);\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set background color at current selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n **/\r\nexport default function setBackgroundColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.backgroundColor = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font name at selection\r\n * @param editor The editor instance\r\n * @param fontName The fontName string, should be a valid CSS font-family style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontName(editor: IEditor, fontName: string) {\r\n    fontName = fontName.trim();\r\n    // The browser provided execCommand creates a HTML <font> tag with face attribute. <font> is not HTML5 standard\r\n    // (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-family style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontFamily = isInnerNode ? '' : fontName;\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set font size at selection\r\n * @param editor The editor instance\r\n * @param fontSize The fontSize string, should be a valid CSS font-size style.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n */\r\nexport default function setFontSize(editor: IEditor, fontSize: string) {\r\n    fontSize = fontSize.trim();\r\n    // The browser provided execCommand only accepts 1-7 point value. In addition, it uses HTML <font> tag with size attribute.\r\n    // <font> is not HTML5 standard (http://www.w3schools.com/tags/tag_font.asp). Use applyInlineStyle which gives flexibility on applying inline style\r\n    // for here, we use CSS font-size style\r\n    applyInlineStyle(editor, (element, isInnerNode) => {\r\n        element.style.fontSize = isInnerNode ? '' : fontSize;\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { DarkModeDatasetNames, IEditor, ModeIndependentColor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set text color at selection\r\n * @param editor The editor instance\r\n * @param color One of two options:\r\n * The color string, can be any of the predefined color names (e.g, 'red')\r\n * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.\r\n * Currently there's no validation to the string, if the passed string is invalid, it won't take affect\r\n * Alternatively, you can pass a @typedef ModeIndepenentColor. If in light mode, the lightModeColor property will be used.\r\n * If in dark mode, the darkModeColor will be used and the lightModeColor will be used when converting back to light mode.\r\n */\r\nexport default function setTextColor(editor: IEditor, color: string | ModeIndependentColor) {\r\n    if (typeof color === 'string') {\r\n        const trimmedColor = color.trim();\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : trimmedColor;\r\n        });\r\n    } else {\r\n        const darkMode = editor.isDarkMode();\r\n        const appliedColor = darkMode ? color.darkModeColor : color.lightModeColor;\r\n        applyInlineStyle(editor, (element, isInnerNode) => {\r\n            element.style.color = isInnerNode ? '' : appliedColor;\r\n            if (darkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] = color.lightModeColor;\r\n            }\r\n        });\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bold at selection\r\n * If selection is collapsed, it will only affect the following input after caret\r\n * If selection contains only bold text, the bold style will be removed\r\n * If selection contains only normal text, bold style will be added to the whole selected text\r\n * If selection contains both bold and normal text, bold stle will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBold(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Bold);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle italic at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only italic text, the italic style will be removed\r\n * If selection contains only normal text, italic style will be added to the whole selected text\r\n * If selection contains both italic and normal text, italic stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleItalic(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Italic);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle underline at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only underlined text, the underline style will be removed\r\n * If selection contains only normal text, underline style will be added to the whole selected text\r\n * If selection contains both underlined and normal text, the underline style will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleUnderline(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Underline);\r\n}\r\n","import blockFormat from './blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Toggle a tag at selection, if selection already contains elements of such tag,\r\n * the elements will be untagge and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param wrapFunction  The wrap function\r\n * @param beforeRunCallback A callback function to run before looping all regions. If it returns false,\r\n * the loop for regions will be skipped\r\n */\r\nexport default function blockWrap(\r\n    editor: IEditor,\r\n    wrapFunction: (nodes: Node[]) => void,\r\n    beforeRunCallback: () => boolean\r\n): void {\r\n    blockFormat(\r\n        editor,\r\n        region => {\r\n            const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n            let nodes = collapseNodesInRegion(region, blocks);\r\n            if (nodes.length > 0) {\r\n                if (nodes.length == 1) {\r\n                    const NodeTag = getTagOfNode(nodes[0]);\r\n                    if (NodeTag == 'BR') {\r\n                        nodes = [wrap(nodes[0])];\r\n                    } else if (NodeTag == 'LI' || NodeTag == 'TD') {\r\n                        nodes = toArray(nodes[0].childNodes);\r\n                    }\r\n                }\r\n\r\n                while (\r\n                    nodes[0] &&\r\n                    isNodeInRegion(region, nodes[0].parentNode) &&\r\n                    nodes.some(node => getTagOfNode(node) == 'LI')\r\n                ) {\r\n                    nodes = [splitBalancedNodeRange(nodes)];\r\n                }\r\n\r\n                wrapFunction(nodes);\r\n            }\r\n        },\r\n        beforeRunCallback\r\n    );\r\n}\r\n","// Classes\r\nexport { default as Editor } from './editor/Editor';\r\n","import { contains } from 'roosterjs-editor-dom';\r\nimport { EditorCore, HasFocus } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Check if the editor has focus now\r\n * @param core The EditorCore object\r\n * @returns True if the editor has focus, otherwise false\r\n */\r\nexport const hasFocus: HasFocus = (core: EditorCore) => {\r\n    let activeElement = core.contentDiv.ownerDocument.activeElement;\r\n    return (\r\n        activeElement && contains(core.contentDiv, activeElement, true /*treatSameNodeAsContain*/)\r\n    );\r\n};\r\n","export * from './plugins/HyperLink/index';\r\n","export * from './plugins/Paste/index';\r\n","import { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** NodeId attribute */\r\nconst NODE_ID_ATTRIBUTE_NAME = 'NodeId';\r\n\r\n/**\r\n * @internal\r\n * Custom data for dom elements\r\n */\r\nexport default interface WordCustomData {\r\n    /** The dict storing custom data, key is element Id, value is dictionary */\r\n    dict: { [key: string]: { [key: string]: number } };\r\n\r\n    /** Next node Id to use */\r\n    nextNodeId: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Create an empty WordCustomData\r\n */\r\nexport function createCustomData(): WordCustomData {\r\n    return {\r\n        dict: {},\r\n        nextNodeId: 1,\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * Sets the specified object data\r\n */\r\nexport function setObject(wordCustomData: WordCustomData, element: Node, key: string, value: any) {\r\n    // Get the id for the element\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\r\n        if (id != '') {\r\n            // Get the values for the element\r\n            if (!wordCustomData.dict[id]) {\r\n                // First time dictionary creation\r\n                wordCustomData.dict[id] = {};\r\n            }\r\n            wordCustomData.dict[id][key] = value;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * Reads the specified object data\r\n */\r\nexport function getObject(wordCustomData: WordCustomData, element: Node, key: string): any {\r\n    if (element.nodeType == NodeType.Element) {\r\n        let id = getAndSetNodeId(wordCustomData, element as HTMLElement);\r\n        if (id != '') {\r\n            return wordCustomData.dict[id] && wordCustomData.dict[id][key];\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Get the unique id for the specified node...\r\n */\r\nfunction getAndSetNodeId(wordCustomData: WordCustomData, element: HTMLElement): string {\r\n    let id = element.getAttribute(NODE_ID_ATTRIBUTE_NAME);\r\n    if (!id) {\r\n        id = wordCustomData.nextNodeId.toString();\r\n        wordCustomData.nextNodeId++;\r\n        element.setAttribute(NODE_ID_ATTRIBUTE_NAME, id);\r\n    }\r\n    return id;\r\n}\r\n","import ListMetadata from './ListMetadata';\r\n\r\n/**\r\n * @internal\r\n * Holds the ids for the lists already seen for a specified level\r\n */\r\nexport default interface LevelLists {\r\n    /**\r\n     * The metadata for the lists seen at  this level\r\n     * key: word list id, value: list metadata\r\n     */\r\n    listsMetadata: { [key: string]: ListMetadata };\r\n\r\n    /** Unique id of the list currently at this level */\r\n    currentUniqueListId: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * create an empty LevelLists\r\n */\r\nexport function createLevelLists(): LevelLists {\r\n    return {\r\n        listsMetadata: {},\r\n        currentUniqueListId: -1,\r\n    };\r\n}\r\n","/**\r\n * @internal\r\n */\r\nexport const WORD_ORDERED_LIST_SELECTOR = 'div.ListContainerWrapper > ul[class^=\"BulletListStyle\"]';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const WORD_UNORDERED_LIST_SELECTOR =\r\n    'div.ListContainerWrapper > ol[class^=\"NumberListStyle\"]';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const WORD_ONLINE_IDENTIFYING_SELECTOR = `${WORD_ORDERED_LIST_SELECTOR},${WORD_UNORDERED_LIST_SELECTOR}`;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const LIST_CONTAINER_ELEMENT_CLASS_NAME = 'ListContainerWrapper';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const UNORDERED_LIST_TAG_NAME = 'UL';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const ORDERED_LIST_TAG_NAME = 'OL';\r\n\r\nconst TEXT_CONTAINER_ELEMENT_CLASS_NAME = 'OutlineElement';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const WAC_IDENTIFING_SELECTOR = `ul[class^=\"BulletListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME},ol[class^=\"NumberListStyle\"]>.${TEXT_CONTAINER_ELEMENT_CLASS_NAME}`;\r\n","export { default as createEditor } from './createEditor';\r\nexport * from 'roosterjs-editor-types';\r\nexport * from 'roosterjs-editor-dom';\r\nexport * from 'roosterjs-editor-core';\r\nexport * from 'roosterjs-editor-api';\r\nexport * from 'roosterjs-editor-plugins';\r\n","import { ContentEdit } from 'roosterjs-editor-plugins/lib/ContentEdit';\r\nimport { Editor } from 'roosterjs-editor-core';\r\nimport { EditorOptions, EditorPlugin, IEditor } from 'roosterjs-editor-types';\r\nimport { HyperLink } from 'roosterjs-editor-plugins/lib/HyperLink';\r\nimport { Paste } from 'roosterjs-editor-plugins/lib/Paste';\r\n\r\n/**\r\n * Create an editor instance with most common options\r\n * @param contentDiv The html div element needed for creating the editor\r\n * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are\r\n * ContentEdit, HyperLink and Paste, user don't need to add those.\r\n * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.\r\n * @returns The editor instance\r\n */\r\nexport default function createEditor(\r\n    contentDiv: HTMLDivElement,\r\n    additionalPlugins?: EditorPlugin[],\r\n    initialContent?: string\r\n): IEditor {\r\n    let plugins: EditorPlugin[] = [new HyperLink(), new Paste(), new ContentEdit()];\r\n\r\n    if (additionalPlugins) {\r\n        plugins = plugins.concat(additionalPlugins);\r\n    }\r\n\r\n    let options: EditorOptions = {\r\n        plugins: plugins,\r\n        initialContent: initialContent,\r\n        defaultFormat: {\r\n            fontFamily: 'Calibri,Arial,Helvetica,sans-serif',\r\n            fontSize: '11pt',\r\n            textColor: '#000000',\r\n        },\r\n    };\r\n    return new Editor(contentDiv, options);\r\n}\r\n","export { default as ContentEdit } from './ContentEdit';\r\nexport { default as getAllFeatures } from './getAllFeatures';\r\n","import getAllFeatures from './getAllFeatures';\r\nimport {\r\n    ContentEditFeatureSettings,\r\n    EditorPlugin,\r\n    GenericContentEditFeature,\r\n    IEditor,\r\n    PluginEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An editor plugin to handle content edit event.\r\n * The following cases are included:\r\n * 1. Auto increase/decrease indentation on Tab, Shift+tab\r\n * 2. Enter, Backspace on empty list item\r\n * 3. Enter, Backspace on empty blockquote line\r\n * 4. Auto bullet/numbering\r\n * 5. Auto link\r\n * 6. Tab in table\r\n * 7. Up/Down in table\r\n * 8. Manage list style\r\n */\r\nexport default class ContentEdit implements EditorPlugin {\r\n    /**\r\n     * Create instance of ContentEdit plugin\r\n     * @param settingsOverride An optional feature set to override default feature settings\r\n     * @param additionalFeatures Optional. More features to add\r\n     */\r\n    constructor(\r\n        private settingsOverride?: Partial<ContentEditFeatureSettings>,\r\n        private additionalFeatures?: GenericContentEditFeature<PluginEvent>[]\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ContentEdit';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    initialize(editor: IEditor): void {\r\n        const features: GenericContentEditFeature<PluginEvent>[] = [];\r\n        const allFeatures = getAllFeatures();\r\n\r\n        Object.keys(allFeatures).forEach((key: keyof typeof allFeatures) => {\r\n            const feature = allFeatures[key];\r\n            const hasSettingForKey =\r\n                this.settingsOverride && this.settingsOverride[key] !== undefined;\r\n\r\n            if (\r\n                (hasSettingForKey && this.settingsOverride[key]) ||\r\n                (!hasSettingForKey && !feature.defaultDisabled)\r\n            ) {\r\n                features.push(feature);\r\n            }\r\n        });\r\n\r\n        features\r\n            .concat(this.additionalFeatures || [])\r\n            .forEach(feature => editor.addContentEditFeature(feature));\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose(): void {}\r\n}\r\n","import { removeLink, replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    AutoLinkFeatureSettings,\r\n    BuildInEditFeature,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    IEditor,\r\n    Keys,\r\n    LinkData,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    clearEventDataCache,\r\n    LinkInlineElement,\r\n    matchLink,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * When user type, they may end a link with a puncatuation, i.e. www.bing.com;\r\n * we need to trim off the trailing puncatuation before turning it to link match\r\n */\r\nconst TRAILING_PUNCTUATION_REGEX = /[.+=\\s:;\"',>]+$/i;\r\nconst MINIMUM_LENGTH = 5;\r\n\r\n/**\r\n * AutoLink edit feature, provides the ability to automatically convert text user typed or pasted\r\n * in hyperlink format into a real hyperlink\r\n */\r\nconst AutoLink: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER, Keys.SPACE, Keys.CONTENTCHANGED],\r\n    shouldHandleEvent: cacheGetLinkData,\r\n    handleEvent: autoLink,\r\n};\r\n\r\n/**\r\n * UnlinkWhenBackspaceAfterLink edit feature, provides the ability to convert a hyperlink back into text\r\n * if user presses BACKSPACE right after a hyperlink\r\n */\r\nconst UnlinkWhenBackspaceAfterLink: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: hasLinkBeforeCursor,\r\n    handleEvent: (event, editor) => {\r\n        event.rawEvent.preventDefault();\r\n        removeLink(editor);\r\n    },\r\n    defaultDisabled: true,\r\n};\r\n\r\nfunction cacheGetLinkData(event: PluginEvent, editor: IEditor): LinkData {\r\n    return event.eventType == PluginEventType.KeyDown ||\r\n        (event.eventType == PluginEventType.ContentChanged && event.source == ChangeSource.Paste)\r\n        ? cacheGetEventData(event, 'LINK_DATA', () => {\r\n              // First try to match link from the whole paste string from the plain text in clipboard.\r\n              // This helps when we paste a link next to some existing character, and the text we got\r\n              // from clipboard will only contain what we pasted, any existing characters will not\r\n              // be included.\r\n              let clipboardData =\r\n                  event.eventType == PluginEventType.ContentChanged &&\r\n                  event.source == ChangeSource.Paste &&\r\n                  (event.data as ClipboardData);\r\n              let link = matchLink((clipboardData.text || '').trim());\r\n              let searcher = editor.getContentSearcherOfCursor(event);\r\n\r\n              // In case the matched link is already inside a <A> tag, we do a range search.\r\n              // getRangeFromText will return null if the given text is already in a LinkInlineElement\r\n              if (link && searcher.getRangeFromText(link.originalUrl, false /*exactMatch*/)) {\r\n                  return link;\r\n              }\r\n\r\n              let word = searcher && searcher.getWordBefore();\r\n              if (word && word.length > MINIMUM_LENGTH) {\r\n                  // Check for trailing punctuation\r\n                  let trailingPunctuations = word.match(TRAILING_PUNCTUATION_REGEX);\r\n                  let trailingPunctuation = (trailingPunctuations || [])[0] || '';\r\n                  let candidate = word.substring(0, word.length - trailingPunctuation.length);\r\n\r\n                  // Do special handling for ')', '}', ']'\r\n                  ['()', '{}', '[]'].forEach(str => {\r\n                      if (\r\n                          candidate[candidate.length - 1] == str[1] &&\r\n                          candidate.indexOf(str[0]) < 0\r\n                      ) {\r\n                          candidate = candidate.substr(0, candidate.length - 1);\r\n                      }\r\n                  });\r\n\r\n                  // Match and replace in editor\r\n                  return matchLink(candidate);\r\n              }\r\n              return null;\r\n          })\r\n        : null;\r\n}\r\n\r\nfunction hasLinkBeforeCursor(event: PluginKeyboardEvent, editor: IEditor): boolean {\r\n    let contentSearcher = editor.getContentSearcherOfCursor(event);\r\n    let inline = contentSearcher.getInlineElementBefore();\r\n    return inline instanceof LinkInlineElement;\r\n}\r\n\r\nfunction autoLink(event: PluginEvent, editor: IEditor) {\r\n    let anchor = editor.getDocument().createElement('a');\r\n    let linkData = cacheGetLinkData(event, editor);\r\n\r\n    // Need to get searcher before we enter the async callback since the callback can happen when cursor is moved to next line\r\n    // and at that time a new searcher won't be able to find the link text to replace\r\n    let searcher = editor.getContentSearcherOfCursor();\r\n    anchor.textContent = linkData.originalUrl;\r\n    anchor.href = linkData.normalizedUrl;\r\n\r\n    editor.runAsync(editor => {\r\n        editor.addUndoSnapshot(\r\n            () => {\r\n                replaceWithNode(\r\n                    editor,\r\n                    linkData.originalUrl,\r\n                    anchor,\r\n                    false /* exactMatch */,\r\n                    searcher\r\n                );\r\n\r\n                // The content at cursor has changed. Should also clear the cursor data cache\r\n                clearEventDataCache(event);\r\n                return anchor;\r\n            },\r\n            ChangeSource.AutoLink,\r\n            true /*canUndoByBackspace*/\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const AutoLinkFeatures: Record<\r\n    keyof AutoLinkFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    autoLink: AutoLink,\r\n    unlinkWhenBackspaceAfterLink: UnlinkWhenBackspaceAfterLink,\r\n};\r\n","import applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { FontSizeChange, IEditor } from 'roosterjs-editor-types';\r\nimport { getComputedStyle } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Default font size sequence, in pt. Suggest editor UI use this sequence as your font size list,\r\n * So that when increase/decrease font size, the font size can match the sequence of your font size picker\r\n */\r\nexport const FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];\r\nconst MIN_FONT_SIZE = 1;\r\nconst MAX_FONT_SIZE = 1000;\r\n\r\n/**\r\n * Increase or decrease font size in selection\r\n * @param editor The editor instance\r\n * @param change Whether increase or decrease font size\r\n * @param fontSizes A sorted font size array, in pt. Default value is FONT_SIZES\r\n */\r\nexport default function changeFontSize(\r\n    editor: IEditor,\r\n    change: FontSizeChange,\r\n    fontSizes: number[] = FONT_SIZES\r\n) {\r\n    let changeBase: 1 | -1 = change == FontSizeChange.Increase ? 1 : -1;\r\n    applyInlineStyle(editor, element => {\r\n        let pt = parseFloat(getComputedStyle(element, 'font-size'));\r\n        element.style.fontSize = getNewFontSize(pt, changeBase, fontSizes) + 'pt';\r\n        let lineHeight = getComputedStyle(element, 'line-height');\r\n        if (lineHeight != 'normal') {\r\n            element.style.lineHeight = 'normal';\r\n        }\r\n    });\r\n}\r\n\r\nexport function getNewFontSize(pt: number, changeBase: 1 | -1, fontSizes: number[]): number {\r\n    pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n    let last = fontSizes[fontSizes.length - 1];\r\n    if (pt <= fontSizes[0]) {\r\n        pt = Math.max(pt + changeBase, MIN_FONT_SIZE);\r\n    } else if (pt > last || (pt == last && changeBase == 1)) {\r\n        pt = pt / 10;\r\n        pt = changeBase == 1 ? Math.floor(pt) : Math.ceil(pt);\r\n        pt = Math.min(Math.max((pt + changeBase) * 10, last), MAX_FONT_SIZE);\r\n    } else if (changeBase == 1) {\r\n        for (let i = 0; i < fontSizes.length; i++) {\r\n            if (pt < fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = fontSizes.length - 1; i >= 0; i--) {\r\n            if (pt > fontSizes[i]) {\r\n                pt = fontSizes[i];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pt;\r\n}\r\n","import collapseNodes from '../utils/collapseNodes';\r\nimport contains from '../utils/contains';\r\nimport createRange from '../selection/createRange';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport wrap from '../utils/wrap';\r\nimport { BlockElement } from 'roosterjs-editor-types';\r\nimport { splitBalancedNodeRange } from '../utils/splitParentNode';\r\n\r\nconst STRUCTURE_NODE_TAGS = ['TD', 'TH', 'LI', 'BLOCKQUOTE'];\r\n\r\n/**\r\n * @internal\r\n * This reprents a block that is identified by a start and end node\r\n * This is for cases like &lt;root&gt;Hello&lt;BR&gt;World&lt;/root&gt;\r\n * in that case, Hello&lt;BR&gt; is a block, World is another block\r\n * Such block cannot be represented by a NodeBlockElement since they don't chained up\r\n * to a single parent node, instead they have a start and end\r\n * This start and end must be in same sibling level and have same parent in DOM tree\r\n */\r\nexport default class StartEndBlockElement implements BlockElement {\r\n    constructor(private rootNode: Node, private startNode: Node, private endNode: Node) {}\r\n\r\n    static getBlockContext(node: Node): HTMLElement {\r\n        while (node && !isBlockElement(node)) {\r\n            node = node.parentNode;\r\n        }\r\n        return node as HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * Collapse this element to a single DOM element.\r\n     * If the content nodes are separated in different root nodes, wrap them to a single node\r\n     * If the content nodes are included in root node with other nodes, split root node\r\n     */\r\n    public collapseToSingleElement(): HTMLElement {\r\n        let nodes = collapseNodes(\r\n            StartEndBlockElement.getBlockContext(this.startNode),\r\n            this.startNode,\r\n            this.endNode,\r\n            true /*canSplitParent*/\r\n        );\r\n        let blockContext = StartEndBlockElement.getBlockContext(this.startNode);\r\n        while (\r\n            nodes[0] &&\r\n            nodes[0] != blockContext &&\r\n            nodes[0].parentNode != this.rootNode &&\r\n            STRUCTURE_NODE_TAGS.indexOf(getTagOfNode(nodes[0].parentNode)) < 0\r\n        ) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n        return nodes.length == 1 && isBlockElement(nodes[0])\r\n            ? (nodes[0] as HTMLElement)\r\n            : wrap(nodes);\r\n    }\r\n\r\n    /**\r\n     * Gets the start node\r\n     */\r\n    public getStartNode(): Node {\r\n        return this.startNode;\r\n    }\r\n\r\n    /**\r\n     * Gets the end node\r\n     */\r\n    public getEndNode(): Node {\r\n        return this.endNode;\r\n    }\r\n\r\n    /**\r\n     * Checks equals of two blocks\r\n     */\r\n    public equals(blockElement: BlockElement): boolean {\r\n        return (\r\n            this.startNode == blockElement.getStartNode() &&\r\n            this.endNode == blockElement.getEndNode()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if another block is after this current\r\n     */\r\n    public isAfter(blockElement: BlockElement): boolean {\r\n        return isNodeAfter(this.getStartNode(), blockElement.getEndNode());\r\n    }\r\n\r\n    /**\r\n     * Checks if an Html node is contained within the block\r\n     */\r\n    public contains(node: Node): boolean {\r\n        return (\r\n            contains(this.startNode, node, true /*treatSameNodeAsContain*/) ||\r\n            contains(this.endNode, node, true /*treatSameNodeAsContain*/) ||\r\n            (isNodeAfter(node, this.startNode) && isNodeAfter(this.endNode, node))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the text content of this block element\r\n     */\r\n    public getTextContent(): string {\r\n        const range = createRange(this.getStartNode(), this.getEndNode());\r\n        return range ? range.toString() : '';\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getFirstLastBlockElement from '../blockElements/getFirstLastBlockElement';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement } from 'roosterjs-editor-types';\r\nimport { getFirstInlineElement } from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * provides scoper for traversing the entire editor body starting from the beginning\r\n */\r\nexport default class BodyScoper implements TraversingScoper {\r\n    private startNode: Node;\r\n\r\n    /**\r\n     * Construct a new instance of BodyScoper class\r\n     * @param rootNode Root node of the body\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    constructor(public rootNode: Node, startNode?: Node) {\r\n        this.startNode = contains(rootNode, startNode) ? startNode : null;\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.startNode\r\n            ? getBlockElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstLastBlockElement(this.rootNode, true /*isFirst*/);\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        return this.startNode\r\n            ? getInlineElementAtNode(this.rootNode, this.startNode)\r\n            : getFirstInlineElement(this.rootNode);\r\n    }\r\n\r\n    /**\r\n     * Since the scope is global, all blocks under the root node are in scope\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return contains(this.rootNode, blockElement.getStartNode());\r\n    }\r\n\r\n    /**\r\n     * Since we're at body scope, inline elements never need to be trimmed\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return inlineElement;\r\n    }\r\n}\r\n","import EmptyInlineElement from '../inlineElements/EmptyInlineElement';\r\nimport getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport getInlineElementAtNode from '../inlineElements/getInlineElementAtNode';\r\nimport NodeBlockElement from '../blockElements/NodeBlockElement';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, ContentPosition, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\nimport {\r\n    getFirstInlineElement,\r\n    getLastInlineElement,\r\n} from '../inlineElements/getFirstLastInlineElement';\r\n\r\n/**\r\n * @internal\r\n * This provides traversing content in a selection start block\r\n * This is commonly used for those cursor context sensitive plugin,\r\n * they want to know text being typed at cursor\r\n * This provides a scope for parsing from cursor position up to begin of the selection block\r\n */\r\nexport default class SelectionBlockScoper implements TraversingScoper {\r\n    private block: BlockElement;\r\n    private position: NodePosition;\r\n\r\n    /**\r\n     * Create a new instance of SelectionBlockScoper class\r\n     * @param rootNode The root node of the whole scope\r\n     * @param position Position of the selection start\r\n     * @param startFrom Where to start, can be Begin, End, SelectionStart\r\n     */\r\n    constructor(\r\n        public rootNode: Node,\r\n        position: NodePosition | Range,\r\n        private startFrom: ContentPosition\r\n    ) {\r\n        position = safeInstanceOf(position, 'Range') ? Position.getStart(position) : position;\r\n        this.position = position.normalize();\r\n        this.block = getBlockElementAtNode(this.rootNode, this.position.node);\r\n    }\r\n\r\n    /**\r\n     * Get the start block element\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        return this.block;\r\n    }\r\n\r\n    /**\r\n     * Get the start inline element\r\n     * The start inline refers to inline before the selection start\r\n     *  The reason why we choose the one before rather after is, when cursor is at the end of a paragragh,\r\n     * the one after likely will point to inline in next paragragh which may be null if the cursor is at bottom of editor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (this.block) {\r\n            switch (this.startFrom) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End:\r\n                case ContentPosition.DomEnd:\r\n                    return getFirstLastInlineElementFromBlockElement(\r\n                        this.block,\r\n                        this.startFrom == ContentPosition.Begin\r\n                    );\r\n                case ContentPosition.SelectionStart:\r\n                    // Get the inline before selection start point, and ensure it falls in the selection block\r\n                    let startInline = getInlineElementAfter(this.rootNode, this.position);\r\n                    return startInline && this.block.contains(startInline.getContainerNode())\r\n                        ? startInline\r\n                        : new EmptyInlineElement(this.position, this.block);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if the given block element is in current scope\r\n     * @param blockElement The block element to check\r\n     */\r\n    public isBlockInScope(blockElement: BlockElement): boolean {\r\n        return this.block && blockElement ? this.block.equals(blockElement) : false;\r\n    }\r\n\r\n    /**\r\n     * Trim the incoming inline element, and return an inline element\r\n     * This just tests and return the inline element if it is in block\r\n     * This is a block scoper, which is not like selection scoper where it may cut an inline element in half\r\n     * A block scoper does not cut an inline in half\r\n     */\r\n    public trimInlineElement(inlineElement: InlineElement): InlineElement {\r\n        return this.block && inlineElement && this.block.contains(inlineElement.getContainerNode())\r\n            ? inlineElement\r\n            : null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get first/last InlineElement of the given BlockElement\r\n * @param block The BlockElement to get InlineElement from\r\n * @param isFirst True to get first InlineElement, false to get last InlineElement\r\n */\r\nfunction getFirstLastInlineElementFromBlockElement(\r\n    block: BlockElement,\r\n    isFirst: boolean\r\n): InlineElement {\r\n    if (block instanceof NodeBlockElement) {\r\n        let blockNode = block.getStartNode();\r\n        return isFirst ? getFirstInlineElement(blockNode) : getLastInlineElement(blockNode);\r\n    } else {\r\n        return getInlineElementAtNode(block, isFirst ? block.getStartNode() : block.getEndNode());\r\n    }\r\n}\r\n","import getBlockElementAtNode from '../blockElements/getBlockElementAtNode';\r\nimport PartialInlineElement from '../inlineElements/PartialInlineElement';\r\nimport Position from '../selection/Position';\r\nimport TraversingScoper from './TraversingScoper';\r\nimport { BlockElement, InlineElement, NodePosition } from 'roosterjs-editor-types';\r\nimport { getInlineElementAfter } from '../inlineElements/getInlineElementBeforeAfter';\r\n\r\n/**\r\n * @internal\r\n * This is selection scoper that provide a start inline as the start of the selection\r\n * and checks if a block falls in the selection (isBlockInScope)\r\n * last trimInlineElement to trim any inline element to return a partial that falls in the selection\r\n */\r\nexport default class SelectionScoper implements TraversingScoper {\r\n    private start: NodePosition;\r\n    private end: NodePosition;\r\n    private startBlock: BlockElement;\r\n    private startInline: InlineElement;\r\n\r\n    /**\r\n     * Create a new instance of SelectionScoper class\r\n     * @param rootNode The root node of the content\r\n     * @param range The selection range to scope to\r\n     */\r\n    constructor(public rootNode: Node, range: Range) {\r\n        this.start = Position.getStart(range).normalize();\r\n        this.end = Position.getEnd(range).normalize();\r\n    }\r\n\r\n    /**\r\n     * Provide a start block as the first block after the cursor\r\n     */\r\n    public getStartBlockElement(): BlockElement {\r\n        if (!this.startBlock) {\r\n            this.startBlock = getBlockElementAtNode(this.rootNode, this.start.node);\r\n        }\r\n\r\n        return this.startBlock;\r\n    }\r\n\r\n    /**\r\n     * Provide a start inline as the first inline after the cursor\r\n     */\r\n    public getStartInlineElement(): InlineElement {\r\n        if (!this.startInline) {\r\n            this.startInline = this.trimInlineElement(\r\n                getInlineElementAfter(this.rootNode, this.start)\r\n            );\r\n        }\r\n\r\n        return this.startInline;\r\n    }\r\n\r\n    /**\r\n     * Checks if a block completely falls in the selection\r\n     * @param block The BlockElement to check\r\n     */\r\n    public isBlockInScope(block: BlockElement): boolean {\r\n        if (!block) {\r\n            return false;\r\n        }\r\n        let inScope = false;\r\n        let selStartBlock = this.getStartBlockElement();\r\n        if (this.start.equalTo(this.end)) {\r\n            inScope = selStartBlock && selStartBlock.equals(block);\r\n        } else {\r\n            let selEndBlock = getBlockElementAtNode(this.rootNode, this.end.node);\r\n\r\n            // There are three cases that are considered as \"block in scope\"\r\n            // 1) The start of selection falls on the block\r\n            // 2) The end of selection falls on the block\r\n            // 3) the block falls in-between selection start and end\r\n            inScope =\r\n                selStartBlock &&\r\n                selEndBlock &&\r\n                (block.equals(selStartBlock) ||\r\n                    block.equals(selEndBlock) ||\r\n                    (block.isAfter(selStartBlock) && selEndBlock.isAfter(block)));\r\n        }\r\n\r\n        return inScope;\r\n    }\r\n\r\n    /**\r\n     * Trim an incoming inline. If it falls completely outside selection, return null\r\n     * otherwise return a partial that represents the portion that falls in the selection\r\n     * @param inline The InlineElement to check\r\n     */\r\n    public trimInlineElement(inline: InlineElement): InlineElement {\r\n        if (!inline || this.start.equalTo(this.end)) {\r\n            return null;\r\n        }\r\n\r\n        // Temp code. Will be changed to using InlineElement.getStart/EndPosition() soon\r\n        let start = inline.getStartPosition();\r\n        let end = inline.getEndPosition();\r\n\r\n        if (start.isAfter(this.end) || this.start.isAfter(end)) {\r\n            return null;\r\n        }\r\n\r\n        let startPartial = false;\r\n        let endPartial = false;\r\n\r\n        if (this.start.isAfter(start)) {\r\n            start = this.start;\r\n            startPartial = true;\r\n        }\r\n\r\n        if (end.isAfter(this.end)) {\r\n            end = this.end;\r\n            endPartial = true;\r\n        }\r\n\r\n        return start.isAfter(end) || start.equalTo(end)\r\n            ? null\r\n            : startPartial || endPartial\r\n            ? new PartialInlineElement(inline, startPartial && start, endPartial && end)\r\n            : inline;\r\n    }\r\n}\r\n","import ContentTraverser from './ContentTraverser';\r\nimport createRange from '../selection/createRange';\r\nimport {\r\n    IContentTraverser,\r\n    InlineElement,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\n// White space matching regex. It matches following chars:\r\n// \\s: white space\r\n// \\u00A0: no-breaking white space\r\n// \\u200B: zero width space\r\n// \\u3000: full width space (which can come from JPN IME)\r\nconst WHITESPACE_REGEX = /[\\s\\u00A0\\u200B\\u3000]+([^\\s\\u00A0\\u200B\\u3000]*)$/i;\r\n\r\n/**\r\n * The class that helps search content around a position\r\n */\r\nexport default class PositionContentSearcher implements IPositionContentSearcher {\r\n    // The cached text before position that has been read so far\r\n    private text = '';\r\n\r\n    // The cached word before position\r\n    private word: string;\r\n\r\n    // The inline element before position\r\n    private inlineBefore: InlineElement;\r\n\r\n    // The inline element after position\r\n    private inlineAfter: InlineElement;\r\n\r\n    // The content traverser used to traverse backwards\r\n    private traverser: IContentTraverser;\r\n\r\n    // Backward parsing has completed\r\n    private traversingComplete: boolean;\r\n\r\n    // All inline elements before position that have been read so far\r\n    private inlineElements: InlineElement[] = [];\r\n\r\n    // First non-text inline before position\r\n    private nearestNonTextInlineElement: InlineElement;\r\n\r\n    /**\r\n     * Create a new CursorData instance\r\n     * @param rootNode Root node of the whole scope\r\n     * @param position Start position\r\n     */\r\n    constructor(private rootNode: Node, private position: NodePosition) {}\r\n\r\n    /**\r\n     * Get the word before position. The word is determined by scanning backwards till the first white space, the portion\r\n     * between position and the white space is the word before position\r\n     * @returns The word before position\r\n     */\r\n    public getWordBefore(): string {\r\n        if (!this.word) {\r\n            this.traverse(() => this.word);\r\n        }\r\n\r\n        return this.word;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element before position\r\n     * @returns The inlineElement before position\r\n     */\r\n    public getInlineElementBefore(): InlineElement {\r\n        if (!this.inlineBefore) {\r\n            this.traverse(null);\r\n        }\r\n\r\n        return this.inlineBefore;\r\n    }\r\n\r\n    /**\r\n     * Get the inline element after position\r\n     * @returns The inline element after position\r\n     */\r\n    public getInlineElementAfter(): InlineElement {\r\n        if (!this.inlineAfter) {\r\n            this.inlineAfter = ContentTraverser.createBlockTraverser(\r\n                this.rootNode,\r\n                this.position\r\n            ).currentInlineElement;\r\n        }\r\n\r\n        return this.inlineAfter;\r\n    }\r\n\r\n    /**\r\n     * Get X number of chars before position\r\n     * The actual returned chars may be less than what is requested.\r\n     * @param length The length of string user want to get, the string always ends at the position,\r\n     * so this length determins the start position of the string\r\n     * @returns The actual string we get as a sub string, or the whole string before position when\r\n     * there is not enough chars in the string\r\n     */\r\n    public getSubStringBefore(length: number): string {\r\n        if (this.text.length < length) {\r\n            this.traverse(() => this.text.length >= length);\r\n        }\r\n\r\n        return this.text.substr(Math.max(0, this.text.length - length));\r\n    }\r\n\r\n    /**\r\n     * Try to get a range matches the given text before the position\r\n     * @param text The text to match against\r\n     * @param exactMatch Whether it is an exact match\r\n     * @returns The range for the matched text, null if unable to find a match\r\n     */\r\n    public getRangeFromText(text: string, exactMatch: boolean): Range {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        let textIndex = text.length - 1;\r\n\r\n        this.forEachTextInlineElement(textInline => {\r\n            let nodeContent = textInline.getTextContent() || '';\r\n            let nodeIndex = nodeContent.length - 1;\r\n            for (; nodeIndex >= 0 && textIndex >= 0; nodeIndex--) {\r\n                if (text.charCodeAt(textIndex) == nodeContent.charCodeAt(nodeIndex)) {\r\n                    textIndex--;\r\n\r\n                    // on first time when end is matched, set the end of range\r\n                    if (!endPosition) {\r\n                        endPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                    }\r\n                } else if (exactMatch || endPosition) {\r\n                    // Mismatch found when exact match or end already match, so return since matching failed\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // when textIndex == -1, we have a successful complete match\r\n            if (textIndex == -1) {\r\n                startPosition = textInline.getStartPosition().move(nodeIndex + 1);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return startPosition && endPosition && createRange(startPosition, endPosition);\r\n    }\r\n\r\n    /**\r\n     * Get text section before position till stop condition is met.\r\n     * This offers consumers to retrieve text section by section\r\n     * The section essentially is just an inline element which has Container element\r\n     * so that the consumer can remember it for anchoring popup or verification purpose\r\n     * when position moves out of context etc.\r\n     * @param stopFunc The callback stop function\r\n     */\r\n    public forEachTextInlineElement(callback: (textInlineElement: InlineElement) => any) {\r\n        // We cache all text sections read so far\r\n        // Every time when you ask for textSection, we start with the cached first\r\n        // and resort to further reading once we exhausted with the cache\r\n        if (!this.inlineElements.some(callback)) {\r\n            this.traverse(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get first non textual inline element before position\r\n     * @returns First non textutal inline element before position or null if no such element exists\r\n     */\r\n    public getNearestNonTextInlineElement(): InlineElement {\r\n        if (!this.nearestNonTextInlineElement) {\r\n            this.traverse(() => this.nearestNonTextInlineElement);\r\n        }\r\n\r\n        return this.nearestNonTextInlineElement;\r\n    }\r\n\r\n    /**\r\n     * Continue traversing backward till stop condition is met or begin of block is reached\r\n     */\r\n    private traverse(callback: (inlineElement: InlineElement) => any) {\r\n        this.traverser =\r\n            this.traverser || ContentTraverser.createBlockTraverser(this.rootNode, this.position);\r\n\r\n        if (!this.traverser || this.traversingComplete) {\r\n            return;\r\n        }\r\n\r\n        let previousInline = this.traverser.getPreviousInlineElement();\r\n        while (!this.traversingComplete) {\r\n            this.inlineBefore = this.inlineBefore || previousInline;\r\n\r\n            if (previousInline && previousInline.isTextualInlineElement()) {\r\n                let textContent = previousInline.getTextContent();\r\n\r\n                // build the word before position if it is not built yet\r\n                if (!this.word) {\r\n                    // Match on the white space, the portion after space is on the index of 1 of the matched result\r\n                    // (index at 0 is whole match result, index at 1 is the word)\r\n                    let matches = WHITESPACE_REGEX.exec(textContent);\r\n                    if (matches && matches.length == 2) {\r\n                        this.word = matches[1] + this.text;\r\n                    }\r\n                }\r\n\r\n                this.text = textContent + this.text;\r\n                this.inlineElements.push(previousInline);\r\n\r\n                // Check if stop condition is met\r\n                if (callback && callback(previousInline)) {\r\n                    break;\r\n                }\r\n            } else {\r\n                this.nearestNonTextInlineElement = previousInline;\r\n                this.traversingComplete = true;\r\n                if (!this.word) {\r\n                    // if parsing is done, whatever we get so far in this.cachedText should also be in this.cachedWordBeforeCursor\r\n                    this.word = this.text;\r\n                }\r\n\r\n                // When a non-textual inline element, or null is seen, we consider parsing complete\r\n                // TODO: we may need to change this if there is a future need to parse beyond text, i.e.\r\n                // we have aaa @someone bbb<position>, and we want to read the text before @someone\r\n                break;\r\n            }\r\n\r\n            previousInline = this.traverser.getPreviousInlineElement();\r\n        }\r\n    }\r\n}\r\n","import { DarkModeDatasetNames, DefaultFormat } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Apply format to an HTML element\r\n * @param element The HTML element to apply format to\r\n * @param format The format to apply\r\n */\r\nexport default function applyFormat(\r\n    element: HTMLElement,\r\n    format: DefaultFormat,\r\n    isDarkMode?: boolean\r\n) {\r\n    if (format) {\r\n        let elementStyle = element.style;\r\n        let {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = format;\r\n\r\n        if (fontFamily) {\r\n            elementStyle.fontFamily = fontFamily;\r\n        }\r\n        if (fontSize) {\r\n            elementStyle.fontSize = fontSize;\r\n        }\r\n        if (textColor || textColors) {\r\n            elementStyle.color =\r\n                (isDarkMode ? textColors?.darkModeColor : textColors?.lightModeColor) || textColor;\r\n\r\n            if (textColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleColor] =\r\n                    textColors.lightModeColor;\r\n            }\r\n        }\r\n        if (backgroundColor || backgroundColors) {\r\n            elementStyle.backgroundColor =\r\n                (isDarkMode ? backgroundColors?.darkModeColor : backgroundColors?.lightModeColor) ||\r\n                backgroundColor;\r\n\r\n            if (backgroundColors && isDarkMode) {\r\n                element.dataset[DarkModeDatasetNames.OriginalStyleBackgroundColor] =\r\n                    backgroundColors.lightModeColor;\r\n            }\r\n        }\r\n        if (bold) {\r\n            elementStyle.fontWeight = 'bold';\r\n        }\r\n        if (italic) {\r\n            elementStyle.fontStyle = 'italic';\r\n        }\r\n        if (underline) {\r\n            elementStyle.textDecoration = 'underline';\r\n        }\r\n    }\r\n}\r\n","import toArray from './toArray';\r\nimport { Browser } from './Browser';\r\nimport {\r\n    ClipboardData,\r\n    EdgeLinkPreview,\r\n    ExtractClipboardEventOption,\r\n} from 'roosterjs-editor-types';\r\n\r\n// HTML header to indicate where is the HTML content started from.\r\n// Sample header:\r\n// Version:0.9\r\n// StartHTML:71\r\n// EndHTML:170\r\n// StartFragment:140\r\n// EndFragment:160\r\n// StartSelection:140\r\n// EndSelection:160\r\nconst CLIPBOARD_HTML_HEADER_REGEX = /^Version:[0-9\\.]+\\s+StartHTML:\\s*([0-9]+)\\s+EndHTML:\\s*([0-9]+)\\s+/i;\r\n\r\ninterface WindowForIE extends Window {\r\n    clipboardData: DataTransfer;\r\n}\r\n\r\n/**\r\n * Extract a Clipboard event\r\n * @param event The paste event\r\n * @param callback Callback function when data is ready\r\n * @param fallbackHtmlRetriever If direct HTML retriving is not support (e.g. Internet Explorer), as a fallback,\r\n * using this helper function to retrieve HTML content\r\n * @returns An object with the following properties:\r\n *  types: Available types from the clipboard event\r\n *  text: Plain text from the clipboard event\r\n *  image: Image file from the clipboard event\r\n *  html: Html string from the clipboard event. When set to null, it means there's no HTML found from the event.\r\n *   When set to undefined, it means can't retrieve HTML string, there may be HTML string but direct retrieving is\r\n *   not supported by browser.\r\n */\r\nexport default function extractClipboardEvent(\r\n    event: ClipboardEvent,\r\n    callback: (items: ClipboardData) => void,\r\n    options?: ExtractClipboardEventOption\r\n) {\r\n    let dataTransfer =\r\n        event.clipboardData ||\r\n        (<WindowForIE>(<Node>event.target).ownerDocument.defaultView).clipboardData;\r\n    let result: ClipboardData = {\r\n        types: dataTransfer.types ? toArray(dataTransfer.types) : [],\r\n        text: dataTransfer.getData('text'),\r\n        image: getImage(dataTransfer),\r\n        rawHtml: undefined,\r\n    };\r\n\r\n    const handlers: {\r\n        promise: Promise<string>;\r\n        callback: (value: string) => void;\r\n    }[] = [];\r\n\r\n    if (event.clipboardData && event.clipboardData.items) {\r\n        event.preventDefault();\r\n\r\n        // Set rawHtml to null so that caller knows that we have tried\r\n        result.rawHtml = null;\r\n        const items = event.clipboardData.items;\r\n\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n\r\n            switch (item.type) {\r\n                case 'text/html':\r\n                    handlers.push({\r\n                        promise: getAsString(item),\r\n                        callback: value => {\r\n                            result.rawHtml = Browser.isEdge ? workaroundForEdge(value) : value;\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'text/link-preview':\r\n                    if (options?.allowLinkPreview) {\r\n                        handlers.push({\r\n                            promise: getAsString(item),\r\n                            callback: value => {\r\n                                try {\r\n                                    result.linkPreview = JSON.parse(value) as EdgeLinkPreview;\r\n                                } catch {}\r\n                            },\r\n                        });\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Promise.all(handlers.map(handler => handler.promise)).then(values => {\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            handlers[i].callback(values[i]);\r\n        }\r\n\r\n        callback(result);\r\n    });\r\n}\r\n\r\nfunction getImage(dataTransfer: DataTransfer): File {\r\n    // Chrome, Firefox, Edge support dataTransfer.items\r\n    let fileCount = dataTransfer.items ? dataTransfer.items.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let item = dataTransfer.items[i];\r\n        if (item.type && item.type.indexOf('image/') == 0) {\r\n            return item.getAsFile();\r\n        }\r\n    }\r\n    // IE, Safari support dataTransfer.files\r\n    fileCount = dataTransfer.files ? dataTransfer.files.length : 0;\r\n    for (let i = 0; i < fileCount; i++) {\r\n        let file = dataTransfer.files.item(i);\r\n        if (file.type && file.type.indexOf('image/') == 0) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Edge sometimes doesn't remove the headers, which cause we paste more things then expected.\r\n * So we need to remove it in our code\r\n * @param html The HTML string got from clipboard\r\n */\r\nfunction workaroundForEdge(html: string) {\r\n    let headerValues = CLIPBOARD_HTML_HEADER_REGEX.exec(html);\r\n\r\n    if (headerValues && headerValues.length == 3) {\r\n        let start = parseInt(headerValues[1]);\r\n        let end = parseInt(headerValues[2]);\r\n        if (start > 0 && end > start) {\r\n            html = html.substring(start, end);\r\n        }\r\n    }\r\n\r\n    return html;\r\n}\r\n\r\nfunction getAsString(item: DataTransferItem): Promise<string> {\r\n    return new Promise<string>(resolve => {\r\n        item.getAsString(value => {\r\n            resolve(value);\r\n        });\r\n    });\r\n}\r\n","import { DocumentCommand, PendableFormatState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Names of Pendable formats\r\n */\r\nexport type PendableFormatNames = keyof PendableFormatState;\r\n\r\n/**\r\n * A map from pendable format name to document command\r\n */\r\nexport const PendableFormatCommandMap: { [key in PendableFormatNames]: DocumentCommand } = {\r\n    /**\r\n     * Bold\r\n     */\r\n    isBold: DocumentCommand.Bold,\r\n\r\n    /**\r\n     * Italic\r\n     */\r\n    isItalic: DocumentCommand.Italic,\r\n\r\n    /**\r\n     * Underline\r\n     */\r\n    isUnderline: DocumentCommand.Underline,\r\n\r\n    /**\r\n     * StrikeThrough\r\n     */\r\n    isStrikeThrough: DocumentCommand.StrikeThrough,\r\n\r\n    /**\r\n     * Subscript\r\n     */\r\n    isSubscript: DocumentCommand.Subscript,\r\n\r\n    /**\r\n     * Superscript\r\n     */\r\n    isSuperscript: DocumentCommand.Superscript,\r\n};\r\n\r\n/**\r\n * Get Pendable Format State at cursor.\r\n * @param document The HTML Document to get format state from\r\n * @returns A PendableFormatState object which contains the values of pendable format states\r\n */\r\nexport default function getPendableFormatState(document: Document): PendableFormatState {\r\n    let keys = Object.keys(PendableFormatCommandMap) as PendableFormatNames[];\r\n\r\n    return keys.reduce((state, key) => {\r\n        state[key] = document.queryCommandState(PendableFormatCommandMap[key]);\r\n        return state;\r\n    }, <PendableFormatState>{});\r\n}\r\n","import { LinkData } from 'roosterjs-editor-types';\r\n\r\ninterface LinkMatchRule {\r\n    match: RegExp;\r\n    except?: RegExp;\r\n    normalizeUrl?: (url: string) => string;\r\n}\r\n\r\n// http exclude matching regex\r\n// invalid URL example (in paricular on IE and Edge):\r\n// - http://www.bing.com%00, %00 before ? (question mark) is considered invalid. IE/Edge throws invalid argument exception\r\n// - http://www.bing.com%1, %1 is invalid\r\n// - http://www.bing.com%g, %g is invalid (IE and Edge expects a two hex value after a %)\r\n// - http://www.bing.com%, % as ending is invalid (IE and Edge expects a two hex value after a %)\r\n// All above % cases if they're after ? (question mark) is then considered valid again\r\n// Similar for @, it needs to be after / (forward slash), or ? (question mark). Otherwise IE/Edge will throw security exception\r\n// - http://www.bing.com@name, @name before ? (question mark) is considered invalid\r\n// - http://www.bing.com/@name, is valid sine it is after / (forward slash)\r\n// - http://www.bing.com?@name, is also valid sinve it is after ? (question mark)\r\n// The regex below is essentially a break down of:\r\n// ^[^?]+%[^0-9a-f]+ => to exclude URL like www.bing.com%%\r\n// ^[^?]+%[0-9a-f][^0-9a-f]+ => to exclude URL like www.bing.com%1\r\n// ^[^?]+%00 => to exclude URL like www.bing.com%00\r\n// ^[^?]+%$ => to exclude URL like www.bing.com%\r\n// ^https?:\\/\\/[^?\\/]+@ => to exclude URL like http://www.bing.com@name\r\n// ^www\\.[^?\\/]+@ => to exclude URL like www.bing.com@name\r\n// , => to exclude url like www.bing,,com\r\nconst httpExcludeRegEx = /^[^?]+%[^0-9a-f]+|^[^?]+%[0-9a-f][^0-9a-f]+|^[^?]+%00|^[^?]+%$|^https?:\\/\\/[^?\\/]+@|^www\\.[^?\\/]+@/i;\r\n\r\n// via https://tools.ietf.org/html/rfc1035 Page 7\r\nconst labelRegEx = '[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'; // We're using case insensitive regexes below so don't bother including A-Z\r\nconst domainNameRegEx = `(?:${labelRegEx}\\\\.)*${labelRegEx}`;\r\nconst domainPortRegEx = `${domainNameRegEx}(?:\\\\:[0-9]+)?`;\r\nconst domainPortWithUrlRegEx = `${domainPortRegEx}(?:[\\\\/\\\\?]\\\\S*)?`;\r\n\r\nconst linkMatchRules: { [schema: string]: LinkMatchRule } = {\r\n    http: {\r\n        match: new RegExp(\r\n            `^(?:microsoft-edge:)?http:\\\\/\\\\/${domainPortWithUrlRegEx}|www\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        except: httpExcludeRegEx,\r\n        normalizeUrl: url =>\r\n            new RegExp('^(?:microsoft-edge:)?http:\\\\/\\\\/', 'i').test(url) ? url : 'http://' + url,\r\n    },\r\n    https: {\r\n        match: new RegExp(`^(?:microsoft-edge:)?https:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i'),\r\n        except: httpExcludeRegEx,\r\n    },\r\n    mailto: { match: new RegExp('^mailto:\\\\S+@\\\\S+\\\\.\\\\S+', 'i') },\r\n    notes: { match: new RegExp('^notes:\\\\/\\\\/\\\\S+', 'i') },\r\n    file: { match: new RegExp('^file:\\\\/\\\\/\\\\/?\\\\S+', 'i') },\r\n    unc: { match: new RegExp('^\\\\\\\\\\\\\\\\\\\\S+', 'i') },\r\n    ftp: {\r\n        match: new RegExp(\r\n            `^ftp:\\\\/\\\\/${domainPortWithUrlRegEx}|ftp\\\\.${domainPortWithUrlRegEx}`,\r\n            'i'\r\n        ),\r\n        normalizeUrl: url => (new RegExp('^ftp:\\\\/\\\\/', 'i').test(url) ? url : 'ftp://' + url),\r\n    },\r\n    news: { match: new RegExp(`^news:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    telnet: { match: new RegExp(`^telnet:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n    gopher: { match: new RegExp(`^gopher:\\\\/\\\\/${domainPortWithUrlRegEx}`, 'i') },\r\n    wais: { match: new RegExp(`^wais:(\\\\/\\\\/)?${domainPortWithUrlRegEx}`, 'i') },\r\n};\r\n\r\n/**\r\n * Try to match a given string with link match rules, return matched link\r\n * @param url Input url to match\r\n * @param option Link match option, exact or partial. If it is exact match, we need\r\n * to check the length of matched link and url\r\n * @param rules Optional link match rules, if not passed, only the default link match\r\n * rules will be applied\r\n * @returns The matched link data, or null if no match found.\r\n * The link data includes an original url and a normalized url\r\n */\r\nexport default function matchLink(url: string): LinkData {\r\n    if (url) {\r\n        for (let schema of Object.keys(linkMatchRules)) {\r\n            let rule = linkMatchRules[schema];\r\n            let matches = url.match(rule.match);\r\n            if (matches && matches[0] == url && (!rule.except || !rule.except.test(url))) {\r\n                return {\r\n                    scheme: schema,\r\n                    originalUrl: url,\r\n                    normalizedUrl: rule.normalizeUrl ? rule.normalizeUrl(url) : url,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import ContentTraverser from '../contentTraverser/ContentTraverser';\r\n\r\n/**\r\n * get block element's text content.\r\n * @param rootNode Root node that the get the textContent of.\r\n * @returns text content of given text content.\r\n */\r\nexport default function getTextContent(rootNode: Node): string {\r\n    const traverser = ContentTraverser.createBodyTraverser(rootNode);\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let textContent: string[] = [];\r\n\r\n    while (block) {\r\n        textContent.push(block.getTextContent());\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    return textContent.join('\\n');\r\n}\r\n","/**\r\n * Read a file object and invoke a callback function with the data url of this file\r\n * @param file The file to read\r\n * @param callback the callback to invoke with data url of the file.\r\n * If fail to read, dataUrl will be null\r\n */\r\nexport default function readFile(file: File, callback: (dataUrl: string) => void) {\r\n    if (file && callback) {\r\n        const reader = new FileReader();\r\n        reader.onload = () => {\r\n            callback(reader.result as string);\r\n        };\r\n        reader.onerror = () => {\r\n            callback(null);\r\n        };\r\n        reader.readAsDataURL(file);\r\n    }\r\n}\r\n","import safeInstanceOf from '../utils/safeInstanceOf';\r\nimport toArray from '../utils/toArray';\r\nimport { TableFormat, TableOperation, VCell } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells\r\n */\r\nexport default class VTable {\r\n    /**\r\n     * The HTML table object\r\n     */\r\n    table: HTMLTableElement;\r\n\r\n    /**\r\n     * Virtual cells\r\n     */\r\n    cells: VCell[][];\r\n\r\n    /**\r\n     * Current row index\r\n     */\r\n    row: number;\r\n\r\n    /**\r\n     * Current column index\r\n     */\r\n    col: number;\r\n\r\n    private trs: HTMLTableRowElement[] = [];\r\n\r\n    /**\r\n     * Create a new instance of VTable object using HTML TABLE or TD node\r\n     * @param node The HTML Table or TD node\r\n     */\r\n    constructor(node: HTMLTableElement | HTMLTableCellElement) {\r\n        this.table = safeInstanceOf(node, 'HTMLTableElement') ? node : getTableFromTd(node);\r\n        if (this.table) {\r\n            let currentTd = safeInstanceOf(node, 'HTMLTableElement') ? null : node;\r\n            let trs = toArray(this.table.rows);\r\n            this.cells = trs.map(row => []);\r\n            trs.forEach((tr, rowIndex) => {\r\n                this.trs[rowIndex % 2] = tr;\r\n                for (let sourceCol = 0, targetCol = 0; sourceCol < tr.cells.length; sourceCol++) {\r\n                    // Skip the cells which already initialized\r\n                    for (; this.cells[rowIndex][targetCol]; targetCol++) {}\r\n\r\n                    let td = tr.cells[sourceCol];\r\n                    if (td == currentTd) {\r\n                        this.col = targetCol;\r\n                        this.row = rowIndex;\r\n                    }\r\n\r\n                    for (let colSpan = 0; colSpan < td.colSpan; colSpan++, targetCol++) {\r\n                        for (let rowSpan = 0; rowSpan < td.rowSpan; rowSpan++) {\r\n                            this.cells[rowIndex + rowSpan][targetCol] = {\r\n                                td: colSpan + rowSpan == 0 ? td : null,\r\n                                spanLeft: colSpan > 0,\r\n                                spanAbove: rowSpan > 0,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the virtual table back to DOM tree to represent the change of VTable\r\n     */\r\n    writeBack() {\r\n        if (this.cells) {\r\n            moveChildren(this.table);\r\n            this.cells.forEach((row, r) => {\r\n                let tr = cloneNode(this.trs[r % 2] || this.trs[0]);\r\n                this.table.appendChild(tr);\r\n                row.forEach((cell, c) => {\r\n                    if (cell.td) {\r\n                        this.recalcSpans(r, c);\r\n                        tr.appendChild(cell.td);\r\n                    }\r\n                });\r\n            });\r\n        } else if (this.table) {\r\n            this.table.parentNode.removeChild(this.table);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the given table format to this virtual table\r\n     * @param format Table format to apply\r\n     */\r\n    applyFormat(format: Partial<TableFormat>) {\r\n        if (!format || !this.table) {\r\n            return;\r\n        }\r\n        this.table.style.borderCollapse = 'collapse';\r\n        this.trs[0].style.backgroundColor = format.bgColorOdd || 'transparent';\r\n        if (this.trs[1]) {\r\n            this.trs[1].style.backgroundColor = format.bgColorEven || 'transparent';\r\n        }\r\n        this.cells.forEach(row =>\r\n            row\r\n                .filter(cell => cell.td)\r\n                .forEach(cell => {\r\n                    cell.td.style.borderTop = getBorderStyle(format.topBorderColor);\r\n                    cell.td.style.borderBottom = getBorderStyle(format.bottomBorderColor);\r\n                    cell.td.style.borderLeft = getBorderStyle(format.verticalBorderColor);\r\n                    cell.td.style.borderRight = getBorderStyle(format.verticalBorderColor);\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Edit table with given operation.\r\n     * @param operation Table operation\r\n     */\r\n    edit(operation: TableOperation) {\r\n        if (!this.table) {\r\n            return;\r\n        }\r\n\r\n        let currentRow = this.cells[this.row];\r\n        let currentCell = currentRow[this.col];\r\n        switch (operation) {\r\n            case TableOperation.InsertAbove:\r\n                this.cells.splice(this.row, 0, currentRow.map(cloneCell));\r\n                break;\r\n            case TableOperation.InsertBelow:\r\n                let newRow = this.row + this.countSpanAbove(this.row, this.col);\r\n                this.cells.splice(\r\n                    newRow,\r\n                    0,\r\n                    this.cells[newRow - 1].map((cell, colIndex) => {\r\n                        let nextCell = this.getCell(newRow, colIndex);\r\n                        if (nextCell.spanAbove) {\r\n                            return cloneCell(nextCell);\r\n                        } else if (cell.spanLeft) {\r\n                            let newCell = cloneCell(cell);\r\n                            newCell.spanAbove = false;\r\n                            return newCell;\r\n                        } else {\r\n                            return {\r\n                                td: cloneNode(this.getTd(this.row, colIndex)),\r\n                            };\r\n                        }\r\n                    })\r\n                );\r\n                break;\r\n\r\n            case TableOperation.InsertLeft:\r\n                this.forEachCellOfCurrentColumn((cell, row) => {\r\n                    row.splice(this.col, 0, cloneCell(cell));\r\n                });\r\n                break;\r\n            case TableOperation.InsertRight:\r\n                let newCol = this.col + this.countSpanLeft(this.row, this.col);\r\n                this.forEachCellOfColumn(newCol - 1, (cell, row, i) => {\r\n                    let nextCell = this.getCell(i, newCol);\r\n                    let newCell: VCell;\r\n                    if (nextCell.spanLeft) {\r\n                        newCell = cloneCell(nextCell);\r\n                    } else if (cell.spanAbove) {\r\n                        newCell = cloneCell(cell);\r\n                        newCell.spanLeft = false;\r\n                    } else {\r\n                        newCell = {\r\n                            td: cloneNode(this.getTd(i, this.col)),\r\n                        };\r\n                    }\r\n\r\n                    row.splice(newCol, 0, newCell);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.DeleteRow:\r\n                this.forEachCellOfCurrentRow((cell, i) => {\r\n                    let nextCell = this.getCell(this.row + 1, i);\r\n                    if (cell.td && cell.td.rowSpan > 1 && nextCell.spanAbove) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                });\r\n                this.cells.splice(this.row, 1);\r\n                break;\r\n\r\n            case TableOperation.DeleteColumn:\r\n                this.forEachCellOfCurrentColumn((cell, row, i) => {\r\n                    let nextCell = this.getCell(i, this.col + 1);\r\n                    if (cell.td && cell.td.colSpan > 1 && nextCell.spanLeft) {\r\n                        nextCell.td = cell.td;\r\n                    }\r\n                    row.splice(this.col, 1);\r\n                });\r\n                break;\r\n\r\n            case TableOperation.MergeAbove:\r\n            case TableOperation.MergeBelow:\r\n                let rowStep = operation == TableOperation.MergeAbove ? -1 : 1;\r\n                for (\r\n                    let rowIndex = this.row + rowStep;\r\n                    rowIndex >= 0 && rowIndex < this.cells.length;\r\n                    rowIndex += rowStep\r\n                ) {\r\n                    let cell = this.getCell(rowIndex, this.col);\r\n                    if (cell.td && !cell.spanAbove) {\r\n                        let aboveCell = rowIndex < this.row ? cell : currentCell;\r\n                        let belowCell = rowIndex < this.row ? currentCell : cell;\r\n                        if (aboveCell.td.colSpan == belowCell.td.colSpan) {\r\n                            moveChildren(belowCell.td, aboveCell.td);\r\n                            belowCell.td = null;\r\n                            belowCell.spanAbove = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.MergeLeft:\r\n            case TableOperation.MergeRight:\r\n                let colStep = operation == TableOperation.MergeLeft ? -1 : 1;\r\n                for (\r\n                    let colIndex = this.col + colStep;\r\n                    colIndex >= 0 && colIndex < this.cells[this.row].length;\r\n                    colIndex += colStep\r\n                ) {\r\n                    let cell = this.getCell(this.row, colIndex);\r\n                    if (cell.td && !cell.spanLeft) {\r\n                        let leftCell = colIndex < this.col ? cell : currentCell;\r\n                        let rightCell = colIndex < this.col ? currentCell : cell;\r\n                        if (leftCell.td.rowSpan == rightCell.td.rowSpan) {\r\n                            moveChildren(rightCell.td, leftCell.td);\r\n                            rightCell.td = null;\r\n                            rightCell.spanLeft = true;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case TableOperation.DeleteTable:\r\n                this.cells = null;\r\n                break;\r\n\r\n            case TableOperation.SplitVertically:\r\n                if (currentCell.td.rowSpan > 1) {\r\n                    this.getCell(this.row + 1, this.col).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    let splitRow = currentRow.map(cell => {\r\n                        return {\r\n                            td: cell == currentCell ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell != currentCell,\r\n                            spanLeft: cell.spanLeft,\r\n                        };\r\n                    });\r\n                    this.cells.splice(this.row + 1, 0, splitRow);\r\n                }\r\n                break;\r\n\r\n            case TableOperation.SplitHorizontally:\r\n                if (currentCell.td.colSpan > 1) {\r\n                    this.getCell(this.row, this.col + 1).td = cloneNode(currentCell.td);\r\n                } else {\r\n                    this.forEachCellOfCurrentColumn((cell, row) => {\r\n                        row.splice(this.col + 1, 0, {\r\n                            td: row == currentRow ? cloneNode(cell.td) : null,\r\n                            spanAbove: cell.spanAbove,\r\n                            spanLeft: row != currentRow,\r\n                        });\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current column and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => any) {\r\n        this.forEachCellOfColumn(this.col, callback);\r\n    }\r\n\r\n    /**\r\n     * Loop each cell of current row and invoke a callback function\r\n     * @param callback The callback function to invoke\r\n     */\r\n    forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => any) {\r\n        this.forEachCellOfRow(this.row, callback);\r\n    }\r\n\r\n    /**\r\n     * Get a table cell using its row and column index. This function will always return an object\r\n     * even if the given indexes don't exist in table.\r\n     * @param row The row index\r\n     * @param col The column index\r\n     */\r\n    getCell(row: number, col: number): VCell {\r\n        return (this.cells && this.cells[row] && this.cells[row][col]) || {};\r\n    }\r\n\r\n    /**\r\n     * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell\r\n     */\r\n    getCurrentTd(): HTMLTableCellElement {\r\n        return this.getTd(this.row, this.col);\r\n    }\r\n\r\n    private getTd(row: number, col: number) {\r\n        if (this.cells) {\r\n            row = Math.min(this.cells.length - 1, row);\r\n            col = this.cells[row] ? Math.min(this.cells[row].length - 1, col) : col;\r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                while (row >= 0 && col >= 0) {\r\n                    let cell = this.getCell(row, col);\r\n                    if (cell.td) {\r\n                        return cell.td;\r\n                    } else if (cell.spanLeft) {\r\n                        col--;\r\n                    } else if (cell.spanAbove) {\r\n                        row--;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private forEachCellOfColumn(\r\n        col: number,\r\n        callback: (cell: VCell, row: VCell[], i: number) => any\r\n    ) {\r\n        for (let i = 0; i < this.cells.length; i++) {\r\n            callback(this.getCell(i, col), this.cells[i], i);\r\n        }\r\n    }\r\n\r\n    private forEachCellOfRow(row: number, callback: (cell: VCell, i: number) => any) {\r\n        for (let i = 0; i < this.cells[row].length; i++) {\r\n            callback(this.getCell(row, i), i);\r\n        }\r\n    }\r\n\r\n    private recalcSpans(row: number, col: number) {\r\n        let td = this.getCell(row, col).td;\r\n        if (td) {\r\n            td.colSpan = this.countSpanLeft(row, col);\r\n            td.rowSpan = this.countSpanAbove(row, col);\r\n            if (td.colSpan == 1) {\r\n                td.removeAttribute('colSpan');\r\n            }\r\n            if (td.rowSpan == 1) {\r\n                td.removeAttribute('rowSpan');\r\n            }\r\n        }\r\n    }\r\n\r\n    private countSpanLeft(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = col + 1; i < this.cells[row].length; i++) {\r\n            let cell = this.getCell(row, i);\r\n            if (cell.td || !cell.spanLeft) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private countSpanAbove(row: number, col: number) {\r\n        let result = 1;\r\n        for (let i = row + 1; i < this.cells.length; i++) {\r\n            let cell = this.getCell(i, col);\r\n            if (cell.td || !cell.spanAbove) {\r\n                break;\r\n            }\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getTableFromTd(td: HTMLTableCellElement) {\r\n    let result = <HTMLElement>td;\r\n    for (; result && result.tagName != 'TABLE'; result = result.parentElement) {}\r\n    return <HTMLTableElement>result;\r\n}\r\n\r\nfunction getBorderStyle(style: string): string {\r\n    return 'solid 1px ' + (style || 'transparent');\r\n}\r\n\r\n/**\r\n * Clone a table cell\r\n * @param cell The cell to clone\r\n */\r\nfunction cloneCell(cell: VCell): VCell {\r\n    return {\r\n        td: cloneNode(cell.td),\r\n        spanAbove: cell.spanAbove,\r\n        spanLeft: cell.spanLeft,\r\n    };\r\n}\r\n\r\n/**\r\n * Clone a node without its children.\r\n * @param node The node to clone\r\n */\r\nfunction cloneNode<T extends Node>(node: T): T {\r\n    let newNode = node ? <T>node.cloneNode(false /*deep*/) : null;\r\n    if (safeInstanceOf(newNode, 'HTMLTableCellElement')) {\r\n        newNode.removeAttribute('id');\r\n        if (!newNode.firstChild) {\r\n            newNode.appendChild(node.ownerDocument.createElement('br'));\r\n        }\r\n    }\r\n    return newNode;\r\n}\r\n\r\n/**\r\n * Move all children from one node to another\r\n * @param fromNode The source node to move children from\r\n * @param toNode Target node. If not passed, children nodes of source node will be removed\r\n */\r\nfunction moveChildren(fromNode: Node, toNode?: Node) {\r\n    while (fromNode.firstChild) {\r\n        if (toNode) {\r\n            toNode.appendChild(fromNode.firstChild);\r\n        } else {\r\n            fromNode.removeChild(fromNode.firstChild);\r\n        }\r\n    }\r\n}\r\n","import contains from '../utils/contains';\r\nimport getListTypeFromNode from './getListTypeFromNode';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isBlockElement from '../utils/isBlockElement';\r\nimport toArray from '../utils/toArray';\r\nimport unwrap from '../utils/unwrap';\r\nimport wrap from '../utils/wrap';\r\nimport { ListType } from 'roosterjs-editor-types';\r\n\r\nconst orderListStyles = [null, 'lower-alpha', 'lower-roman'];\r\n\r\n/**\r\n * @internal\r\n * !!! Never directly create instance of this class. It should be created within VList class !!!\r\n *\r\n * Represent a list item.\r\n *\r\n * A list item is normally wrapped using a LI tag. But this class is only a logical item,\r\n * it can be a LI tag, or another other type of node which means it is actually not a list item.\r\n * That can happen after we do \"outdent\" on a 1-level list item, then it becomes not a list item.\r\n * @internal\r\n */\r\nexport default class VListItem {\r\n    private listTypes: ListType[];\r\n\r\n    /**\r\n     * Construct a new instance of VListItem class\r\n     * @param node The DOM node for this item\r\n     * @param listTypes An array represnets list types of all parent and current level.\r\n     * Skip this parameter for a non-list item.\r\n     */\r\n    constructor(private node: Node, ...listTypes: (ListType.Ordered | ListType.Unordered)[]) {\r\n        if (!node) {\r\n            throw new Error('node must not be null');\r\n        }\r\n\r\n        // Always add a None list type in front of all other types to represent non-list scenario.\r\n        this.listTypes = [ListType.None, ...listTypes];\r\n    }\r\n\r\n    /**\r\n     * Get type of current list item\r\n     */\r\n    getListType(): ListType {\r\n        return this.listTypes[this.listTypes.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Get the levels of this list item.\r\n     */\r\n    getLevel(): number {\r\n        return this.listTypes.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Get DOM node of this list item\r\n     */\r\n    getNode(): Node {\r\n        return this.node;\r\n    }\r\n\r\n    /**\r\n     * Check if a given node is contained by this list item\r\n     * @param node The node to check\r\n     */\r\n    contains(node: Node): boolean {\r\n        return contains(this.node, node, true /*treateSameNodeAsContain*/);\r\n    }\r\n\r\n    /**\r\n     * Check if this item is an orphan item.\r\n     *\r\n     * Orphan item is not a normal case but could happen. It represents the DOM nodes directly under OL/UL tag\r\n     * and are in front of all other LI tags so that they cannot be merged into any existing LI tags.\r\n     *\r\n     * For example:\r\n     * ```html\r\n     * <ol>\r\n     *   <div>Orphan node</div>\r\n     *   <li>first item</li>\r\n     * </ol>\r\n     * ```\r\n     * Here the first DIV tag is an orphan item.\r\n     *\r\n     * There can also be nodes directly under OL/UL but between other LI tags in source HTML which should not be\r\n     * treated as orphan item because they can be merged into their previous LI tag. But when we build VList,\r\n     * those nodes will be merged into LI, so that ideally here they should not exist.\r\n     */\r\n    isOrphanItem(): boolean {\r\n        return getTagOfNode(this.node) != 'LI';\r\n    }\r\n\r\n    /**\r\n     * Check if the given item can be merged into this item.\r\n     * An item can be merged when it is an orphan item and its list type stack is exactly the same with current one.\r\n     * @param item The item to check\r\n     */\r\n    canMerge(item: VListItem): boolean {\r\n        if (!item?.isOrphanItem() || this.listTypes.length != item.listTypes.length) {\r\n            return false;\r\n        }\r\n\r\n        return this.listTypes.every((type, index) => item.listTypes[index] == type);\r\n    }\r\n\r\n    /**\r\n     * Merge items into this item.\r\n     * @example Before merge:\r\n     * ```html\r\n     * <ol>\r\n     *   <li>Current item</li>\r\n     *   <div>line 1</div>\r\n     *   <div>line 2</div>\r\n     * </ol>\r\n     * ```\r\n     * After merge then two DIVs into LI:\r\n     * ```html\r\n     * <ol>\r\n     *   <li>Current item\r\n     *     <div>line 1</div>\r\n     *     <div>line 2</div>\r\n     *   </li>\r\n     * </ol>\r\n     * ```\r\n     * @param items The items to merge\r\n     */\r\n    mergeItems(items: VListItem[]) {\r\n        const nodesToWrap = items?.map(item => item.node) || [];\r\n        const targetNodes = wrapIfNotBlockNode(\r\n            nodesToWrap,\r\n            true /*checkFirst*/,\r\n            false /*checkLast*/\r\n        );\r\n        targetNodes.forEach(node => this.node.appendChild(node));\r\n    }\r\n\r\n    /**\r\n     * Indent this item\r\n     * If this is not an list item, it will be no op\r\n     */\r\n    indent() {\r\n        const listType = this.getListType();\r\n        if (listType != ListType.None) {\r\n            this.listTypes.push(listType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Outdent this item\r\n     * If this item is already not an list item, it will be no op\r\n     */\r\n    outdent() {\r\n        if (this.listTypes.length > 1) {\r\n            this.listTypes.pop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change list type of this item\r\n     * @param targetType The target list type to change to\r\n     */\r\n    changeListType(targetType: ListType) {\r\n        if (targetType == ListType.None) {\r\n            this.listTypes = [targetType];\r\n        } else {\r\n            this.outdent();\r\n            this.listTypes.push(targetType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write the change result back into DOM\r\n     * @param listStack current stack of list elements\r\n     * @param originalRoot Original list root element. It will be reused when write back if possible\r\n     */\r\n    writeBack(listStack: Node[], originalRoot?: HTMLOListElement | HTMLUListElement) {\r\n        let nextLevel = 1;\r\n\r\n        // 1. Determine list elements that we can reuse\r\n        // e.g.:\r\n        //    passed in listStack: Fragment > OL > UL > OL\r\n        //    local listTypes:     null     > OL > UL > UL > OL\r\n        //    then Fragment > OL > UL can be reused\r\n        for (; nextLevel < listStack.length; nextLevel++) {\r\n            if (getListTypeFromNode(listStack[nextLevel]) !== this.listTypes[nextLevel]) {\r\n                listStack.splice(nextLevel);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // 2. Add new list elements\r\n        // e.g.:\r\n        //    passed in listStack: Fragment > OL > UL\r\n        //    local listTypes:     null     > OL > UL > UL > OL\r\n        //    then we need to create a UL and a OL tag\r\n        for (; nextLevel < this.listTypes.length; nextLevel++) {\r\n            const newList = createListElement(\r\n                listStack[0],\r\n                this.listTypes[nextLevel],\r\n                nextLevel,\r\n                originalRoot\r\n            );\r\n\r\n            listStack[listStack.length - 1].appendChild(newList);\r\n            listStack.push(newList);\r\n        }\r\n\r\n        // 3. Add current node into deepest list element\r\n        listStack[listStack.length - 1].appendChild(this.node);\r\n\r\n        // 4. If this is not a list item now, need to unwrap the LI node and do proper handling\r\n        if (this.listTypes.length <= 1) {\r\n            wrapIfNotBlockNode(\r\n                getTagOfNode(this.node) == 'LI' ? getChildrenAndUnwrap(this.node) : [this.node],\r\n                true /*checkFirst*/,\r\n                true /*checkLast*/\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction createListElement(\r\n    newRoot: Node,\r\n    listType: ListType,\r\n    nextLevel: number,\r\n    originalRoot?: HTMLOListElement | HTMLUListElement\r\n): HTMLOListElement | HTMLUListElement {\r\n    const doc = newRoot.ownerDocument;\r\n    let result: HTMLOListElement | HTMLUListElement;\r\n\r\n    // Try to reuse the existing root element\r\n    // It can be reused when\r\n    // 1. Current list item is level 1 (top level), AND\r\n    // 2. Original root exists, AND\r\n    // 3. They have the same list type AND\r\n    // 4. The original root is not used yet\r\n    if (nextLevel == 1 && originalRoot && listType == getListTypeFromNode(originalRoot)) {\r\n        if (contains(newRoot, originalRoot)) {\r\n            // If it is already used, let's clone one and remove ID to avoid duplicating ID\r\n            result = originalRoot.cloneNode(false /*deep*/) as HTMLOListElement | HTMLUListElement;\r\n            (<HTMLOListElement>result).removeAttribute('id');\r\n        } else {\r\n            // Remove all child nodes, they will be added back later when write back other items\r\n            while (originalRoot.firstChild) {\r\n                originalRoot.removeChild(originalRoot.firstChild);\r\n            }\r\n            result = originalRoot;\r\n        }\r\n    } else {\r\n        // Can't be reused, can't clone, let's create a new one\r\n        result = doc.createElement(listType == ListType.Ordered ? 'ol' : 'ul');\r\n    }\r\n\r\n    if (listType == ListType.Ordered && nextLevel > 1) {\r\n        result.style.listStyleType = orderListStyles[(nextLevel - 1) % orderListStyles.length];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction wrapIfNotBlockNode(nodes: Node[], checkFirst: boolean, checkLast: boolean): Node[] {\r\n    if (\r\n        nodes.length > 0 &&\r\n        (!checkFirst || !isBlockElement(nodes[0])) &&\r\n        (!checkLast || !isBlockElement(nodes[nodes.length]))\r\n    ) {\r\n        nodes = [wrap(nodes)];\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nfunction getChildrenAndUnwrap(node: Node): Node[] {\r\n    const result = toArray(node.childNodes);\r\n    unwrap(node);\r\n    return result;\r\n}\r\n","import fromHtml from '../utils/fromHtml';\r\nimport getRootListNode from './getRootListNode';\r\nimport getSelectedBlockElementsInRegion from '../region/getSelectedBlockElementsInRegion';\r\nimport isNodeInRegion from '../region/isNodeInRegion';\r\nimport Position from '../selection/Position';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport shouldSkipNode from '../utils/shouldSkipNode';\r\nimport toArray from '../utils/toArray';\r\nimport VList from './VList';\r\nimport wrap from '../utils/wrap';\r\nimport { getLeafSibling } from '../utils/getLeafSibling';\r\nimport { isListElement } from './getListTypeFromNode';\r\nimport { ListType, Region } from 'roosterjs-editor-types';\r\nimport { PositionType } from 'roosterjs-editor-types';\r\n\r\nconst ListSelector = 'ol,ul';\r\n\r\n/**\r\n * @internal\r\n * @param region The region to get VList from\r\n * @param includeSiblingLists True to also try get lists before and after the selection and merge them together,\r\n * false to only include the list for the selected blocks\r\n * @param startNode (Optional) When specified, try get VList which will contain this node.\r\n * If not specified, get VList from selection of this region\r\n */\r\nexport default function createVListFromRegion(\r\n    region: Region,\r\n    includeSiblingLists?: boolean,\r\n    startNode?: Node\r\n): VList {\r\n    if (!region) {\r\n        return null;\r\n    }\r\n\r\n    let nodes: Node[] = [];\r\n\r\n    if (startNode) {\r\n        const list = getRootListNode(region, ListSelector, startNode);\r\n        if (list) {\r\n            nodes.push(list);\r\n        }\r\n    } else {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        blocks.forEach(block => {\r\n            const list = getRootListNode(region, ListSelector, block.getStartNode());\r\n\r\n            if (list) {\r\n                if (nodes[nodes.length - 1] != list) {\r\n                    nodes.push(list);\r\n                }\r\n                if (\r\n                    nodes.length == 1 &&\r\n                    safeInstanceOf(list, 'HTMLOListElement') &&\r\n                    list.start > 1\r\n                ) {\r\n                    // Do not include sibling lists if this list is not start from 1\r\n                    includeSiblingLists = false;\r\n                }\r\n            } else {\r\n                nodes.push(block.collapseToSingleElement());\r\n            }\r\n        });\r\n\r\n        if (nodes.length == 0 && !region.rootNode.firstChild) {\r\n            const newNode = fromHtml('<div><br></div>', region.rootNode.ownerDocument)[0];\r\n            region.rootNode.appendChild(newNode);\r\n            nodes.push(newNode);\r\n            region.fullSelectionStart = new Position(newNode, PositionType.Begin);\r\n            region.fullSelectionEnd = new Position(newNode, PositionType.End);\r\n        }\r\n\r\n        if (includeSiblingLists) {\r\n            tryIncludeSiblingNode(region, nodes, false /*isNext*/);\r\n            tryIncludeSiblingNode(region, nodes, true /*isNext*/);\r\n        }\r\n\r\n        nodes = nodes.filter(node => !shouldSkipNode(node, true /*ignoreSpace*/));\r\n    }\r\n\r\n    let vList: VList = null;\r\n\r\n    if (nodes.length > 0) {\r\n        const firstNode = nodes.shift();\r\n        vList = isListElement(firstNode)\r\n            ? new VList(firstNode)\r\n            : createVListFromItemNode(firstNode);\r\n\r\n        nodes.forEach(node => {\r\n            if (isListElement(node)) {\r\n                vList.mergeVList(new VList(node));\r\n            } else {\r\n                vList.appendItem(node, ListType.None);\r\n            }\r\n        });\r\n    }\r\n\r\n    return vList;\r\n}\r\n\r\nfunction tryIncludeSiblingNode(region: Region, nodes: Node[], isNext: boolean) {\r\n    let node = nodes[isNext ? nodes.length - 1 : 0];\r\n    node = getLeafSibling(region.rootNode, node, isNext, region.skipTags, true /*ignoreSpace*/);\r\n    node = getRootListNode(region, ListSelector, node);\r\n    if (isNodeInRegion(region, node) && isListElement(node)) {\r\n        if (isNext) {\r\n            if (!safeInstanceOf(node, 'HTMLOListElement') || node.start == 1) {\r\n                // Only include sibling list when\r\n                // 1. This is a unordered list, OR\r\n                // 2. This list starts from 1\r\n                nodes.push(node);\r\n            }\r\n        } else {\r\n            nodes.unshift(node);\r\n        }\r\n    }\r\n}\r\n\r\nfunction createVListFromItemNode(node: Node): VList {\r\n    // Wrap all child nodes under a single one, and put the new list under original root node\r\n    // so that the list can carry over styles under the root node.\r\n    const childNodes = toArray(node.childNodes);\r\n    const nodeForItem = childNodes.length == 1 ? childNodes[0] : wrap(childNodes, 'SPAN');\r\n\r\n    // Create a temporary OL root element for this list.\r\n    const listNode = node.ownerDocument.createElement('ol'); // Either OL or UL is ok here\r\n    node.appendChild(listNode);\r\n\r\n    // Create the VList and append items\r\n    const vList = new VList(listNode);\r\n    vList.appendItem(nodeForItem, ListType.None);\r\n\r\n    return vList;\r\n}\r\n","import arrayPush from '../utils/arrayPush';\r\nimport getRootListNode from './getRootListNode';\r\nimport isNodeAfter from '../utils/isNodeAfter';\r\nimport isNodeInRegion from '../region/isNodeInRegion';\r\nimport queryElements from '../utils/queryElements';\r\nimport VList from './VList';\r\nimport { ListType, RegionBase } from 'roosterjs-editor-types';\r\n\r\nconst CHAIN_NAME_PREFIX = '__List_Chain_';\r\nconst CHAIN_DATASET_NAME = 'listchain';\r\nconst AFTER_CURSOR_DATASET_NAME = 'listchainafter';\r\nlet lastChainIndex = 0;\r\n\r\n/**\r\n * Represent a chain of list nodes.\r\n * A chain of lists is a virtual link of lists that have continuous numbers, when editor one of them,\r\n * all others should also be updated in order to main the list number to be continuous.\r\n */\r\nexport default class VListChain {\r\n    private lastNumber = 0;\r\n    private lastNumberBeforeCursor = 0;\r\n\r\n    /**\r\n     * Create an array of VListChain from current region in editor\r\n     * @param region The region to create VListChain from\r\n     * @param currentNode Optional current node, used for mark lists that are after this node\r\n     * @param nameGenerator Used by test code only\r\n     */\r\n    static createListChains(\r\n        region: RegionBase | RegionBase[],\r\n        currentNode?: Node,\r\n        nameGenerator?: () => string\r\n    ): VListChain[] {\r\n        const regions = Array.isArray(region) ? region : region ? [region] : [];\r\n        const result: VListChain[] = [];\r\n        regions.forEach(region => {\r\n            const chains: VListChain[] = [];\r\n            let lastList: HTMLOListElement;\r\n\r\n            queryElements(region.rootNode, 'ol', ol => {\r\n                const list = getRootListNode(region, 'ol', ol);\r\n\r\n                if (lastList != list) {\r\n                    const chain =\r\n                        chains.filter(c => c.canAppendToTail(list))[0] ||\r\n                        new VListChain(region, (nameGenerator || createListChainName)());\r\n                    const index = chains.indexOf(chain);\r\n                    const afterCurrentNode = currentNode && isNodeAfter(list, currentNode);\r\n\r\n                    if (!afterCurrentNode) {\r\n                        // Make sure current one is at the front if current block has not been met, so that\r\n                        // the first chain is always the nearest one from current node\r\n                        if (index >= 0) {\r\n                            chains.splice(index, 1);\r\n                        }\r\n\r\n                        chains.unshift(chain);\r\n                    } else if (index < 0) {\r\n                        chains.push(chain);\r\n                    }\r\n\r\n                    chain.append(list, afterCurrentNode);\r\n                    lastList = list;\r\n                }\r\n            });\r\n\r\n            arrayPush(result, chains);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a list with the given start number can be appended next to the last list before cursor\r\n     * @param startNumber The start number of the new list\r\n     */\r\n    canAppendAtCursor(startNumber: number): boolean {\r\n        return this.lastNumberBeforeCursor + 1 == startNumber;\r\n    }\r\n\r\n    /**\r\n     * Create a VList to wrap the block of the given node, and append to current chain\r\n     * @param container The container node to create list at\r\n     * @param startNumber Start number of the new list\r\n     */\r\n    createVListAtBlock(container: Node, startNumber: number): VList {\r\n        if (container) {\r\n            const list = container.ownerDocument.createElement('ol');\r\n\r\n            list.start = startNumber;\r\n            this.applyChainName(list);\r\n            container.parentNode.insertBefore(list, container);\r\n\r\n            const vList = new VList(list);\r\n\r\n            vList.appendItem(container, ListType.None);\r\n            return vList;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * After change the lists, commit the change to all lists in this chain to update the list number,\r\n     * and clear the temporary dataset values added to list node\r\n     */\r\n    commit() {\r\n        const lists = this.getLists();\r\n        let lastNumber = 0;\r\n\r\n        for (let i = 0; i < lists.length; i++) {\r\n            const list = lists[i];\r\n            list.start = lastNumber + 1;\r\n\r\n            const vlist = new VList(list);\r\n\r\n            lastNumber = vlist.getLastItemNumber();\r\n\r\n            delete list.dataset[CHAIN_DATASET_NAME];\r\n            delete list.dataset[AFTER_CURSOR_DATASET_NAME];\r\n\r\n            vlist.writeBack();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Contruct a new instance of VListChain class\r\n     * @param editor Editor object\r\n     */\r\n    private constructor(private region: RegionBase, private name: string) {}\r\n\r\n    /**\r\n     * Check if the given list node is can be appended into current list chain\r\n     * @param list The list node to check\r\n     */\r\n    private canAppendToTail(list: HTMLOListElement) {\r\n        return this.lastNumber + 1 == list.start;\r\n    }\r\n\r\n    /**\r\n     * Append the given list node into this VListChain\r\n     * @param list The list node to append\r\n     * @param isAfterCurrentNode Whether this list is after current node\r\n     */\r\n    private append(list: HTMLOListElement, isAfterCurrentNode: boolean) {\r\n        this.applyChainName(list);\r\n        this.lastNumber = new VList(list).getLastItemNumber();\r\n\r\n        if (isAfterCurrentNode) {\r\n            list.dataset[AFTER_CURSOR_DATASET_NAME] = 'true';\r\n        } else {\r\n            this.lastNumberBeforeCursor = this.lastNumber;\r\n        }\r\n    }\r\n\r\n    private applyChainName(list: HTMLOListElement) {\r\n        list.dataset[CHAIN_DATASET_NAME] = this.name;\r\n    }\r\n\r\n    private getLists() {\r\n        return queryElements(\r\n            this.region.rootNode,\r\n            `ol[data-${CHAIN_DATASET_NAME}=${this.name}]`\r\n        ).filter(node => isNodeInRegion(this.region, node)) as HTMLOListElement[];\r\n    }\r\n}\r\n\r\nfunction createListChainName() {\r\n    return CHAIN_NAME_PREFIX + lastChainIndex++;\r\n}\r\n","import { RegionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Constants for each region type\r\n */\r\nexport interface RegionTypeData {\r\n    /**\r\n     * Tags that child elements will be skipped\r\n     */\r\n    skipTags: string[];\r\n\r\n    /**\r\n     * Selector of outer node of a region\r\n     */\r\n    outerSelector: string;\r\n\r\n    /**\r\n     * Selector of inner node of a region\r\n     */\r\n    innerSelector: string;\r\n}\r\n\r\nconst regionTypeData: Record<RegionType, RegionTypeData> = {\r\n    [RegionType.Table]: {\r\n        skipTags: ['TABLE'],\r\n        outerSelector: 'table',\r\n        innerSelector: 'td,th',\r\n    },\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default regionTypeData;\r\n","import createRange from './createRange';\r\nimport normalizeRect from '../utils/normalizeRect';\r\nimport { NodePosition, NodeType, Rect } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get bounding rect of this position\r\n * @param position The positioin to get rect from\r\n */\r\nexport default function getPositionRect(position: NodePosition): Rect {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n\r\n    let range = createRange(position);\r\n\r\n    // 1) try to get rect using range.getBoundingClientRect()\r\n    let rect = range.getBoundingClientRect && normalizeRect(range.getBoundingClientRect());\r\n\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 2) try to get rect using range.getClientRects\r\n    position = position.normalize();\r\n    const rects = range.getClientRects && range.getClientRects();\r\n    rect = rects && rects.length == 1 && normalizeRect(rects[0]);\r\n    if (rect) {\r\n        return rect;\r\n    }\r\n\r\n    // 3) if node is text node, try inserting a SPAN and get the rect of SPAN for others\r\n    if (position.node.nodeType == NodeType.Text) {\r\n        const document = position.node.ownerDocument;\r\n        let span = document.createElement('SPAN');\r\n        span.innerHTML = '\\u200b';\r\n        range = createRange(position);\r\n        range.insertNode(span);\r\n        rect = span.getBoundingClientRect && normalizeRect(span.getBoundingClientRect());\r\n        span.parentNode.removeChild(span);\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    // 4) try getBoundingClientRect on element\r\n    let element = position.element;\r\n    if (element && element.getBoundingClientRect) {\r\n        rect = normalizeRect(element.getBoundingClientRect());\r\n        if (rect) {\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n","import contains from '../utils/contains';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport isNodeEmpty from '../utils/isNodeEmpty';\r\nimport { NodePosition } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Check if this position is at beginning of the given node.\r\n * This will return true if all nodes between the beginning of target node and the position are empty.\r\n * @param position The position to check\r\n * @param targetNode The node to check\r\n * @returns True if position is at beginning of the node, otherwise false\r\n */\r\nexport default function isPositionAtBeginningOf(position: NodePosition, targetNode: Node) {\r\n    if (position) {\r\n        let { node, offset } = position.normalize();\r\n        if (offset == 0) {\r\n            while (contains(targetNode, node) && areAllPrevousNodesEmpty(node)) {\r\n                node = node.parentNode;\r\n            }\r\n\r\n            return node == targetNode;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction areAllPrevousNodesEmpty(node: Node): boolean {\r\n    while (node.previousSibling) {\r\n        node = node.previousSibling;\r\n        if (getTagOfNode(node) == 'BR' || !isNodeEmpty(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import getSelectionPath from './getSelectionPath';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport queryElements from '../utils/queryElements';\r\n\r\n/**\r\n * Get inner Html of a root node with a selection path which can be used for restore selection.\r\n * The result string can be used by setHtmlWithSelectionPath() to restore the HTML and selection.\r\n * @param rootNode Root node to get inner Html from\r\n * @param range The range of selection. If pass null, no selection path will be added\r\n * @returns Inner HTML of the root node, followed by HTML comment contains selection path if the given range is valid\r\n */\r\nexport default function getHtmlWithSelectionPath(rootNode: HTMLElement, range: Range): string {\r\n    if (!rootNode) {\r\n        return '';\r\n    }\r\n\r\n    const { startContainer, endContainer, startOffset, endOffset } = range || {};\r\n    let isDOMChanged = false;\r\n\r\n    queryElements(rootNode, 'table', table => {\r\n        let tbody: HTMLTableSectionElement = null;\r\n\r\n        for (let child = table.firstChild; child; child = child.nextSibling) {\r\n            if (getTagOfNode(child) == 'TR') {\r\n                if (!tbody) {\r\n                    tbody = table.ownerDocument.createElement('tbody');\r\n                    table.insertBefore(tbody, child);\r\n                }\r\n\r\n                tbody.appendChild(child);\r\n                child = tbody;\r\n\r\n                isDOMChanged = true;\r\n            } else {\r\n                tbody = null;\r\n            }\r\n        }\r\n    });\r\n\r\n    if (range && isDOMChanged) {\r\n        try {\r\n            range.setStart(startContainer, startOffset);\r\n            range.setEnd(endContainer, endOffset);\r\n        } catch {}\r\n    }\r\n\r\n    const content = rootNode.innerHTML;\r\n    const selectionPath = range && getSelectionPath(rootNode, range);\r\n\r\n    return selectionPath ? `${content}<!--${JSON.stringify(selectionPath)}-->` : content;\r\n}\r\n","import createRange from './createRange';\r\nimport { NodeType, SelectionPath } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Restore inner Html of a root element from given html string. If the string contains selection path,\r\n * remove the selection path and return a range represented by the path\r\n * @param root The root element\r\n * @param html The html to restore\r\n * @returns A selection range if the html contains a valid selection path, otherwise null\r\n */\r\nexport default function setHtmlWithSelectionPath(rootNode: HTMLElement, html: string): Range {\r\n    rootNode.innerHTML = html || '';\r\n    let path: SelectionPath = null;\r\n    let pathComment = rootNode.lastChild;\r\n\r\n    try {\r\n        path =\r\n            pathComment &&\r\n            pathComment.nodeType == NodeType.Comment &&\r\n            (JSON.parse(pathComment.nodeValue) as SelectionPath);\r\n        if (path && path.end && path.end.length > 0 && path.start && path.start.length > 0) {\r\n            rootNode.removeChild(pathComment);\r\n        } else {\r\n            path = null;\r\n        }\r\n    } catch {}\r\n\r\n    return path && createRange(rootNode, path.start, path.end);\r\n}\r\n","import { Browser } from '../utils/Browser';\r\n\r\n/**\r\n * Add the given range into selection of the given document\r\n * @param range The range to select\r\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection,\r\n * otherwise it will always remove current selection ranage and set to the given one.\r\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\r\n */\r\nexport default function addRangeToSelection(range: Range, skipSameRange?: boolean) {\r\n    const selection = range?.commonAncestorContainer?.ownerDocument?.defaultView?.getSelection();\r\n    if (selection) {\r\n        let needAddRange = true;\r\n\r\n        if (selection.rangeCount > 0) {\r\n            // Workaround IE exception 800a025e\r\n            try {\r\n                let currentRange: Range;\r\n                // Do not remove/add range if current selection is the same with target range\r\n                // Without this check, execCommand() may fail in Edge since we changed the selection\r\n                if (\r\n                    (skipSameRange || Browser.isEdge) &&\r\n                    (currentRange = selection.rangeCount == 1 ? selection.getRangeAt(0) : null) &&\r\n                    currentRange.startContainer == range.startContainer &&\r\n                    currentRange.startOffset == range.startOffset &&\r\n                    currentRange.endContainer == range.endContainer &&\r\n                    currentRange.endOffset == range.endOffset\r\n                ) {\r\n                    needAddRange = false;\r\n                } else {\r\n                    selection.removeAllRanges();\r\n                }\r\n            } catch (e) {}\r\n        }\r\n\r\n        if (needAddRange) {\r\n            selection.addRange(range);\r\n        }\r\n    }\r\n}\r\n","import arrayPush from '../utils/arrayPush';\r\nimport collapseNodesInRegion from '../region/collapseNodesInRegion';\r\nimport getRegionsFromRange from '../region/getRegionsFromRange';\r\nimport getSelectionRangeInRegion from '../region/getSelectionRangeInRegion';\r\nimport mergeBlocksInRegion from '../region/mergeBlocksInRegion';\r\nimport Position from './Position';\r\nimport queryElements from '../utils/queryElements';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport splitTextNode from '../utils/splitTextNode';\r\nimport { PositionType, QueryScope, RegionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Delete selected content, and return the new positon to select\r\n * @param core The EditorCore object.\r\n * @param range The range to delete\r\n */\r\nexport default function deleteSelectedContent(root: HTMLElement, range: Range) {\r\n    let nodeBefore: Node = null;\r\n\r\n    // 1. TABLE and TR node in selected should be deleted. It is possible we don't detecte them from step 2\r\n    // since table cells will fall in to different regions\r\n    const nodesToDelete: Node[] = queryElements(\r\n        root,\r\n        'table,tr',\r\n        null /*callback*/,\r\n        QueryScope.InSelection,\r\n        range\r\n    );\r\n\r\n    // 2. Loop all selected regions, find out those nodes need to be deleted and merged.\r\n    // We don't delete them directly here because delete node from one region may cause selection range\r\n    // another region becomes invalid. So we delay the process of deletion.\r\n    const regions = getRegionsFromRange(root, range, RegionType.Table);\r\n    const nodesPairToMerge = regions\r\n        .map(region => {\r\n            const regionRange = getSelectionRangeInRegion(region);\r\n            if (!regionRange) {\r\n                return null;\r\n            }\r\n\r\n            const { startContainer, endContainer, startOffset, endOffset } = regionRange;\r\n\r\n            // Make sure there are node before and after the merging point.\r\n            // This is required by mergeBlocksInRegion API.\r\n            // This may create some empty text node as anchor\r\n            let [beforeEnd, afterEnd] = ensureBeforeAndAfter(\r\n                endContainer,\r\n                endOffset,\r\n                false /*isStart*/\r\n            );\r\n            let [beforeStart, afterStart] = ensureBeforeAndAfter(\r\n                startContainer,\r\n                startOffset,\r\n                true /*isStart*/\r\n            );\r\n            nodeBefore = nodeBefore || beforeStart;\r\n\r\n            // Find out all nodes to be deleted\r\n            const nodes = collapseNodesInRegion(region, [afterStart, beforeEnd]);\r\n            arrayPush(nodesToDelete, nodes);\r\n            return { region, beforeStart, afterEnd };\r\n        })\r\n        .filter(x => !!x);\r\n\r\n    // 3. Delete all nodes that we found\r\n    nodesToDelete.forEach(node => node.parentNode?.removeChild(node));\r\n\r\n    // 4. Merge lines for each region, so that after we don't see extra line breaks\r\n    nodesPairToMerge.forEach(nodes =>\r\n        mergeBlocksInRegion(nodes.region, nodes.beforeStart, nodes.afterEnd)\r\n    );\r\n\r\n    return nodeBefore && new Position(nodeBefore, PositionType.End);\r\n}\r\n\r\nfunction ensureBeforeAndAfter(node: Node, offset: number, isStart: boolean) {\r\n    if (safeInstanceOf(node, 'Text')) {\r\n        const newNode = splitTextNode(node, offset, isStart);\r\n        return isStart ? [newNode, node] : [node, newNode];\r\n    } else {\r\n        let nodeBefore: Node = node.childNodes[offset - 1];\r\n        let nodeAfter: Node = node.childNodes[offset];\r\n\r\n        // Condition 1: node child nodes\r\n        // (\"I\" means cursor; \"o\" means a DOM node, \"[ ]\" means a parent node)\r\n        // [ I ]\r\n        // need to use parent node instead to convert to condition 2\r\n        if (!nodeBefore && !nodeAfter) {\r\n            if (isStart) {\r\n                nodeAfter = node;\r\n                nodeBefore = nodeAfter.previousSibling;\r\n            } else {\r\n                nodeBefore = node;\r\n                nodeAfter = nodeBefore.nextSibling;\r\n            }\r\n        }\r\n\r\n        // Condition 2: Either nodeBefore or nodeAfter is null (XOR case)\r\n        // [ o I ]  or [ I o]\r\n        // need to add empty text node to convert to condition 3\r\n        if ((nodeBefore || nodeAfter) && (!nodeBefore || !nodeAfter)) {\r\n            const emptyNode = node.ownerDocument.createTextNode('');\r\n            (nodeBefore || nodeAfter).parentNode?.insertBefore(emptyNode, nodeAfter);\r\n            if (nodeBefore) {\r\n                nodeAfter = emptyNode;\r\n            } else {\r\n                nodeBefore = emptyNode;\r\n            }\r\n        }\r\n\r\n        // Condition 3: Both nodeBefore and nodeAfter are not null\r\n        // [o I o]\r\n        // return the nodes\r\n        return [nodeBefore, nodeAfter];\r\n    }\r\n}\r\n","import clearProceedingSnapshots from './clearProceedingSnapshots';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Add a new snapshot to the given snapshots data structure\r\n * @param snapshots The snapshots data structure to add new snapshot into\r\n * @param snapshot The snapshot to add\r\n * @param isAutoCompleteSnapshot Whether this is a snapshot before auto complete action\r\n */\r\nexport default function addSnapshot(\r\n    snapshots: Snapshots,\r\n    snapshot: string,\r\n    isAutoCompleteSnapshot: boolean\r\n) {\r\n    if (snapshots.currentIndex < 0 || snapshot != snapshots.snapshots[snapshots.currentIndex]) {\r\n        clearProceedingSnapshots(snapshots);\r\n        snapshots.snapshots.push(snapshot);\r\n        snapshots.currentIndex++;\r\n        snapshots.totalSize += snapshot.length;\r\n\r\n        let removeCount = 0;\r\n        while (\r\n            removeCount < snapshots.snapshots.length &&\r\n            snapshots.totalSize > snapshots.maxSize\r\n        ) {\r\n            snapshots.totalSize -= snapshots.snapshots[removeCount].length;\r\n            removeCount++;\r\n        }\r\n\r\n        if (removeCount > 0) {\r\n            snapshots.snapshots.splice(0, removeCount);\r\n            snapshots.currentIndex -= removeCount;\r\n            snapshots.autoCompleteIndex -= removeCount;\r\n        }\r\n\r\n        if (isAutoCompleteSnapshot) {\r\n            snapshots.autoCompleteIndex = snapshots.currentIndex;\r\n        }\r\n    }\r\n}\r\n","import canMoveCurrentSnapshot from './canMoveCurrentSnapshot';\r\nimport { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Move current snapshot with the given step if can move this step. Otherwise no action and return null\r\n * @param snapshots The snapshots data structure to move\r\n * @param step The step to move\r\n * @returns If can move with the given step, returns the snapshot after move, otherwise null\r\n */\r\nexport default function moveCurrentSnapsnot(snapshots: Snapshots, step: number): string {\r\n    if (canMoveCurrentSnapshot(snapshots, step)) {\r\n        snapshots.currentIndex += step;\r\n        snapshots.autoCompleteIndex = -1;\r\n        return snapshots.snapshots[snapshots.currentIndex];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create initial snapshots\r\n * @param maxSize max size of all snapshots\r\n */\r\nexport default function createSnapshots(maxSize: number): Snapshots {\r\n    return {\r\n        snapshots: [],\r\n        totalSize: 0,\r\n        currentIndex: -1,\r\n        autoCompleteIndex: -1,\r\n        maxSize,\r\n    };\r\n}\r\n","import { Snapshots } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Whether there is a snapshot added before auto complete and it can be undone now\r\n */\r\nexport default function canUndoAutoComplete(snapshots: Snapshots): boolean {\r\n    return (\r\n        snapshots.autoCompleteIndex >= 0 &&\r\n        snapshots.currentIndex - snapshots.autoCompleteIndex == 1\r\n    );\r\n}\r\n","import changeElementTag from '../utils/changeElementTag';\r\nimport getInheritableStyles from './getInheritableStyles';\r\nimport getPredefinedCssForElement from './getPredefinedCssForElement';\r\nimport getStyles from '../style/getStyles';\r\nimport getTagOfNode from '../utils/getTagOfNode';\r\nimport safeInstanceOf from '../utils/safeInstanceOf';\r\nimport setStyles from '../style/setStyles';\r\nimport toArray from '../utils/toArray';\r\nimport { cloneObject } from './cloneObject';\r\nimport {\r\n    getAllowedAttributes,\r\n    getAllowedCssClassesRegex,\r\n    getTagReplacement,\r\n    getDefaultStyleValues,\r\n    getStyleCallbacks,\r\n} from './getAllowedValues';\r\nimport {\r\n    AttributeCallbackMap,\r\n    CssStyleCallbackMap,\r\n    ElementCallbackMap,\r\n    HtmlSanitizerOptions,\r\n    NodeType,\r\n    PredefinedCssMap,\r\n    SanitizeHtmlOptions,\r\n    StringMap,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * HTML sanitizer class provides two featuers:\r\n * 1. Convert global CSS to inline CSS\r\n * 2. Sanitize an HTML document, remove unnecessary/dangerous attribute/nodes\r\n */\r\nexport default class HtmlSanitizer {\r\n    /**\r\n     * Convert global CSS to inline CSS if any\r\n     * @param html HTML source\r\n     * @param additionalStyleNodes (Optional) additional HTML STYLE elements used as global CSS\r\n     */\r\n    static convertInlineCss(html: string, additionalStyleNodes?: HTMLStyleElement[]) {\r\n        let sanitizer = new HtmlSanitizer({\r\n            additionalGlobalStyleNodes: additionalStyleNodes,\r\n        });\r\n        return sanitizer.exec(html, true /*convertCssOnly*/);\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string, remove any unuseful HTML node/attribute/CSS.\r\n     * @param html HTML source string\r\n     * @param options Options used for this sanitizing process\r\n     */\r\n    static sanitizeHtml(html: string, options?: SanitizeHtmlOptions) {\r\n        options = options || {};\r\n        let sanitizer = new HtmlSanitizer(options);\r\n        let currentStyles = safeInstanceOf(options.currentElementOrStyle, 'HTMLElement')\r\n            ? getInheritableStyles(options.currentElementOrStyle)\r\n            : options.currentElementOrStyle;\r\n        return sanitizer.exec(html, options.convertCssOnly, currentStyles);\r\n    }\r\n\r\n    private elementCallbacks: ElementCallbackMap;\r\n    private styleCallbacks: CssStyleCallbackMap;\r\n    private attributeCallbacks: AttributeCallbackMap;\r\n    private tagReplacements: Record<string, string>;\r\n    private allowedAttributes: string[];\r\n    private allowedCssClassesRegex: RegExp;\r\n    private defaultStyleValues: StringMap;\r\n    private additionalPredefinedCssForElement: PredefinedCssMap;\r\n    private additionalGlobalStyleNodes: HTMLStyleElement[];\r\n    private unknownTagReplacement: string;\r\n\r\n    /**\r\n     * Construct a new instance of HtmlSanitizer\r\n     * @param options Options for HtmlSanitizer\r\n     */\r\n    constructor(options?: HtmlSanitizerOptions) {\r\n        options = options || {};\r\n        this.elementCallbacks = cloneObject(options.elementCallbacks);\r\n        this.styleCallbacks = getStyleCallbacks(options.cssStyleCallbacks);\r\n        this.attributeCallbacks = cloneObject(options.attributeCallbacks);\r\n        this.tagReplacements = getTagReplacement(options.additionalTagReplacements);\r\n        this.allowedAttributes = getAllowedAttributes(options.additionalAllowedAttributes);\r\n        this.allowedCssClassesRegex = getAllowedCssClassesRegex(\r\n            options.additionalAllowedCssClasses\r\n        );\r\n        this.defaultStyleValues = getDefaultStyleValues(options.additionalDefaultStyleValues);\r\n        this.additionalPredefinedCssForElement = options.additionalPredefinedCssForElement;\r\n        this.additionalGlobalStyleNodes = options.additionalGlobalStyleNodes || [];\r\n        this.unknownTagReplacement = options.unknownTagReplacement;\r\n    }\r\n\r\n    /**\r\n     * Sanitize HTML string\r\n     * This function will do the following work:\r\n     * 1. Convert global CSS into inline CSS\r\n     * 2. Remove dangerous HTML tags and attributes\r\n     * 3. Remove useless CSS properties\r\n     * @param html The input HTML\r\n     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing\r\n     * @param currentStyles Current inheritable CSS styles\r\n     */\r\n    exec(html: string, convertCssOnly?: boolean, currentStyles?: StringMap): string {\r\n        const parser = new DOMParser();\r\n        const doc = parser.parseFromString(html || '', 'text/html');\r\n\r\n        if (doc && doc.body && doc.body.firstChild) {\r\n            this.convertGlobalCssToInlineCss(doc);\r\n            if (!convertCssOnly) {\r\n                this.sanitize(doc.body, currentStyles);\r\n            }\r\n        }\r\n        return (doc && doc.body && doc.body.innerHTML) || '';\r\n    }\r\n\r\n    /**\r\n     * Sanitize an HTML element, remove unnecessary or dangerous elements/attribute/CSS rules\r\n     * @param rootNode Root node to sanitize\r\n     * @param currentStyles Current CSS styles. Inheritable styles in the given node which has\r\n     * the same value with current styles will be ignored.\r\n     */\r\n    sanitize(rootNode: Node, currentStyles?: StringMap) {\r\n        if (!rootNode) {\r\n            return '';\r\n        }\r\n        currentStyles = cloneObject(currentStyles, getInheritableStyles(null));\r\n        this.processNode(rootNode, currentStyles, {});\r\n    }\r\n\r\n    /**\r\n     * Convert global CSS into inline CSS\r\n     * @param rootNode The HTML Document\r\n     */\r\n    convertGlobalCssToInlineCss(rootNode: ParentNode) {\r\n        let styleNodes = toArray(rootNode.querySelectorAll('style'));\r\n        let styleSheets = this.additionalGlobalStyleNodes\r\n            .reverse()\r\n            .map(node => node.sheet as CSSStyleSheet)\r\n            .concat(styleNodes.map(node => node.sheet as CSSStyleSheet).reverse())\r\n            .filter(sheet => sheet);\r\n        for (let styleSheet of styleSheets) {\r\n            for (let j = styleSheet.cssRules.length - 1; j >= 0; j--) {\r\n                // Skip any none-style rule, i.e. @page\r\n                let styleRule = styleSheet.cssRules[j] as CSSStyleRule;\r\n                let text = styleRule && styleRule.style ? styleRule.style.cssText : null;\r\n                if (styleRule.type != CSSRule.STYLE_RULE || !text || !styleRule.selectorText) {\r\n                    continue;\r\n                }\r\n                // Make sure the selector is not empty\r\n                for (let selector of styleRule.selectorText.split(',')) {\r\n                    if (!selector || !selector.trim() || selector.indexOf(':') >= 0) {\r\n                        continue;\r\n                    }\r\n                    let nodes = toArray(rootNode.querySelectorAll(selector));\r\n                    // Always put existing styles after so that they have higher priority\r\n                    // Which means if both global style and inline style apply to the same element,\r\n                    // inline style will have higher priority\r\n                    nodes.forEach(node =>\r\n                        node.setAttribute('style', text + (node.getAttribute('style') || ''))\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        styleNodes.forEach(node => {\r\n            if (node.parentNode) {\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        });\r\n    }\r\n\r\n    private processNode(node: Node, currentStyle: StringMap, context: Object) {\r\n        const nodeType = node.nodeType;\r\n        const isElement = nodeType == NodeType.Element;\r\n        const isText = nodeType == NodeType.Text;\r\n        const isFragment = nodeType == NodeType.DocumentFragment;\r\n\r\n        let shouldKeep = false;\r\n\r\n        if (isElement) {\r\n            const tag = getTagOfNode(node);\r\n            const callback = this.elementCallbacks[tag];\r\n            let replacement = this.tagReplacements[tag.toLowerCase()];\r\n\r\n            if (replacement === undefined) {\r\n                replacement = this.unknownTagReplacement;\r\n            }\r\n\r\n            if (callback) {\r\n                shouldKeep = callback(node as HTMLElement, context);\r\n            } else if (tag.indexOf(':') > 0) {\r\n                shouldKeep = true;\r\n            } else if (tag == replacement || replacement == '*') {\r\n                shouldKeep = true;\r\n            } else if (replacement && /^[a-zA-Z][\\w\\-]*$/.test(replacement)) {\r\n                node = changeElementTag(node as HTMLElement, replacement);\r\n                shouldKeep = true;\r\n            }\r\n        } else if (isText) {\r\n            const whiteSpace = currentStyle['white-space'];\r\n            shouldKeep =\r\n                whiteSpace == 'pre' ||\r\n                whiteSpace == 'pre-line' ||\r\n                whiteSpace == 'pre-wrap' ||\r\n                !/^[\\r\\n]*$/g.test(node.nodeValue);\r\n        } else if (isFragment) {\r\n            shouldKeep = true;\r\n        } else {\r\n            shouldKeep = false;\r\n        }\r\n\r\n        if (!shouldKeep) {\r\n            node.parentNode.removeChild(node);\r\n        } else if (\r\n            isText &&\r\n            (currentStyle['white-space'] == 'pre' || currentStyle['white-space'] == 'pre-wrap')\r\n        ) {\r\n            node.nodeValue = node.nodeValue.replace(/^ /gm, '\\u00A0').replace(/ {2}/g, ' \\u00A0');\r\n        } else if (isElement || isFragment) {\r\n            let thisStyle = cloneObject(currentStyle);\r\n            let element = <HTMLElement>node;\r\n            if (isElement) {\r\n                this.processAttributes(element, context);\r\n                this.preprocessCss(element, thisStyle);\r\n                this.processCss(element, thisStyle, context);\r\n            }\r\n\r\n            let child: Node = element.firstChild;\r\n            let next: Node;\r\n            for (; child; child = next) {\r\n                next = child.nextSibling;\r\n                this.processNode(child, thisStyle, context);\r\n            }\r\n        }\r\n    }\r\n\r\n    private preprocessCss(element: HTMLElement, thisStyle: StringMap) {\r\n        const predefinedStyles = getPredefinedCssForElement(\r\n            element,\r\n            this.additionalPredefinedCssForElement\r\n        );\r\n        if (predefinedStyles) {\r\n            Object.keys(predefinedStyles).forEach(name => {\r\n                thisStyle[name] = predefinedStyles[name];\r\n            });\r\n        }\r\n    }\r\n\r\n    private processCss(element: HTMLElement, thisStyle: StringMap, context: Object) {\r\n        const styles = getStyles(element);\r\n        Object.keys(styles).forEach(name => {\r\n            const value = styles[name];\r\n            let callback = this.styleCallbacks[name];\r\n            let isInheritable = thisStyle[name] != undefined;\r\n            let keep =\r\n                (!callback || callback(value, element, thisStyle, context)) &&\r\n                value != 'inherit' &&\r\n                value.indexOf('expression') < 0 &&\r\n                name.substr(0, 1) != '-' &&\r\n                this.defaultStyleValues[name] != value &&\r\n                ((isInheritable && value != thisStyle[name]) ||\r\n                    (!isInheritable && value != 'initial' && value != 'normal'));\r\n            if (keep && isInheritable) {\r\n                thisStyle[name] = value;\r\n            }\r\n\r\n            if (!keep) {\r\n                delete styles[name];\r\n            }\r\n        });\r\n\r\n        setStyles(element, styles);\r\n    }\r\n\r\n    private processAttributes(element: HTMLElement, context: Object) {\r\n        for (let i = element.attributes.length - 1; i >= 0; i--) {\r\n            let attribute = element.attributes[i];\r\n            let name = attribute.name.toLowerCase().trim();\r\n            let value = attribute.value;\r\n            let callback = this.attributeCallbacks[name];\r\n\r\n            let newValue = callback\r\n                ? callback(value, element, context)\r\n                : this.allowedAttributes.indexOf(name) >= 0 || name.indexOf('data-') == 0\r\n                ? value\r\n                : null;\r\n\r\n            if (name == 'class' && this.allowedCssClassesRegex) {\r\n                newValue = this.processCssClass(value, newValue);\r\n            }\r\n\r\n            if (\r\n                newValue === null ||\r\n                newValue === undefined ||\r\n                newValue.match(/s\\n*c\\n*r\\n*i\\n*p\\n*t\\n*:/i) // match script: with any NewLine inside. Browser will ignore those NewLine char and still treat it as script prefix\r\n            ) {\r\n                element.removeAttribute(name);\r\n            } else {\r\n                attribute.value = newValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    private processCssClass(originalValue: string, calculatedValue: string): string {\r\n        const originalClasses = originalValue ? originalValue.split(' ') : [];\r\n        const calculatedClasses = calculatedValue ? calculatedValue.split(' ') : [];\r\n\r\n        originalClasses.forEach(className => {\r\n            if (\r\n                this.allowedCssClassesRegex.test(className) &&\r\n                calculatedClasses.indexOf(className) < 0\r\n            ) {\r\n                calculatedClasses.push(className);\r\n            }\r\n        });\r\n\r\n        return calculatedClasses.length > 0 ? calculatedClasses.join(' ') : null;\r\n    }\r\n}\r\n","import { cloneObject } from './cloneObject';\r\nimport { CssStyleCallbackMap, StringMap } from 'roosterjs-editor-types';\r\n\r\nconst HTML_TAG_REPLACEMENT: Record<string, string> = {\r\n    // Allowed tags\r\n    a: '*',\r\n    abbr: '*',\r\n    address: '*',\r\n    area: '*',\r\n    article: '*',\r\n    aside: '*',\r\n    b: '*',\r\n    bdi: '*',\r\n    bdo: '*',\r\n    blockquote: '*',\r\n    body: '*',\r\n    br: '*',\r\n    button: '*',\r\n    canvas: '*',\r\n    caption: '*',\r\n    center: '*',\r\n    cite: '*',\r\n    code: '*',\r\n    col: '*',\r\n    colgroup: '*',\r\n    data: '*',\r\n    datalist: '*',\r\n    dd: '*',\r\n    del: '*',\r\n    details: '*',\r\n    dfn: '*',\r\n    dialog: '*',\r\n    dir: '*',\r\n    div: '*',\r\n    dl: '*',\r\n    dt: '*',\r\n    em: '*',\r\n    fieldset: '*',\r\n    figcaption: '*',\r\n    figure: '*',\r\n    font: '*',\r\n    footer: '*',\r\n    h1: '*',\r\n    h2: '*',\r\n    h3: '*',\r\n    h4: '*',\r\n    h5: '*',\r\n    h6: '*',\r\n    head: '*',\r\n    header: '*',\r\n    hgroup: '*',\r\n    hr: '*',\r\n    html: '*',\r\n    i: '*',\r\n    img: '*',\r\n    input: '*',\r\n    ins: '*',\r\n    kbd: '*',\r\n    label: '*',\r\n    legend: '*',\r\n    li: '*',\r\n    main: '*',\r\n    map: '*',\r\n    mark: '*',\r\n    menu: '*',\r\n    menuitem: '*',\r\n    meter: '*',\r\n    nav: '*',\r\n    ol: '*',\r\n    optgroup: '*',\r\n    option: '*',\r\n    output: '*',\r\n    p: '*',\r\n    picture: '*',\r\n    pre: '*',\r\n    progress: '*',\r\n    q: '*',\r\n    rp: '*',\r\n    rt: '*',\r\n    ruby: '*',\r\n    s: '*',\r\n    samp: '*',\r\n    section: '*',\r\n    select: '*',\r\n    small: '*',\r\n    span: '*',\r\n    strike: '*',\r\n    strong: '*',\r\n    sub: '*',\r\n    summary: '*',\r\n    sup: '*',\r\n    table: '*',\r\n    tbody: '*',\r\n    td: '*',\r\n    template: '*',\r\n    textarea: '*',\r\n    tfoot: '*',\r\n    th: '*',\r\n    thead: '*',\r\n    time: '*',\r\n    tr: '*',\r\n    tt: '*',\r\n    u: '*',\r\n    ul: '*',\r\n    var: '*',\r\n    wbr: '*',\r\n    xmp: '*',\r\n\r\n    // Replaced tags:\r\n    form: 'SPAN',\r\n\r\n    // Disallowed tags\r\n    applet: null,\r\n    audio: null,\r\n    base: null,\r\n    basefont: null,\r\n    embed: null,\r\n    frame: null,\r\n    frameset: null,\r\n    iframe: null,\r\n    link: null,\r\n    meta: null,\r\n    noscript: null,\r\n    object: null,\r\n    param: null,\r\n    script: null,\r\n    slot: null,\r\n    source: null,\r\n    style: null,\r\n    title: null,\r\n    track: null,\r\n    video: null,\r\n};\r\n\r\nconst ALLOWED_HTML_ATTRIBUTES = (\r\n    'accept,align,alt,checked,cite,color,cols,colspan,contextmenu,' +\r\n    'coords,datetime,default,dir,dirname,disabled,download,face,headers,height,hidden,high,href,' +\r\n    'hreflang,ismap,kind,label,lang,list,low,max,maxlength,media,min,multiple,open,optimum,pattern,' +\r\n    'placeholder,readonly,rel,required,reversed,rows,rowspan,scope,selected,shape,size,sizes,span,' +\r\n    'spellcheck,src,srclang,srcset,start,step,style,tabindex,target,title,translate,type,usemap,value,' +\r\n    'width,wrap'\r\n).split(',');\r\n\r\nconst DEFAULT_STYLE_VALUES: { [name: string]: string } = {\r\n    'background-color': 'transparent',\r\n    'border-bottom-color': 'rgb(0, 0, 0)',\r\n    'border-bottom-style': 'none',\r\n    'border-bottom-width': '0px',\r\n    'border-image-outset': '0',\r\n    'border-image-repeat': 'stretch',\r\n    'border-image-slice': '100%',\r\n    'border-image-source': 'none',\r\n    'border-image-width': '1',\r\n    'border-left-color': 'rgb(0, 0, 0)',\r\n    'border-left-style': 'none',\r\n    'border-left-width': '0px',\r\n    'border-right-color': 'rgb(0, 0, 0)',\r\n    'border-right-style': 'none',\r\n    'border-right-width': '0px',\r\n    'border-top-color': 'rgb(0, 0, 0)',\r\n    'border-top-style': 'none',\r\n    'border-top-width': '0px',\r\n    'outline-color': 'transparent',\r\n    'outline-style': 'none',\r\n    'outline-width': '0px',\r\n    overflow: 'visible',\r\n    'text-decoration': 'none',\r\n    '-webkit-text-stroke-width': '0px',\r\n    'word-wrap': 'break-word',\r\n    'margin-left': '0px',\r\n    'margin-right': '0px',\r\n    padding: '0px',\r\n    'padding-top': '0px',\r\n    'padding-left': '0px',\r\n    'padding-right': '0px',\r\n    'padding-bottom': '0px',\r\n    border: '0px',\r\n    'border-top': '0px',\r\n    'border-left': '0px',\r\n    'border-right': '0px',\r\n    'border-bottom': '0px',\r\n    'vertical-align': 'baseline',\r\n    float: 'none',\r\n};\r\n\r\n// This is to preserve entity related CSS classes when paste.\r\nconst ALLOWED_CSS_CLASSES: string[] = [];\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getTagReplacement(\r\n    additionalReplacements: Record<string, string>\r\n): Record<string, string> {\r\n    const result = { ...HTML_TAG_REPLACEMENT };\r\n    const replacements = additionalReplacements || {};\r\n    Object.keys(replacements).forEach(key => {\r\n        if (key) {\r\n            result[key.toLowerCase()] = replacements[key];\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getAllowedAttributes(additionalAttributes: string[]): string[] {\r\n    return unique(ALLOWED_HTML_ATTRIBUTES.concat(additionalAttributes || [])).map(attr =>\r\n        attr.toLocaleLowerCase()\r\n    );\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getAllowedCssClassesRegex(additionalCssClasses: string[]): RegExp {\r\n    const patterns = ALLOWED_CSS_CLASSES.concat(additionalCssClasses || []);\r\n    return patterns.length > 0 ? new RegExp(patterns.join('|')) : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getDefaultStyleValues(additionalDefaultStyles: StringMap): StringMap {\r\n    let result = cloneObject(DEFAULT_STYLE_VALUES);\r\n    if (additionalDefaultStyles) {\r\n        Object.keys(additionalDefaultStyles).forEach(name => {\r\n            let value = additionalDefaultStyles[name];\r\n            if (value !== null && value !== undefined) {\r\n                result[name] = value;\r\n            } else {\r\n                delete result[name];\r\n            }\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getStyleCallbacks(callbacks: CssStyleCallbackMap): CssStyleCallbackMap {\r\n    let result = cloneObject(callbacks);\r\n    result.position = result.position || removeValue;\r\n    result.width = result.width || removeWidthForLiAndDiv;\r\n    return result;\r\n}\r\n\r\nfunction removeValue(): null {\r\n    return null;\r\n}\r\n\r\nfunction removeWidthForLiAndDiv(value: string, element: HTMLElement) {\r\n    let tag = element.tagName;\r\n    return !(tag == 'LI' || tag == 'DIV');\r\n}\r\n\r\nfunction unique<T>(array: T[]): T[] {\r\n    return array.filter((value, index, self) => self.indexOf(value) == index);\r\n}\r\n","import { HtmlSanitizerOptions } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Create default value of HtmlSanitizerOptions with every property set\r\n */\r\nexport default function createDefaultHtmlSanitizerOptions(): Required<HtmlSanitizerOptions> {\r\n    return {\r\n        elementCallbacks: {},\r\n        attributeCallbacks: {},\r\n        cssStyleCallbacks: {},\r\n        additionalTagReplacements: {},\r\n        additionalAllowedAttributes: [],\r\n        additionalAllowedCssClasses: [],\r\n        additionalDefaultStyleValues: {},\r\n        additionalGlobalStyleNodes: [],\r\n        additionalPredefinedCssForElement: {},\r\n        unknownTagReplacement: null,\r\n    };\r\n}\r\n","/**\r\n * Chain all callback for an attribute together\r\n * @param map The source callback map\r\n * @param name Name of the property to chain\r\n * @param newCallback A new callback to process the given name on the given map.\r\n * If the same property got multiple callbacks, the final return value will be the return\r\n * value of the latest callback\r\n */\r\nexport default function chainSanitizerCallback<T extends any[], R>(\r\n    map: Record<string, (...args: T) => R>,\r\n    name: string,\r\n    newCallback: (...args: T) => R\r\n) {\r\n    if (!map[name]) {\r\n        map[name] = newCallback;\r\n    } else {\r\n        const originalCallback = map[name];\r\n        map[name] = (...args: T) => {\r\n            originalCallback(...args);\r\n            return newCallback(...args);\r\n        };\r\n    }\r\n}\r\n","import { EntityClasses } from 'roosterjs-editor-types';\r\n\r\nconst CONTENT_EDITABLE = 'contenteditable';\r\n\r\n/**\r\n * Commit information of an entity (type, isReadonly, id) into the wrapper node as CSS Classes\r\n * @param wrapper The entity wrapper element\r\n * @param type Entity type\r\n * @param isReadonly Whether this is a readonly entity\r\n * @param id Optional Id of the entity\r\n */\r\nexport default function commitEntity(\r\n    wrapper: HTMLElement,\r\n    type: string,\r\n    isReadonly: boolean,\r\n    id?: string\r\n) {\r\n    if (wrapper) {\r\n        wrapper.className = `${EntityClasses.ENTITY_INFO_NAME} ${\r\n            EntityClasses.ENTITY_TYPE_PREFIX\r\n        }${type} ${id ? `${EntityClasses.ENTITY_ID_PREFIX}${id} ` : ''}${\r\n            EntityClasses.ENTITY_READONLY_PREFIX\r\n        }${isReadonly ? '1' : '0'}`;\r\n\r\n        if (isReadonly) {\r\n            wrapper.contentEditable = 'false';\r\n        } else if (wrapper.getAttribute(CONTENT_EDITABLE)) {\r\n            wrapper.removeAttribute(CONTENT_EDITABLE);\r\n        }\r\n    }\r\n}\r\n","import { Entity, EntityClasses } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get Entity object from an entity root element\r\n * @param element The entity root element. If this element is not an entity root element,\r\n * it will return null\r\n */\r\nexport default function getEntityFromElement(element: HTMLElement): Entity {\r\n    let isEntity = false;\r\n    let type: string;\r\n    let id = '';\r\n    let isReadonly = false;\r\n\r\n    element?.className?.split(' ').forEach(name => {\r\n        if (name == EntityClasses.ENTITY_INFO_NAME) {\r\n            isEntity = true;\r\n        } else if (name.indexOf(EntityClasses.ENTITY_TYPE_PREFIX) == 0) {\r\n            type = name.substr(EntityClasses.ENTITY_TYPE_PREFIX.length);\r\n        } else if (name.indexOf(EntityClasses.ENTITY_ID_PREFIX) == 0) {\r\n            id = name.substr(EntityClasses.ENTITY_ID_PREFIX.length);\r\n        } else if (name.indexOf(EntityClasses.ENTITY_READONLY_PREFIX) == 0) {\r\n            isReadonly = name.substr(EntityClasses.ENTITY_READONLY_PREFIX.length) == '1';\r\n        }\r\n    });\r\n\r\n    return isEntity\r\n        ? {\r\n              wrapper: element,\r\n              id,\r\n              type,\r\n              isReadonly,\r\n          }\r\n        : null;\r\n}\r\n","import { EntityClasses } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal Get a selector string for specified entity type and id\r\n * @param type (Optional) Type of entity\r\n * @param id (Optional) Id of entity\r\n */\r\nexport default function getEntitySelector(type?: string, id?: string): string {\r\n    const typeSelector = type ? `.${EntityClasses.ENTITY_TYPE_PREFIX}${type}` : '';\r\n    const idSelector = id ? `.${EntityClasses.ENTITY_ID_PREFIX}${id}` : '';\r\n    return '.' + EntityClasses.ENTITY_INFO_NAME + typeSelector + idSelector;\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Gets the cached event data by cache key from event object if there is already one.\r\n * Otherwise, call getter function to create one, and cache it.\r\n * @param event The event object\r\n * @param key Cache key string, need to be unique\r\n * @param getter Getter function to get the object when it is not in cache yet\r\n */\r\nexport default function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T {\r\n    let result =\r\n        event && event.eventDataCache && event.eventDataCache.hasOwnProperty(key)\r\n            ? <T>event.eventDataCache[key]\r\n            : getter();\r\n    if (event) {\r\n        event.eventDataCache = event.eventDataCache || {};\r\n        event.eventDataCache[key] = result;\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { PluginEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Clear a cached object by its key from an event object\r\n * @param event The event object\r\n * @param key The cache key\r\n */\r\nexport default function clearEventDataCache(event: PluginEvent, key?: string): void {\r\n    if (event && event.eventDataCache) {\r\n        if (key && event.eventDataCache.hasOwnProperty(key)) {\r\n            delete event.eventDataCache[key];\r\n        } else if (!key) {\r\n            event.eventDataCache = {};\r\n        }\r\n    }\r\n}\r\n","import isModifierKey from './isModifierKey';\r\n\r\n/**\r\n * Returns true when the event was fired from a key that produces a character value, otherwise false\r\n * This detection is not 100% accurate. event.key is not fully supported by all browsers, and in some browsers (e.g. IE),\r\n * event.key is longer than 1 for num pad input. But here we just want to improve performance as much as possible.\r\n * So if we missed some case here it is still acceptable.\r\n * @param event The keyboard event object\r\n */\r\nexport default function isCharacterValue(event: KeyboardEvent): boolean {\r\n    return !isModifierKey(event) && event.key && event.key.length == 1;\r\n}\r\n","import { Browser } from '../utils/Browser';\r\n\r\n/**\r\n * Check if Ctrl key (Windows) or Meta key (Mac) is pressed for the given Event\r\n * @param event A Keyboard event or Mouse event object\r\n * @returns True if Ctrl key is pressed on Windows or Meta key is pressed on Mac\r\n */\r\nconst isCtrlOrMetaPressed: (event: KeyboardEvent | MouseEvent) => boolean = Browser.isMac\r\n    ? event => event.metaKey\r\n    : event => event.ctrlKey;\r\nexport default isCtrlOrMetaPressed;\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { IEditor } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    getSelectedBlockElementsInRegion,\r\n    getStyles,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeInRegion,\r\n    isVoidHtmlElement,\r\n    safeInstanceOf,\r\n    setStyles,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst TAGS_TO_UNWRAP = 'B,I,U,STRONG,EM,SUB,SUP,STRIKE,FONT,CENTER,H1,H2,H3,H4,H5,H6,UL,OL,LI,SPAN,P,BLOCKQUOTE,CODE,S,PRE'.split(\r\n    ','\r\n);\r\nconst ATTRIBUTES_TO_PRESERVE = ['href', 'src'];\r\nconst TAGS_TO_STOP_UNWRAP = ['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'];\r\n\r\n/**\r\n * Clear all formats of selected blocks.\r\n * When selection is collapsed, only clear format of current block.\r\n * @param editor The editor instance\r\n */\r\nexport default function clearBlockFormat(editor: IEditor) {\r\n    blockFormat(editor, region => {\r\n        const blocks = getSelectedBlockElementsInRegion(region);\r\n        let nodes = collapseNodesInRegion(region, blocks);\r\n\r\n        if (editor.contains(region.rootNode)) {\r\n            // If there are styles on table cell, wrap all its children and move down all non-border styles.\r\n            // So that we can preserve styles for unselected blocks as well as border styles for table\r\n            const nonborderStyles = removeNonBorderStyles(region.rootNode);\r\n            if (Object.keys(nonborderStyles).length > 0) {\r\n                const wrapper = wrap(toArray(region.rootNode.childNodes));\r\n                setStyles(wrapper, nonborderStyles);\r\n            }\r\n        }\r\n\r\n        while (nodes.length > 0 && isNodeInRegion(region, nodes[0].parentNode)) {\r\n            nodes = [splitBalancedNodeRange(nodes)];\r\n        }\r\n\r\n        nodes.forEach(clearNodeFormat);\r\n    });\r\n}\r\n\r\nfunction clearNodeFormat(node: Node): boolean {\r\n    // 1. Recursively clear format of all its child nodes\r\n    const areBlockElements = toArray(node.childNodes).map(clearNodeFormat);\r\n    let areAllChildrenBlock = areBlockElements.every(b => b);\r\n    let returnBlockElement = isBlockElement(node);\r\n\r\n    // 2. Unwrap the tag if necessary\r\n    const tag = getTagOfNode(node);\r\n    if (tag) {\r\n        if (\r\n            TAGS_TO_UNWRAP.indexOf(tag) >= 0 ||\r\n            (areAllChildrenBlock &&\r\n                !isVoidHtmlElement(node) &&\r\n                TAGS_TO_STOP_UNWRAP.indexOf(tag) < 0)\r\n        ) {\r\n            if (returnBlockElement && !areAllChildrenBlock) {\r\n                wrap(node);\r\n            }\r\n            unwrap(node);\r\n        } else {\r\n            // 3. Otherwise, remove all attributes\r\n            clearAttribute(node as HTMLElement);\r\n        }\r\n    }\r\n\r\n    return returnBlockElement;\r\n}\r\n\r\nfunction clearAttribute(element: HTMLElement) {\r\n    const isTableCell = safeInstanceOf(element, 'HTMLTableCellElement');\r\n\r\n    for (let attr of toArray(element.attributes)) {\r\n        if (isTableCell && attr.name == 'style') {\r\n            removeNonBorderStyles(element);\r\n        } else if (\r\n            ATTRIBUTES_TO_PRESERVE.indexOf(attr.name.toLowerCase()) < 0 &&\r\n            attr.name.indexOf('data-') != 0\r\n        ) {\r\n            element.removeAttribute(attr.name);\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNonBorderStyles(element: HTMLElement): Record<string, string> {\r\n    const styles = getStyles(element);\r\n    const result: Record<string, string> = {};\r\n\r\n    Object.keys(styles).forEach(name => {\r\n        if (name.indexOf('border') < 0) {\r\n            result[name] = styles[name];\r\n            delete styles[name];\r\n        }\r\n    });\r\n\r\n    setStyles(element, styles);\r\n\r\n    return result;\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport setBackgroundColor from './setBackgroundColor';\r\nimport setFontName from './setFontName';\r\nimport setFontSize from './setFontSize';\r\nimport setTextColor from './setTextColor';\r\nimport toggleBold from './toggleBold';\r\nimport toggleItalic from './toggleItalic';\r\nimport toggleUnderline from './toggleUnderline';\r\nimport { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\nconst STYLES_TO_REMOVE = ['font', 'text-decoration', 'color', 'background'];\r\n\r\n/**\r\n * Clear the format in current selection, after cleaning, the format will be\r\n * changed to default format. The format that get cleaned include B/I/U/font name/\r\n * font size/text color/background color/align left/align right/align center/superscript/subscript\r\n * @param editor The editor instance\r\n */\r\nexport default function clearFormat(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, DocumentCommand.RemoveFormat);\r\n\r\n        editor.queryElements('[class]', QueryScope.OnSelection, node =>\r\n            node.removeAttribute('class')\r\n        );\r\n\r\n        const defaultFormat = editor.getDefaultFormat();\r\n        const isDefaultFormatEmpty = Object.keys(defaultFormat).length === 0;\r\n        editor.queryElements('[style]', QueryScope.InSelection, node => {\r\n            STYLES_TO_REMOVE.forEach(style => node.style.removeProperty(style));\r\n\r\n            // when default format is empty, keep the HTML minimum by removing style attribute if there's no style\r\n            // (note: because default format is empty, we're not adding style back in)\r\n            if (isDefaultFormatEmpty && node.getAttribute('style') === '') {\r\n                node.removeAttribute('style');\r\n            }\r\n        });\r\n\r\n        if (!isDefaultFormatEmpty) {\r\n            if (defaultFormat.fontFamily) {\r\n                setFontName(editor, defaultFormat.fontFamily);\r\n            }\r\n            if (defaultFormat.fontSize) {\r\n                setFontSize(editor, defaultFormat.fontSize);\r\n            }\r\n            if (defaultFormat.textColor) {\r\n                if (defaultFormat.textColors) {\r\n                    setTextColor(editor, defaultFormat.textColors);\r\n                } else {\r\n                    setTextColor(editor, defaultFormat.textColor);\r\n                }\r\n            }\r\n            if (defaultFormat.backgroundColor) {\r\n                if (defaultFormat.backgroundColors) {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColors);\r\n                } else {\r\n                    setBackgroundColor(editor, defaultFormat.backgroundColor);\r\n                }\r\n            }\r\n            if (defaultFormat.bold) {\r\n                toggleBold(editor);\r\n            }\r\n            if (defaultFormat.italic) {\r\n                toggleItalic(editor);\r\n            }\r\n            if (defaultFormat.underline) {\r\n                toggleUnderline(editor);\r\n            }\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer, matchLink } from 'roosterjs-editor-dom';\r\n\r\n// Regex matching Uri scheme\r\nconst URI_REGEX = /^[a-zA-Z]+:/i;\r\n// Regex matching begin of email address\r\nconst MAILTO_REGEX = /^[\\w.%+-]+@/i;\r\n// Regex matching begin of ftp, i.e. ftp.microsoft.com\r\nconst FTP_REGEX = /^ftp\\./i;\r\nconst TEMP_TITLE = 'istemptitle';\r\n\r\nfunction applyLinkPrefix(url: string): string {\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // Add link prefix per rule:\r\n    // (a) if the url always starts with a URI scheme, leave it as it is\r\n    // (b) if the url is an email address, xxx@... add mailto: prefix\r\n    // (c) if the url starts with ftp., add ftp:// prefix\r\n    // (d) rest, add http:// prefix\r\n    let prefix = '';\r\n    if (url.search(URI_REGEX) < 0) {\r\n        if (url.search(MAILTO_REGEX) == 0) {\r\n            prefix = 'mailto:';\r\n        } else if (url.search(FTP_REGEX) == 0) {\r\n            prefix = 'ftp://';\r\n        } else {\r\n            // fallback to http://\r\n            prefix = 'http://';\r\n        }\r\n    }\r\n\r\n    return prefix + url;\r\n}\r\n\r\n/**\r\n * Insert a hyperlink at cursor.\r\n * When there is a selection, hyperlink will be applied to the selection,\r\n * otherwise a hyperlink will be inserted to the cursor position.\r\n * @param editor Editor object\r\n * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.\r\n * When protocol is not specified, a best matched protocol will be predicted.\r\n * @param altText Optional alt text of the link, will be shown when hover on the link\r\n * @param displayText Optional display text for the link.\r\n * If specified, the display text of link will be replaced with this text.\r\n * If not specified and there wasn't a link, the link url will be used as display text.\r\n */\r\nexport default function createLink(\r\n    editor: IEditor,\r\n    link: string,\r\n    altText?: string,\r\n    displayText?: string\r\n) {\r\n    editor.focus();\r\n    let url = (checkXss(link) || '').trim();\r\n    if (url) {\r\n        let linkData = matchLink(url);\r\n        // matchLink can match most links, but not all, i.e. if you pass link a link as \"abc\", it won't match\r\n        // we know in that case, users will want to insert a link like http://abc\r\n        // so we have separate logic in applyLinkPrefix to add link prefix depending on the format of the link\r\n        // i.e. if the link starts with something like abc@xxx, we will add mailto: prefix\r\n        // if the link starts with ftp.xxx, we will add ftp:// link. For more, see applyLinkPrefix\r\n        let normalizedUrl = linkData ? linkData.normalizedUrl : applyLinkPrefix(url);\r\n        let originalUrl = linkData ? linkData.originalUrl : url;\r\n\r\n        editor.addUndoSnapshot(() => {\r\n            let range = editor.getSelectionRange();\r\n            let anchor: HTMLAnchorElement = null;\r\n            if (range && range.collapsed) {\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n\r\n                // If there is already a link, just change its href\r\n                if (anchor) {\r\n                    anchor.href = normalizedUrl;\r\n                    // Change text content if it is specified\r\n                    updateAnchorDisplayText(anchor, displayText);\r\n                } else {\r\n                    anchor = editor.getDocument().createElement('A') as HTMLAnchorElement;\r\n                    anchor.textContent = displayText || originalUrl;\r\n                    anchor.href = normalizedUrl;\r\n                    editor.insertNode(anchor);\r\n                }\r\n            } else {\r\n                // the selection is not collapsed, use browser execCommand\r\n                editor.getDocument().execCommand(DocumentCommand.CreateLink, false, normalizedUrl);\r\n                anchor = getAnchorNodeAtCursor(editor);\r\n                updateAnchorDisplayText(anchor, displayText);\r\n            }\r\n            if (altText && anchor) {\r\n                // Hack: Ideally this should be done by HyperLink plugin.\r\n                // We make a hack here since we don't have an event to notify HyperLink plugin\r\n                // before we apply the link.\r\n                anchor.removeAttribute(TEMP_TITLE);\r\n                anchor.title = altText;\r\n            }\r\n            return anchor;\r\n        }, ChangeSource.CreateLink);\r\n    }\r\n}\r\n\r\nfunction getAnchorNodeAtCursor(editor: IEditor): HTMLAnchorElement {\r\n    return editor.queryElements('a[href]', QueryScope.OnSelection)[0] as HTMLAnchorElement;\r\n}\r\n\r\nfunction updateAnchorDisplayText(anchor: HTMLAnchorElement, displayText: string) {\r\n    if (displayText && anchor.textContent != displayText) {\r\n        anchor.textContent = displayText;\r\n    }\r\n}\r\n\r\nfunction checkXss(link: string): string {\r\n    const santizer = new HtmlSanitizer();\r\n    const doc = new DOMParser().parseFromString('<a></a>', 'text/html');\r\n    const a = doc.body.firstChild as HTMLAnchorElement;\r\n\r\n    a.href = link || '';\r\n    santizer.sanitize(doc.body);\r\n    // We use getAttribute because some browsers will try to make the href property a valid link.\r\n    // This has unintended side effects when the link lacks a protocol.\r\n    return a.getAttribute('href');\r\n}\r\n","import { getPendableFormatState, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport {\r\n    ElementBasedFormatState,\r\n    FormatState,\r\n    IEditor,\r\n    PluginEvent,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Get element based Format State at cursor\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns An ElementBasedFormatState object\r\n */\r\nexport function getElementBasedFormatState(\r\n    editor: IEditor,\r\n    event?: PluginEvent\r\n): ElementBasedFormatState {\r\n    let listTag = getTagOfNode(editor.getElementAtCursor('OL,UL', null /*startFrom*/, event));\r\n    let headerTag = getTagOfNode(\r\n        editor.getElementAtCursor('H1,H2,H3,H4,H5,H6', null /*startFrom*/, event)\r\n    );\r\n\r\n    return {\r\n        isBullet: listTag == 'UL',\r\n        isNumbering: listTag == 'OL',\r\n        headerLevel: (headerTag && parseInt(headerTag[1])) || 0,\r\n\r\n        canUnlink: !!editor.queryElements('a[href]', QueryScope.OnSelection)[0],\r\n        canAddImageAltText: !!editor.queryElements('img', QueryScope.OnSelection)[0],\r\n        isBlockQuote: !!editor.queryElements('blockquote', QueryScope.OnSelection)[0],\r\n    };\r\n}\r\n\r\n/**\r\n * Get format state at cursor\r\n * A format state is a collection of all format related states, e.g.,\r\n * bold, italic, underline, font name, font size, etc.\r\n * @param editor The editor instance\r\n * @param event (Optional) The plugin event, it stores the event cached data for looking up.\r\n * In this function the event cache is used to get list state and header level. If not passed,\r\n * it will query the node within selection to get the info\r\n * @returns The format state at cursor\r\n */\r\nexport default function getFormatState(editor: IEditor, event?: PluginEvent): FormatState {\r\n    return {\r\n        ...getPendableFormatState(editor.getDocument()),\r\n        ...getElementBasedFormatState(editor, event),\r\n        ...editor.getStyleBasedFormatState(),\r\n        ...editor.getUndoState(),\r\n    };\r\n}\r\n","import {\r\n    commitEntity,\r\n    getEntityFromElement,\r\n    getEntitySelector,\r\n    Position,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentPosition,\r\n    Entity,\r\n    IEditor,\r\n    NodePosition,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Insert an entity into editor.\r\n * @param editor The editor to insert entity into.\r\n * @param type Type of the entity\r\n * @param contentNode Root element of the entity\r\n * @param isBlock Whether the entity will be shown as a block\r\n * @param isReadonly Whether the entity will be a readonly entity\r\n * @param position (Optional) The position to insert into. If not specified, current position will be used.\r\n * If isBlock is true, entity will be insert below this position\r\n */\r\nexport default function insertEntity(\r\n    editor: IEditor,\r\n    type: string,\r\n    contentNode: Node,\r\n    isBlock: boolean,\r\n    isReadonly: boolean,\r\n    position?: NodePosition | ContentPosition.Begin | ContentPosition.End | ContentPosition.DomEnd\r\n): Entity {\r\n    const wrapper = wrap(contentNode, isBlock ? 'DIV' : 'SPAN');\r\n\r\n    // For inline & readonly entity, we need to set display to \"inline-block\" otherwise\r\n    // there will be some weird behavior when move cursor around the entity node.\r\n    // And we should only do this for readonly entity since \"inline-block\" has some side effect\r\n    // in IE that there will be a resize border around the inline-block element. We made some\r\n    // workaround for readonly entity for this issue but for editable entity, keep it as \"inline\"\r\n    // will just work fine.\r\n    if (!isBlock && isReadonly) {\r\n        wrapper.style.display = 'inline-block';\r\n    }\r\n\r\n    commitEntity(wrapper, type, isReadonly);\r\n\r\n    if (!editor.contains(wrapper)) {\r\n        let currentRange: Range;\r\n        let contentPosition:\r\n            | ContentPosition.Begin\r\n            | ContentPosition.End\r\n            | ContentPosition.DomEnd\r\n            | ContentPosition.SelectionStart;\r\n\r\n        if (typeof position == 'number') {\r\n            contentPosition = position;\r\n        } else if (position) {\r\n            currentRange = editor.getSelectionRange();\r\n            const node = position.normalize().node;\r\n            const existingEntity = node && editor.getElementAtCursor(getEntitySelector(), node);\r\n\r\n            // Do not insert entity into another entity\r\n            if (existingEntity) {\r\n                position = new Position(existingEntity, PositionType.After);\r\n            }\r\n\r\n            editor.select(position);\r\n            contentPosition = ContentPosition.SelectionStart;\r\n        } else {\r\n            editor.focus();\r\n            contentPosition = ContentPosition.SelectionStart;\r\n        }\r\n\r\n        editor.insertNode(wrapper, {\r\n            updateCursor: false,\r\n            insertOnNewLine: isBlock,\r\n            replaceSelection: true,\r\n            position: contentPosition,\r\n        });\r\n\r\n        if (contentPosition == ContentPosition.SelectionStart) {\r\n            if (currentRange) {\r\n                editor.select(currentRange);\r\n            } else if (!isBlock) {\r\n                editor.select(wrapper, PositionType.After);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (isBlock) {\r\n        // Insert an extra empty line for block entity to make sure\r\n        // user can still put cursor below the entity.\r\n        const br = editor.getDocument().createElement('BR');\r\n        wrapper.parentNode.insertBefore(br, wrapper.nextSibling);\r\n    }\r\n\r\n    const entity = getEntityFromElement(wrapper);\r\n    editor.triggerContentChangedEvent(ChangeSource.InsertEntity, entity);\r\n\r\n    return entity;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\nimport { readFile } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image file. There are at least 3 ways to obtain the file object:\r\n * From local file, from clipboard data, from drag-and-drop\r\n */\r\nexport default function insertImage(editor: IEditor, imageFile: File): void;\r\n\r\n/**\r\n * Insert an image to editor at current selection\r\n * @param editor The editor instance\r\n * @param imageFile The image link.\r\n */\r\nexport default function insertImage(editor: IEditor, url: string): void;\r\n\r\nexport default function insertImage(editor: IEditor, imageFile: File | string): void {\r\n    if (typeof imageFile == 'string') {\r\n        insertImageWithSrc(editor, imageFile);\r\n    } else {\r\n        readFile(imageFile, dataUrl => {\r\n            if (dataUrl && !editor.isDisposed()) {\r\n                insertImageWithSrc(editor, dataUrl);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction insertImageWithSrc(editor: IEditor, src: string) {\r\n    editor.addUndoSnapshot(() => {\r\n        const image = editor.getDocument().createElement('img');\r\n        image.src = src;\r\n        image.style.maxWidth = '100%';\r\n        editor.insertNode(image);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableFormat } from 'roosterjs-editor-types';\r\nimport { Position, VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Insert table into editor at current selection\r\n * @param editor The editor instance\r\n * @param columns Number of columns in table, it also controls the default table cell width:\r\n * if columns &lt;= 4, width = 120px; if columns &lt;= 6, width = 100px; else width = 70px\r\n * @param rows Number of rows in table\r\n * @param format (Optional) The table format. If not passed, the default format will be applied:\r\n * background color: #FFF; border color: #ABABAB\r\n */\r\nexport default function insertTable(\r\n    editor: IEditor,\r\n    columns: number,\r\n    rows: number,\r\n    format?: TableFormat\r\n) {\r\n    let document = editor.getDocument();\r\n    let fragment = document.createDocumentFragment();\r\n    let table = document.createElement('table') as HTMLTableElement;\r\n    fragment.appendChild(table);\r\n    table.cellSpacing = '0';\r\n    table.cellPadding = '1';\r\n    for (let i = 0; i < rows; i++) {\r\n        let tr = document.createElement('tr') as HTMLTableRowElement;\r\n        table.appendChild(tr);\r\n        for (let j = 0; j < columns; j++) {\r\n            let td = document.createElement('td') as HTMLTableCellElement;\r\n            tr.appendChild(td);\r\n            td.appendChild(document.createElement('br'));\r\n            td.style.width = getTableCellWidth(columns);\r\n        }\r\n    }\r\n\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        let vtable = new VTable(table);\r\n        vtable.applyFormat(\r\n            format || {\r\n                bgColorEven: '#FFF',\r\n                bgColorOdd: '#FFF',\r\n                topBorderColor: '#ABABAB',\r\n                bottomBorderColor: '#ABABAB',\r\n                verticalBorderColor: '#ABABAB',\r\n            }\r\n        );\r\n        vtable.writeBack();\r\n        editor.insertNode(fragment);\r\n        editor.runAsync(editor =>\r\n            editor.select(new Position(table, PositionType.Begin).normalize())\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n\r\nfunction getTableCellWidth(columns: number): string {\r\n    if (columns <= 4) {\r\n        return '120px';\r\n    } else if (columns <= 6) {\r\n        return '100px';\r\n    } else {\r\n        return '70px';\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, PositionType, TableOperation } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Edit table with given operation. If there is no table at cursor then no op.\r\n * @param editor The editor instance\r\n * @param operation Table operation\r\n */\r\nexport default function editTable(editor: IEditor, operation: TableOperation) {\r\n    let td = editor.getElementAtCursor('TD,TH') as HTMLTableCellElement;\r\n    if (td) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(td);\r\n            vtable.edit(operation);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n\r\n            let cellToSelect = calculateCellToSelect(operation, vtable.row, vtable.col);\r\n            editor.select(\r\n                vtable.getCell(cellToSelect.newRow, cellToSelect.newCol).td,\r\n                PositionType.Begin\r\n            );\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n\r\nfunction calculateCellToSelect(operation: TableOperation, currentRow: number, currentCol: number) {\r\n    let newRow = currentRow;\r\n    let newCol = currentCol;\r\n    switch (operation) {\r\n        case TableOperation.InsertAbove:\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertBelow:\r\n            newRow += 1;\r\n            newCol = 0;\r\n            break;\r\n        case TableOperation.InsertLeft:\r\n            newRow = 0;\r\n            break;\r\n        case TableOperation.InsertRight:\r\n            newRow = 0;\r\n            newCol += 1;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        newRow,\r\n        newCol,\r\n    };\r\n}\r\n","import { ChangeSource, IEditor, TableFormat } from 'roosterjs-editor-types';\r\nimport { VTable } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Format table\r\n * @param editor The editor which contains the table to format\r\n * @param format A TableFormat object contains format information we want to apply to the table\r\n * @param table The table to format. This is optional. When not passed, the current table (if any) will be formatted\r\n */\r\nexport default function formatTable(\r\n    editor: IEditor,\r\n    format: Partial<TableFormat>,\r\n    table?: HTMLTableElement\r\n) {\r\n    table = table || (editor.getElementAtCursor('TABLE') as HTMLTableElement);\r\n    if (table) {\r\n        editor.addUndoSnapshot((start, end) => {\r\n            let vtable = new VTable(table);\r\n            vtable.applyFormat(format);\r\n            vtable.writeBack();\r\n            editor.focus();\r\n            editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Remove link at selection. If no links at selection, do nothing.\r\n * If selection contains multiple links, all of the link styles will be removed.\r\n * If only part of a link is selected, the whole link style will be removed.\r\n * @param editor The editor instance\r\n */\r\nexport default function removeLink(editor: IEditor) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        editor.queryElements('a[href]', QueryScope.OnSelection, unwrap);\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { ContentPosition, IEditor, IPositionContentSearcher } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Replace text before current selection with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param text The text for matching. We will try to match the text with the text before cursor\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n * @param searcher Optional PositionContentSearcher of current selection to help search text\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    text: string,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean;\r\n\r\n/**\r\n * Replace a given range with a node, current selection will be kept if possible\r\n * @param editor The editor instance\r\n * @param range The range to replace from\r\n * @param node The node to replace the text with\r\n * @param exactMatch True if the text must appear exactly before selection,\r\n * otherwise there can be some text between the tearget text and selection\r\n */\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    range: Range,\r\n    node: Node,\r\n    exactMatch: boolean\r\n): boolean;\r\n\r\nexport default function replaceWithNode(\r\n    editor: IEditor,\r\n    textOrRange: string | Range,\r\n    node: Node,\r\n    exactMatch: boolean,\r\n    searcher?: IPositionContentSearcher\r\n): boolean {\r\n    // Make sure the text and node is valid\r\n    if (!textOrRange || !node) {\r\n        return false;\r\n    }\r\n\r\n    let range: Range;\r\n\r\n    if (typeof textOrRange == 'string') {\r\n        searcher = searcher || editor.getContentSearcherOfCursor();\r\n        range = searcher && searcher.getRangeFromText(textOrRange, exactMatch);\r\n    } else {\r\n        range = textOrRange;\r\n    }\r\n\r\n    if (range) {\r\n        const backupRange = editor.getSelectionRange();\r\n\r\n        // If the range to replace is right before current cursor, it is actually an exact match\r\n        if (\r\n            backupRange.collapsed &&\r\n            range.endContainer == backupRange.startContainer &&\r\n            range.endOffset == backupRange.startOffset\r\n        ) {\r\n            exactMatch = true;\r\n        }\r\n\r\n        editor.insertNode(node, {\r\n            position: ContentPosition.Range,\r\n            updateCursor: exactMatch,\r\n            replaceSelection: true,\r\n            insertOnNewLine: false,\r\n            range: range,\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import { ChangeSource, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Rotate an element visually\r\n * @param editor The editor instance\r\n * @param element The element that should be rotated\r\n * @param angle The degree at which to rotate the element from it's center\r\n */\r\nexport default function rotateElement(editor: IEditor, element: HTMLElement, angle: number): void {\r\n    if (element) {\r\n        editor.addUndoSnapshot(() => {\r\n            element.style.transform = `rotate(${angle}deg)`;\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport {\r\n    Alignment,\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set content alignment\r\n * @param editor The editor instance\r\n * @param alignment The alignment option:\r\n * Alignment.Center, Alignment.Left, Alignment.Right\r\n */\r\nexport default function setAlignment(editor: IEditor, alignment: Alignment) {\r\n    let command = DocumentCommand.JustifyLeft;\r\n    let align = 'left';\r\n\r\n    if (alignment == Alignment.Center) {\r\n        command = DocumentCommand.JustifyCenter;\r\n        align = 'center';\r\n    } else if (alignment == Alignment.Right) {\r\n        command = DocumentCommand.JustifyRight;\r\n        align = 'right';\r\n    }\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        execCommand(editor, command);\r\n        editor.queryElements(\r\n            '[align]',\r\n            QueryScope.OnSelection,\r\n            node => (node.style.textAlign = align)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import collapseSelectedBlocks from '../utils/collapseSelectedBlocks';\r\nimport { ChangeSource, Direction, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Change direction for the blocks/paragraph at selection\r\n * @param editor The editor instance\r\n * @param direction The direction option:\r\n * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'\r\n */\r\nexport default function setDirection(editor: IEditor, direction: Direction) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot((start, end) => {\r\n        collapseSelectedBlocks(editor, element => {\r\n            element.setAttribute('dir', direction == Direction.LeftToRight ? 'ltr' : 'rtl');\r\n            element.style.textAlign = direction == Direction.LeftToRight ? 'left' : 'right';\r\n        });\r\n        editor.select(start, end);\r\n    }, ChangeSource.Format);\r\n}\r\n","import { BlockElement, IEditor, NodeType } from 'roosterjs-editor-types';\r\nimport { getTagOfNode } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Collapse all selected blocks, return single HTML elements for each block\r\n * @param editor The editor instance\r\n * @param forEachCallback A callback function to invoke for each of the collapsed element\r\n */\r\nexport default function collapseSelectedBlocks(\r\n    editor: IEditor,\r\n    forEachCallback: (element: HTMLElement) => any\r\n) {\r\n    let traverser = editor.getSelectionTraverser();\r\n    let block = traverser && traverser.currentBlockElement;\r\n    let blocks: BlockElement[] = [];\r\n    while (block) {\r\n        if (!isEmptyBlockUnderTR(block)) {\r\n            blocks.push(block);\r\n        }\r\n        block = traverser.getNextBlockElement();\r\n    }\r\n\r\n    blocks.forEach(block => {\r\n        let element = block.collapseToSingleElement();\r\n        forEachCallback(element);\r\n    });\r\n}\r\n\r\nfunction isEmptyBlockUnderTR(block: BlockElement): boolean {\r\n    let startNode = block.getStartNode();\r\n\r\n    return (\r\n        startNode == block.getEndNode() &&\r\n        startNode.nodeType == NodeType.Text &&\r\n        ['TR', 'TABLE'].indexOf(getTagOfNode(startNode.parentNode)) >= 0\r\n    );\r\n}\r\n","import { ChangeSource, IEditor, QueryScope } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set image alt text for all selected images at selection. If no images is contained\r\n * in selection, do nothing.\r\n * The alt attribute provides alternative information for an image if a user for some reason\r\n * cannot view it (because of slow connection, an error in the src attribute, or if the user\r\n * uses a screen reader). See https://www.w3schools.com/tags/att_img_alt.asp\r\n * @param editor The editor instance\r\n * @param altText The image alt text\r\n */\r\nexport default function setImageAltText(editor: IEditor, altText: string) {\r\n    editor.focus();\r\n    editor.addUndoSnapshot(() => {\r\n        editor.queryElements('img', QueryScope.OnSelection, node =>\r\n            node.setAttribute('alt', altText)\r\n        );\r\n    }, ChangeSource.Format);\r\n}\r\n","import experimentSetIndentation from '../experiment/experimentSetIndentation';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    Indentation,\r\n    QueryScope,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Set indentation at selection\r\n * If selection contains bullet/numbering list, increase/decrease indentation will\r\n * increase/decrease the list level by one.\r\n * @param editor The editor instance\r\n * @param indentation The indentation option:\r\n * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation\r\n */\r\nexport default function setIndentation(editor: IEditor, indentation: Indentation) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewIndentation)) {\r\n        experimentSetIndentation(editor, indentation);\r\n    } else {\r\n        let command: DocumentCommand.Indent | DocumentCommand.Outdent =\r\n            indentation == Indentation.Increase ? DocumentCommand.Indent : DocumentCommand.Outdent;\r\n        editor.addUndoSnapshot(() => {\r\n            editor.focus();\r\n            let listNode = editor.getElementAtCursor('OL,UL');\r\n            let newNode: Node;\r\n\r\n            if (listNode) {\r\n                // There is already list node, setIndentation() will increase/decrease the list level,\r\n                // so we need to process the list when change indentation\r\n                newNode = processList(editor, command);\r\n            } else {\r\n                // No existing list node, browser will create <Blockquote> node for indentation.\r\n                // We need to set top and bottom margin to 0 to avoid unnecessary spaces\r\n                editor.getDocument().execCommand(command, false, null);\r\n                editor.queryElements('BLOCKQUOTE', QueryScope.OnSelection, node => {\r\n                    newNode = newNode || node;\r\n                    node.style.marginTop = '0px';\r\n                    node.style.marginBottom = '0px';\r\n                });\r\n            }\r\n\r\n            return newNode;\r\n        }, ChangeSource.Format);\r\n    }\r\n}\r\n","import blockFormat from '../utils/blockFormat';\r\nimport { BlockElement, IEditor, Indentation, RegionBase } from 'roosterjs-editor-types';\r\nimport {\r\n    collapseNodesInRegion,\r\n    createVListFromRegion,\r\n    findClosestElementAncestor,\r\n    getSelectedBlockElementsInRegion,\r\n    getTagOfNode,\r\n    isNodeInRegion,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst BlockWrapper = '<blockquote style=\"margin-top:0;margin-bottom:0\"></blockquote>';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default function experimentSetIndentation(editor: IEditor, indentation: Indentation) {\r\n    const handler = indentation == Indentation.Increase ? indent : outdent;\r\n\r\n    blockFormat(editor, (region, start, end) => {\r\n        const blocks = getSelectedBlockElementsInRegion(region, true /*createBlockIfEmpty*/);\r\n        const blockGroups: BlockElement[][] = [[]];\r\n\r\n        for (let i = 0; i < blocks.length; i++) {\r\n            const startNode = blocks[i].getStartNode();\r\n            const vList = createVListFromRegion(region, true /*includeSiblingLists*/, startNode);\r\n\r\n            if (vList) {\r\n                blockGroups.push([]);\r\n                while (blocks[i + 1] && vList.contains(blocks[i + 1].getStartNode())) {\r\n                    i++;\r\n                }\r\n                vList.setIndentation(start, end, indentation);\r\n                vList.writeBack();\r\n            } else {\r\n                blockGroups[blockGroups.length - 1].push(blocks[i]);\r\n            }\r\n        }\r\n\r\n        blockGroups.forEach(group => handler(region, group));\r\n    });\r\n}\r\n\r\nfunction indent(region: RegionBase, blocks: BlockElement[]) {\r\n    const nodes = collapseNodesInRegion(region, blocks);\r\n    wrap(nodes, BlockWrapper);\r\n}\r\n\r\nfunction outdent(region: RegionBase, blocks: BlockElement[]) {\r\n    blocks.forEach(blockElement => {\r\n        let node = blockElement.collapseToSingleElement();\r\n        const quote = findClosestElementAncestor(node, region.rootNode, 'blockquote');\r\n        if (quote) {\r\n            if (node == quote) {\r\n                node = wrap(toArray(node.childNodes));\r\n            }\r\n\r\n            while (isNodeInRegion(region, node) && getTagOfNode(node) != 'BLOCKQUOTE') {\r\n                node = splitBalancedNodeRange(node);\r\n            }\r\n\r\n            if (isNodeInRegion(region, node)) {\r\n                unwrap(node);\r\n            }\r\n        }\r\n    });\r\n}\r\n","import { IEditor } from 'roosterjs-editor-types';\r\nimport { Capitalization, NodeType } from 'roosterjs-editor-types';\r\nimport applyInlineStyle from '../utils/applyInlineStyle';\r\nimport { getFirstLeafNode, getNextLeafSibling } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Change the capitalization of text in the selection\r\n * @param editor The editor instance\r\n * @param capitalization The case option\r\n * @param language Optional parameter for language string that should comply to \"IETF BCP 47 Tags for\r\n * Identifying Languages\". For example: 'en' or 'en-US' for English, 'tr' for Turkish.\r\n * Default is the host environment’s current locale.\r\n */\r\nexport default function changeCapitalization(\r\n    editor: IEditor,\r\n    capitalization: Capitalization,\r\n    language?: string\r\n) {\r\n    applyInlineStyle(editor, element => {\r\n        for (let node = getFirstLeafNode(element); node; node = getNextLeafSibling(element, node)) {\r\n            if (node.nodeType == NodeType.Text) {\r\n                try {\r\n                    node.textContent = getCapitalizedText(node.textContent, language);\r\n                } catch {\r\n                    node.textContent = getCapitalizedText(node.textContent, undefined);\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    function getCapitalizedText(originalText: string, language: string): string {\r\n        switch (capitalization) {\r\n            case Capitalization.Lowercase:\r\n                return originalText.toLocaleLowerCase(language);\r\n            case Capitalization.Uppercase:\r\n                return originalText.toLocaleUpperCase(language);\r\n            case Capitalization.CapitalizeEachWord:\r\n                const wordArray = originalText.toLocaleLowerCase(language).split(' ');\r\n                for (let i = 0; i < wordArray.length; i++) {\r\n                    wordArray[i] =\r\n                        wordArray[i].charAt(0).toLocaleUpperCase(language) + wordArray[i].slice(1);\r\n                }\r\n                return wordArray.join(' ');\r\n            case Capitalization.Sentence:\r\n                // TODO: Add rules on punctuation for internationalization - TASK 104769\r\n                const punctuationMarks = '[\\\\.\\\\!\\\\?]';\r\n                // Find a match of a word character either:\r\n                // - At the beginning of a string with or without preceding whitespace, for\r\n                // example: '  hello world' and 'hello world' strings would both match 'h'.\r\n                // - Or preceded by a punctuation mark and at least one whitespace, for\r\n                // example 'yes. hello world' would match 'y' and 'h'.\r\n                const regex = new RegExp('^\\\\s*\\\\w|' + punctuationMarks + '\\\\s+\\\\w', 'g');\r\n                return originalText.toLocaleLowerCase(language).replace(regex, match => {\r\n                    return match.toLocaleUpperCase(language);\r\n                });\r\n        }\r\n    }\r\n}\r\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    ListType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle bullet at selection\r\n * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one\r\n * If selection contains number list, toggle bullet will convert the number list into bullet list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleBullet(editor: IEditor) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewBullet)) {\r\n        experimentToggleListType(editor, ListType.Unordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertUnorderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import experimentToggleListType from '../experiment/experimentToggleListType';\r\nimport processList from '../utils/processList';\r\nimport {\r\n    ChangeSource,\r\n    DocumentCommand,\r\n    IEditor,\r\n    ListType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle numbering at selection\r\n * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one\r\n * If selection contains bullet list, toggle numbering will convert the bullet list into number list\r\n * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding\r\n * realization of browser execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleNumbering(editor: IEditor) {\r\n    if (editor.isFeatureEnabled(ExperimentalFeatures.NewNumbering)) {\r\n        experimentToggleListType(editor, ListType.Ordered);\r\n    } else {\r\n        editor.focus();\r\n        editor.addUndoSnapshot(\r\n            () => processList(editor, DocumentCommand.InsertOrderedList),\r\n            ChangeSource.Format\r\n        );\r\n    }\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst BLOCKQUOTE_TAG = 'blockquote';\r\nconst DEFAULT_STYLER = (element: HTMLElement): void => {\r\n    element.style.borderLeft = '3px solid';\r\n    element.style.borderColor = '#C8C8C8';\r\n    element.style.paddingLeft = '10px';\r\n    element.style.color = '#666666';\r\n};\r\n\r\n/**\r\n * Toggle blockquote at selection, if selection already contains any blockquoted elements,\r\n * the blockquoted elements will be unblockquoted and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the blockquote element\r\n */\r\nexport default function toggleBlockQuote(editor: IEditor, styler?: (element: HTMLElement) => void) {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const wrapper = wrap(nodes, BLOCKQUOTE_TAG);\r\n            (styler || DEFAULT_STYLER)(wrapper);\r\n        },\r\n        () => editor.queryElements('blockquote', QueryScope.OnSelection, unwrap).length == 0\r\n    );\r\n}\r\n","import blockWrap from '../utils/blockWrap';\r\nimport { IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { unwrap, wrap } from 'roosterjs-editor-dom';\r\n\r\nconst PRE_TAG = 'pre';\r\nconst CODE_TAG = 'code';\r\nconst SELECTOR = `${PRE_TAG}>${CODE_TAG}`;\r\n\r\n/**\r\n * Toggle code block at selection, if selection already contains any code blocked elements,\r\n * the code block elements will be no longer be code blocked and other elements will take no affect\r\n * @param editor The editor instance\r\n * @param styler (Optional) The custom styler for setting the style for the code block element\r\n */\r\nexport default function toggleCodeBlock(\r\n    editor: IEditor,\r\n    styler?: (element: HTMLElement) => void\r\n): void {\r\n    blockWrap(\r\n        editor,\r\n        nodes => {\r\n            const code = wrap(nodes, CODE_TAG);\r\n            const pre = wrap(code, PRE_TAG);\r\n            styler?.(pre);\r\n        },\r\n        () =>\r\n            editor.queryElements(SELECTOR, QueryScope.OnSelection, code => {\r\n                if (!code.previousSibling && !code.nextSibling) {\r\n                    const parent = code.parentNode;\r\n                    unwrap(code);\r\n                    unwrap(parent);\r\n                }\r\n            }).length == 0\r\n    );\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle strikethrough at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only strikethrough text, the strikethrough style will be removed\r\n * If selection contains only normal text, strikethrough style will be added to the whole selected text\r\n * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleStrikethrough(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.StrikeThrough);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle subscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only subscript text, the subscript style will be removed\r\n * If selection contains only normal text, subscript style will be added to the whole selected text\r\n * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text\r\n * If selection contains any superscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSubscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Subscript);\r\n}\r\n","import execCommand from '../utils/execCommand';\r\nimport { DocumentCommand, IEditor } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Toggle superscript at selection\r\n * If selection is collapsed, it will only affect the input after caret\r\n * If selection contains only superscript text, the superscript style will be removed\r\n * If selection contains only normal text, superscript style will be added to the whole selected text\r\n * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text\r\n * If selection contains any subscript text, the behavior is determined by corresponding realization of browser\r\n * execCommand API\r\n * @param editor The editor instance\r\n */\r\nexport default function toggleSuperscript(editor: IEditor) {\r\n    execCommand(editor, DocumentCommand.Superscript);\r\n}\r\n","import { ChangeSource, DocumentCommand, IEditor, QueryScope } from 'roosterjs-editor-types';\r\nimport { HtmlSanitizer } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Toggle header at selection\r\n * @param editor The editor instance\r\n * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to\r\n * the HTML header element &lt;H1&gt; to &lt;H6&gt;, 0 means no header\r\n * if passed in param is outside the range, will be rounded to nearest number in the range\r\n */\r\nexport default function toggleHeader(editor: IEditor, level: number) {\r\n    level = Math.min(Math.max(Math.round(level), 0), 6);\r\n\r\n    editor.addUndoSnapshot(() => {\r\n        editor.focus();\r\n\r\n        let wrapped = false;\r\n        editor.queryElements('H1,H2,H3,H4,H5,H6', QueryScope.OnSelection, header => {\r\n            if (!wrapped) {\r\n                editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, '<DIV>');\r\n                wrapped = true;\r\n            }\r\n\r\n            let div = editor.getDocument().createElement('div');\r\n            while (header.firstChild) {\r\n                div.appendChild(header.firstChild);\r\n            }\r\n            editor.replaceNode(header, div);\r\n        });\r\n\r\n        if (level > 0) {\r\n            let traverser = editor.getSelectionTraverser();\r\n            let blockElement = traverser ? traverser.currentBlockElement : null;\r\n            let sanitizer = new HtmlSanitizer({\r\n                cssStyleCallbacks: {\r\n                    'font-size': () => false,\r\n                },\r\n            });\r\n            while (blockElement) {\r\n                let element = blockElement.collapseToSingleElement();\r\n                sanitizer.sanitize(element);\r\n                blockElement = traverser.getNextBlockElement();\r\n            }\r\n            editor.getDocument().execCommand(DocumentCommand.FormatBlock, false, `<H${level}>`);\r\n        }\r\n    }, ChangeSource.Format);\r\n}\r\n","import { Browser, getComputedStyle, Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    BuildInEditFeature,\r\n    CursorFeatureSettings,\r\n    Keys,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst NoCycleCursorMove: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.LEFT, Keys.RIGHT],\r\n    allowFunctionKeys: true,\r\n    shouldHandleEvent: (event, editor, ctrlOrMeta) => {\r\n        let range: Range;\r\n        let position: Position;\r\n\r\n        if (\r\n            !ctrlOrMeta ||\r\n            !(range = editor.getSelectionRange()) ||\r\n            !range.collapsed ||\r\n            !(position = Position.getStart(range)) ||\r\n            !editor.isPositionAtBeginning(position)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        let rtl = getComputedStyle(position.element, 'direction') == 'rtl';\r\n        let rawEvent = event.rawEvent;\r\n\r\n        return (!rtl && rawEvent.which == Keys.LEFT) || (rtl && rawEvent.which == Keys.RIGHT);\r\n    },\r\n    handleEvent: event => {\r\n        event.rawEvent.preventDefault();\r\n    },\r\n    defaultDisabled: !Browser.isChrome,\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const CursorFeatures: Record<\r\n    keyof CursorFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    noCycleCursorMove: NoCycleCursorMove,\r\n};\r\n","import {\r\n    cacheGetEventData,\r\n    getEntityFromElement,\r\n    getEntitySelector,\r\n    Position,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    BuildInEditFeature,\r\n    EntityFeatureSettings,\r\n    EntityOperation,\r\n    IEditor,\r\n    Keys,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * A content edit feature to trigger EntityOperation event with operation \"Click\" when user\r\n * clicks on a readonly entity.\r\n */\r\nconst ClickOnEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Click);\r\n    },\r\n};\r\n\r\n/**\r\n * A content edit feature to trigger EntityOperation event with operation \"Escape\" when user\r\n * presses ESC on a readonly entity.\r\n */\r\nconst EscapeFromEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ESCAPE],\r\n    shouldHandleEvent: (event, editor) => cacheGetReadonlyEntityElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        cacheGetReadonlyEntityElement(event, editor, EntityOperation.Escape);\r\n    },\r\n};\r\n\r\nfunction cacheGetReadonlyEntityElement(\r\n    event: PluginKeyboardEvent,\r\n    editor: IEditor,\r\n    operation?: EntityOperation\r\n) {\r\n    const element = cacheGetEventData(event, 'READONLY_ENTITY_ELEMENT', () => {\r\n        const node = event.rawEvent.target as Node;\r\n        const entityElement = node && editor.getElementAtCursor(getEntitySelector(), node);\r\n        return entityElement && !entityElement.isContentEditable ? entityElement : null;\r\n    });\r\n\r\n    if (element && operation !== undefined) {\r\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\r\n            operation,\r\n            rawEvent: event.rawEvent,\r\n            entity: getEntityFromElement(element),\r\n        });\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * A content edit feature to split current line into two lines at the cursor when user presses\r\n * ENTER right before a readonly entity.\r\n * Browser's default behavior will insert an extra BR tag before the entity which causes an extra\r\n * empty line. So we override the default behavior here.\r\n */\r\nconst EnterBeforeReadonlyEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) =>\r\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, false /*collapseOnly*/),\r\n    handleEvent: (event, editor) => {\r\n        event.rawEvent.preventDefault();\r\n\r\n        const range = editor.getSelectionRange();\r\n        const node = Position.getEnd(range).normalize().node;\r\n        const br = editor.getDocument().createElement('BR');\r\n        node.parentNode.insertBefore(br, node.nextSibling);\r\n\r\n        const block = editor.getBlockElementAtNode(node);\r\n        let newContainer: HTMLElement;\r\n\r\n        if (block) {\r\n            newContainer = block.collapseToSingleElement();\r\n            br.parentNode?.removeChild(br);\r\n        }\r\n\r\n        editor.getSelectionRange().deleteContents();\r\n\r\n        if (newContainer.nextSibling) {\r\n            editor.select(newContainer.nextSibling, PositionType.Begin);\r\n        }\r\n    },\r\n};\r\n\r\n/**\r\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromEnd\" when user\r\n * press BACKSPACE right after an entity\r\n */\r\nconst BackspaceAfterEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) =>\r\n        cacheGetNeighborEntityElement(event, editor, false /*isNext*/, true /*collapseOnly*/),\r\n    handleEvent: (event, editor) => {\r\n        cacheGetNeighborEntityElement(\r\n            event,\r\n            editor,\r\n            false /*isNext*/,\r\n            true /*collapseOnly*/,\r\n            EntityOperation.RemoveFromEnd\r\n        );\r\n    },\r\n};\r\n\r\n/**\r\n * A content edit feature to trigger EntityOperation event with operation \"RemoveFromStart\" when user\r\n * press DELETE right after an entity\r\n */\r\nconst DeleteBeforeEntityFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.DELETE],\r\n    shouldHandleEvent: (event, editor) =>\r\n        cacheGetNeighborEntityElement(event, editor, true /*isNext*/, true /*collapseOnly*/),\r\n    handleEvent: (event, editor) => {\r\n        cacheGetNeighborEntityElement(\r\n            event,\r\n            editor,\r\n            true /*isNext*/,\r\n            true /*collapseOnly*/,\r\n            EntityOperation.RemoveFromStart\r\n        );\r\n    },\r\n};\r\n\r\nfunction cacheGetNeighborEntityElement(\r\n    event: PluginKeyboardEvent,\r\n    editor: IEditor,\r\n    isNext: boolean,\r\n    collapseOnly: boolean,\r\n    operation?: EntityOperation\r\n): HTMLElement {\r\n    const element = cacheGetEventData(\r\n        event,\r\n        'NEIGHBOR_ENTITY_ELEMENT_' + isNext + '_' + collapseOnly,\r\n        () => {\r\n            const range = editor.getSelectionRange();\r\n\r\n            if (collapseOnly && !range.collapsed) {\r\n                return null;\r\n            }\r\n\r\n            const pos = Position.getEnd(range).normalize();\r\n            const isAtBeginOrEnd = pos.offset == 0 || pos.isAtEnd;\r\n            let entityNode: HTMLElement = null;\r\n\r\n            if (isAtBeginOrEnd) {\r\n                const traverser = editor.getBodyTraverser(pos.node);\r\n                const sibling = isNext\r\n                    ? pos.offset == 0\r\n                        ? traverser.currentInlineElement\r\n                        : traverser.getNextInlineElement()\r\n                    : pos.isAtEnd\r\n                    ? traverser.currentInlineElement\r\n                    : traverser.getPreviousInlineElement();\r\n                let node = sibling && sibling.getContainerNode();\r\n\r\n                if (!collapseOnly) {\r\n                    const block = editor.getBlockElementAtNode(pos.node);\r\n                    if (!block || !block.contains(node)) {\r\n                        node = null;\r\n                    }\r\n                }\r\n\r\n                entityNode = node && editor.getElementAtCursor(getEntitySelector(), node);\r\n            }\r\n\r\n            return entityNode;\r\n        }\r\n    );\r\n\r\n    if (element && operation !== undefined) {\r\n        editor.triggerPluginEvent(PluginEventType.EntityOperation, {\r\n            operation,\r\n            rawEvent: event.rawEvent,\r\n            entity: getEntityFromElement(element),\r\n        });\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const EntityFeatures: Record<\r\n    keyof EntityFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    clickOnEntity: ClickOnEntityFeature,\r\n    escapeFromEntity: EscapeFromEntityFeature,\r\n    enterBeforeReadonlyEntity: EnterBeforeReadonlyEntityFeature,\r\n    backspaceAfterEntity: BackspaceAfterEntityFeature,\r\n    deleteBeforeEntity: DeleteBeforeEntityFeature,\r\n};\r\n","import experimentToggleListType from 'roosterjs-editor-api/lib/experiment/experimentToggleListType';\r\nimport {\r\n    experimentCommitListChains,\r\n    setIndentation,\r\n    toggleBullet,\r\n    toggleNumbering,\r\n} from 'roosterjs-editor-api';\r\nimport {\r\n    Browser,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n    Position,\r\n    VListChain,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    BuildInEditFeature,\r\n    IEditor,\r\n    Indentation,\r\n    ListFeatureSettings,\r\n    Keys,\r\n    NodeType,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    ListType,\r\n    QueryScope,\r\n    RegionBase,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * IndentWhenTab edit feature, provides the ability to indent current list when user press TAB\r\n */\r\nconst IndentWhenTab: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        !event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Increase);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * OutdentWhenShiftTab edit feature, provides the ability to outdent current list when user press Shift+TAB\r\n */\r\nconst OutdentWhenShiftTab: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: (event, editor) =>\r\n        event.rawEvent.shiftKey && cacheGetListElement(event, editor),\r\n    handleEvent: (event, editor) => {\r\n        setIndentation(editor, Indentation.Decrease);\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * MergeInNewLine edit feature, provides the ability to merge current line into a new line when user press\r\n * BACKSPACE at beginning of a list item\r\n */\r\nconst MergeInNewLine: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\r\n        let range = editor.getSelectionRange();\r\n        return li && range && isPositionAtBeginningOf(Position.getStart(range), li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\r\n        if (li.previousSibling) {\r\n            const chains = getListChains(editor);\r\n            editor.runAsync(editor => {\r\n                let br = editor.getDocument().createElement('BR');\r\n                editor.insertNode(br);\r\n                editor.select(br, PositionType.After);\r\n                experimentCommitListChains(editor, chains);\r\n            });\r\n        } else {\r\n            toggleListAndPreventDefault(event, editor);\r\n        }\r\n    },\r\n    defaultDisabled: true,\r\n};\r\n\r\n/**\r\n * OutdentWhenBackOn1stEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * BACKSPACE at the first and empty line of a list\r\n */\r\nconst OutdentWhenBackOn1stEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\r\n        return li && isNodeEmpty(li) && !li.previousSibling;\r\n    },\r\n    handleEvent: toggleListAndPreventDefault,\r\n};\r\n\r\n/**\r\n * OutdentWhenEnterOnEmptyLine edit feature, provides the ability to outdent current item if user press\r\n * ENTER at the beginning of an empty line of a list\r\n */\r\nconst OutdentWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let li = editor.getElementAtCursor('LI', null /*startFrom*/, event);\r\n        return !event.rawEvent.shiftKey && li && isNodeEmpty(li);\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.addUndoSnapshot(\r\n            () => toggleListAndPreventDefault(event, editor),\r\n            null /*changeSource*/,\r\n            true /*canUndoByBackspace*/\r\n        );\r\n    },\r\n    defaultDisabled: !Browser.isIE && !Browser.isChrome,\r\n};\r\n\r\n/**\r\n * AutoBullet edit feature, provides the ablility to automatically convert current line into a list.\r\n * When user input \"1. \", convert into a numbering list\r\n * When user input \"- \" or \"* \", convert into a bullet list\r\n */\r\nconst AutoBullet: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.SPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        if (!cacheGetListElement(event, editor)) {\r\n            let searcher = editor.getContentSearcherOfCursor(event);\r\n            let textBeforeCursor = searcher.getSubStringBefore(4);\r\n\r\n            // Auto list is triggered if:\r\n            // 1. Text before cursor exactly mathces '*', '-' or '1.'\r\n            // 2. There's no non-text inline entities before cursor\r\n            return (\r\n                /^(\\*|-|[0-9]{1,2}\\.)$/.test(textBeforeCursor) &&\r\n                !searcher.getNearestNonTextInlineElement()\r\n            );\r\n        }\r\n        return false;\r\n    },\r\n    handleEvent: (event, editor) => {\r\n        editor.runAsync(editor => {\r\n            editor.addUndoSnapshot(\r\n                () => {\r\n                    let regions: RegionBase[];\r\n                    let searcher = editor.getContentSearcherOfCursor();\r\n                    let textBeforeCursor = searcher.getSubStringBefore(4);\r\n                    let rangeToDelete = searcher.getRangeFromText(\r\n                        textBeforeCursor,\r\n                        true /*exactMatch*/\r\n                    );\r\n\r\n                    if (!rangeToDelete) {\r\n                        // no op if the range can't be found\r\n                    } else if (\r\n                        textBeforeCursor.indexOf('*') == 0 ||\r\n                        textBeforeCursor.indexOf('-') == 0\r\n                    ) {\r\n                        prepareAutoBullet(editor, rangeToDelete);\r\n                        toggleBullet(editor);\r\n                    } else if (textBeforeCursor.indexOf('1.') == 0) {\r\n                        prepareAutoBullet(editor, rangeToDelete);\r\n                        toggleNumbering(editor);\r\n                    } else if (\r\n                        editor.isFeatureEnabled(ExperimentalFeatures.ListChain) &&\r\n                        (regions = editor.getSelectedRegions()) &&\r\n                        regions.length == 1\r\n                    ) {\r\n                        const num = parseInt(textBeforeCursor);\r\n                        prepareAutoBullet(editor, rangeToDelete);\r\n                        experimentToggleListType(editor, ListType.Ordered, num);\r\n                    }\r\n                },\r\n                null /*changeSource*/,\r\n                true /*canUndoByBackspace*/\r\n            );\r\n        });\r\n    },\r\n};\r\n\r\n/**\r\n * Maintain the list numbers in list chain\r\n * e.g. we have two lists:\r\n * 1, 2, 3 and 4, 5, 6\r\n * Now we delete list item 2, so the first one becomes \"1, 2\".\r\n * This edit feature can maintain the list number of the second list to become \"3, 4, 5\"\r\n */\r\nconst MaintainListChain: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER, Keys.TAB, Keys.DELETE, Keys.BACKSPACE, Keys.RANGE],\r\n    shouldHandleEvent: (event, editor) =>\r\n        editor.queryElements('li', QueryScope.OnSelection).length > 0,\r\n    handleEvent: (event, editor) => {\r\n        const chains = getListChains(editor);\r\n        editor.runAsync(editor => experimentCommitListChains(editor, chains));\r\n    },\r\n};\r\n\r\nfunction getListChains(editor: IEditor) {\r\n    return editor.isFeatureEnabled(ExperimentalFeatures.ListChain)\r\n        ? VListChain.createListChains(editor.getSelectedRegions())\r\n        : [];\r\n}\r\n\r\nfunction prepareAutoBullet(editor: IEditor, range: Range) {\r\n    range.deleteContents();\r\n    const node = range.startContainer;\r\n    if (node?.nodeType == NodeType.Text && node.nodeValue == '' && !node.nextSibling) {\r\n        const br = editor.getDocument().createElement('BR');\r\n        editor.insertNode(br);\r\n        editor.select(br, PositionType.Before);\r\n    }\r\n}\r\n\r\nfunction toggleListAndPreventDefault(event: PluginKeyboardEvent, editor: IEditor) {\r\n    let listInfo = cacheGetListElement(event, editor);\r\n    if (listInfo) {\r\n        let listElement = listInfo[0];\r\n        let tag = getTagOfNode(listElement);\r\n        if (tag == 'UL') {\r\n            toggleBullet(editor);\r\n        } else if (tag == 'OL') {\r\n            toggleNumbering(editor);\r\n        }\r\n        editor.focus();\r\n        event.rawEvent.preventDefault();\r\n    }\r\n}\r\n\r\nfunction cacheGetListElement(event: PluginKeyboardEvent, editor: IEditor) {\r\n    let li = editor.getElementAtCursor('LI,TABLE', null /*startFrom*/, event);\r\n    let listElement = li && getTagOfNode(li) == 'LI' && editor.getElementAtCursor('UL,OL', li);\r\n    return listElement ? [listElement, li] : null;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const ListFeatures: Record<\r\n    keyof ListFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    autoBullet: AutoBullet,\r\n    indentWhenTab: IndentWhenTab,\r\n    outdentWhenShiftTab: OutdentWhenShiftTab,\r\n    outdentWhenBackspaceOnEmptyFirstLine: OutdentWhenBackOn1stEmptyLine,\r\n    outdentWhenEnterOnEmptyLine: OutdentWhenEnterOnEmptyLine,\r\n    mergeInNewLineWhenBackspaceOnFirstChar: MergeInNewLine,\r\n    maintainListChain: MaintainListChain,\r\n};\r\n","import { cacheGetEventData, createRange } from 'roosterjs-editor-dom';\r\nimport {\r\n    BuildInEditFeature,\r\n    ChangeSource,\r\n    IEditor,\r\n    Keys,\r\n    MarkdownFeatureSettings,\r\n    NodePosition,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst ZERO_WIDTH_SPACE = '\\u200B';\r\n\r\nfunction generateBasicMarkdownFeature(\r\n    key: Keys,\r\n    triggerCharacter: string,\r\n    elementTag: string,\r\n    useShiftKey: boolean\r\n): BuildInEditFeature<PluginKeyboardEvent> {\r\n    return {\r\n        keys: [key],\r\n        shouldHandleEvent: (event, editor) =>\r\n            event.rawEvent.shiftKey === useShiftKey &&\r\n            !!cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter),\r\n        handleEvent: (event, editor) => {\r\n            // runAsync is here to allow the event to complete so autocomplete will present the trigger character.\r\n            editor.runAsync(editor => {\r\n                handleMarkdownEvent(event, editor, triggerCharacter, elementTag);\r\n            });\r\n        },\r\n    };\r\n}\r\n\r\nfunction cacheGetRangeForMarkdownOperation(\r\n    event: PluginKeyboardEvent,\r\n    editor: IEditor,\r\n    triggerCharacter: string\r\n): Range {\r\n    return cacheGetEventData(event, 'MARKDOWN_RANGE', () => {\r\n        const searcher = editor.getContentSearcherOfCursor(event);\r\n\r\n        let startPosition: NodePosition;\r\n        let endPosition: NodePosition;\r\n        searcher.forEachTextInlineElement(textInlineElement => {\r\n            if (endPosition && startPosition) {\r\n                return true;\r\n            }\r\n            const inlineTextContent = textInlineElement.getTextContent();\r\n\r\n            // special case for immediately preceeding character being whitespace\r\n            if (inlineTextContent[inlineTextContent.length - 1].trim().length == 0) {\r\n                return false;\r\n            }\r\n\r\n            // special case for consecutive trigger characters\r\n            if (inlineTextContent[inlineTextContent.length - 1] === triggerCharacter) {\r\n                return false;\r\n            }\r\n\r\n            if (!endPosition) {\r\n                endPosition = textInlineElement.getStartPosition().move(inlineTextContent.length);\r\n            }\r\n            if (inlineTextContent[0] == triggerCharacter) {\r\n                startPosition = textInlineElement.getStartPosition();\r\n            } else {\r\n                let contentIndex = inlineTextContent.length - 1;\r\n                for (; contentIndex > 0; contentIndex--) {\r\n                    if (startPosition) {\r\n                        return true;\r\n                    }\r\n                    if (\r\n                        inlineTextContent[contentIndex] == triggerCharacter &&\r\n                        inlineTextContent[contentIndex - 1].trim().length == 0\r\n                    ) {\r\n                        startPosition = textInlineElement.getStartPosition().move(contentIndex);\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return !!startPosition && !!endPosition && createRange(startPosition, endPosition);\r\n    });\r\n}\r\n\r\nfunction handleMarkdownEvent(\r\n    event: PluginKeyboardEvent,\r\n    editor: IEditor,\r\n    triggerCharacter: string,\r\n    elementTag: string\r\n) {\r\n    editor.addUndoSnapshot(\r\n        () => {\r\n            const range = cacheGetRangeForMarkdownOperation(event, editor, triggerCharacter);\r\n            if (!!range) {\r\n                // get the text content range\r\n                const textContentRange = range.cloneRange();\r\n                textContentRange.setStart(\r\n                    textContentRange.startContainer,\r\n                    textContentRange.startOffset + 1\r\n                );\r\n\r\n                // set the removal range to include the typed last character.\r\n                range.setEnd(range.endContainer, range.endOffset + 1);\r\n\r\n                // extract content and put it into a new element.\r\n                const elementToWrap = editor.getDocument().createElement(elementTag);\r\n                elementToWrap.appendChild(textContentRange.extractContents());\r\n                range.deleteContents();\r\n\r\n                // ZWS here ensures we don't end up inside the newly created node.\r\n                const nonPrintedSpaceTextNode = editor\r\n                    .getDocument()\r\n                    .createTextNode(ZERO_WIDTH_SPACE);\r\n                range.insertNode(nonPrintedSpaceTextNode);\r\n                range.insertNode(elementToWrap);\r\n                editor.select(nonPrintedSpaceTextNode, PositionType.End);\r\n            }\r\n        },\r\n        ChangeSource.Format,\r\n        true /*canUndoByBackspace*/\r\n    );\r\n}\r\n\r\n/**\r\n * Markdown bold feature. Bolds text with markdown shortcuts.\r\n */\r\nconst MarkdownBold: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\r\n    Keys.EIGHT_ASTIRISK,\r\n    '*',\r\n    'b',\r\n    true\r\n);\r\n\r\n/**\r\n * Markdown italics feature. Italicises text with markdown shortcuts.\r\n */\r\nconst MarkdownItalic: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\r\n    Keys.DASH_UNDERSCORE,\r\n    '_',\r\n    'i',\r\n    true\r\n);\r\n\r\n/**\r\n * Markdown strikethru feature. Strikethrus text with markdown shortcuts.\r\n */\r\nconst MarkdownStrikethru: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\r\n    Keys.GRAVE_TILDE,\r\n    '~',\r\n    's',\r\n    true\r\n);\r\n\r\n/**\r\n * Markdown inline code feature. Marks specific text as inline code with markdown shortcuts.\r\n */\r\nconst MarkdownInlineCode: BuildInEditFeature<PluginKeyboardEvent> = generateBasicMarkdownFeature(\r\n    Keys.GRAVE_TILDE,\r\n    '`',\r\n    'code',\r\n    false\r\n);\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const MarkdownFeatures: Record<\r\n    keyof MarkdownFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    markdownBold: MarkdownBold,\r\n    markdownItalic: MarkdownItalic,\r\n    markdownStrikethru: MarkdownStrikethru,\r\n    markdownInlineCode: MarkdownInlineCode,\r\n};\r\n","import {\r\n    BuildInEditFeature,\r\n    IEditor,\r\n    Keys,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    QuoteFeatureSettings,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    splitBalancedNodeRange,\r\n    toArray,\r\n    unwrap,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst QUOTE_TAG = 'BLOCKQUOTE';\r\nconst STRUCTURED_TAGS = [QUOTE_TAG, 'LI', 'TD', 'TH'].join(',');\r\n\r\n/**\r\n * UnquoteWhenBackOnEmpty1stLine edit feature, provides the ability to Unquote current line when\r\n * user press BACKSPACE on first and empty line of a BLOCKQUOTE\r\n */\r\nconst UnquoteWhenBackOnEmpty1stLine: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.BACKSPACE],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        return childOfQuote && isNodeEmpty(childOfQuote) && !childOfQuote.previousSibling;\r\n    },\r\n    handleEvent: splitQuote,\r\n};\r\n\r\n/**\r\n * UnquoteWhenEnterOnEmptyLine edit feature, provides the ability to Unquote current line when\r\n * user press ENTER on an empty line of a BLOCKQUOTE\r\n */\r\nconst UnquoteWhenEnterOnEmptyLine: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: (event, editor) => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let shift = event.rawEvent.shiftKey;\r\n        return !shift && childOfQuote && isNodeEmpty(childOfQuote);\r\n    },\r\n    handleEvent: (event, editor) =>\r\n        editor.addUndoSnapshot(\r\n            () => splitQuote(event, editor),\r\n            null /*changeSource*/,\r\n            true /*canUndoByBackspace*/\r\n        ),\r\n};\r\n\r\nfunction cacheGetQuoteChild(event: PluginKeyboardEvent, editor: IEditor): Node {\r\n    return cacheGetEventData(event, 'QUOTE_CHILD', () => {\r\n        let quote = editor.getElementAtCursor(STRUCTURED_TAGS);\r\n        if (quote && getTagOfNode(quote) == QUOTE_TAG) {\r\n            let pos = editor.getFocusedPosition();\r\n            let block = pos && editor.getBlockElementAtNode(pos.normalize().node);\r\n            if (block) {\r\n                let node =\r\n                    block.getStartNode() == quote\r\n                        ? block.getStartNode()\r\n                        : block.collapseToSingleElement();\r\n                return isNodeEmpty(node) ? node : null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\nfunction splitQuote(event: PluginKeyboardEvent, editor: IEditor) {\r\n    editor.addUndoSnapshot(() => {\r\n        let childOfQuote = cacheGetQuoteChild(event, editor);\r\n        let parent: Node;\r\n        if (getTagOfNode(childOfQuote) == QUOTE_TAG) {\r\n            childOfQuote = wrap(toArray(childOfQuote.childNodes));\r\n        }\r\n        parent = splitBalancedNodeRange(childOfQuote);\r\n        unwrap(parent);\r\n        editor.select(childOfQuote, PositionType.Begin);\r\n    });\r\n    event.rawEvent.preventDefault();\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const QuoteFeatures: Record<\r\n    keyof QuoteFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    unquoteWhenBackspaceOnEmptyFirstLine: UnquoteWhenBackOnEmpty1stLine,\r\n    unquoteWhenEnterOnEmptyLine: UnquoteWhenEnterOnEmptyLine,\r\n};\r\n","import { Browser, cacheGetEventData } from 'roosterjs-editor-dom';\r\nimport {\r\n    BuildInEditFeature,\r\n    FontSizeChange,\r\n    IEditor,\r\n    Keys,\r\n    PluginEventType,\r\n    PluginKeyboardEvent,\r\n    ShortcutFeatureSettings,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    changeFontSize,\r\n    toggleBold,\r\n    toggleItalic,\r\n    toggleUnderline,\r\n    toggleBullet,\r\n    toggleNumbering,\r\n} from 'roosterjs-editor-api';\r\n\r\ninterface ShortcutCommand {\r\n    winKey: number;\r\n    macKey: number;\r\n    action: (editor: IEditor) => any;\r\n}\r\n\r\nfunction createCommand(winKey: number, macKey: number, action: (editor: IEditor) => any) {\r\n    return {\r\n        winKey,\r\n        macKey,\r\n        action,\r\n    };\r\n}\r\n\r\nconst commands: ShortcutCommand[] = [\r\n    createCommand(Keys.Ctrl | Keys.B, Keys.Meta | Keys.B, toggleBold),\r\n    createCommand(Keys.Ctrl | Keys.I, Keys.Meta | Keys.I, toggleItalic),\r\n    createCommand(Keys.Ctrl | Keys.U, Keys.Meta | Keys.U, toggleUnderline),\r\n    createCommand(Keys.Ctrl | Keys.Z, Keys.Meta | Keys.Z, editor => editor.undo()),\r\n    createCommand(Keys.Ctrl | Keys.Y, Keys.Meta | Keys.Shift | Keys.Z, editor => editor.redo()),\r\n    createCommand(Keys.Ctrl | Keys.PERIOD, Keys.Meta | Keys.PERIOD, toggleBullet),\r\n    createCommand(Keys.Ctrl | Keys.FORWARDSLASH, Keys.Meta | Keys.FORWARDSLASH, toggleNumbering),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.PERIOD,\r\n        Keys.Meta | Keys.Shift | Keys.PERIOD,\r\n        editor => changeFontSize(editor, FontSizeChange.Increase)\r\n    ),\r\n    createCommand(\r\n        Keys.Ctrl | Keys.Shift | Keys.COMMA,\r\n        Keys.Meta | Keys.Shift | Keys.COMMA,\r\n        editor => changeFontSize(editor, FontSizeChange.Decrease)\r\n    ),\r\n];\r\n\r\n/**\r\n * DefaultShortcut edit feature, provides shortcuts for the following features:\r\n * Ctrl/Meta+B: toggle bold style\r\n * Ctrl/Meta+I: toggle italic style\r\n * Ctrl/Meta+U: toggle underline style\r\n * Ctrl/Meta+Z: undo\r\n * Ctrl+Y/Meta+Shift+Z: redo\r\n * Ctrl/Meta+PERIOD: toggle bullet list\r\n * Ctrl/Meta+/: toggle numbering list\r\n * Ctrl/Meta+Shift+>: increase font size\r\n * Ctrl/Meta+Shift+<: decrease font size\r\n */\r\nconst DefaultShortcut: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    allowFunctionKeys: true,\r\n    keys: [Keys.B, Keys.I, Keys.U, Keys.Y, Keys.Z, Keys.COMMA, Keys.PERIOD, Keys.FORWARDSLASH],\r\n    shouldHandleEvent: cacheGetCommand,\r\n    handleEvent: (event, editor) => {\r\n        let command = cacheGetCommand(event);\r\n        if (command) {\r\n            command.action(editor);\r\n            event.rawEvent.preventDefault();\r\n            event.rawEvent.stopPropagation();\r\n        }\r\n    },\r\n};\r\n\r\nfunction cacheGetCommand(event: PluginKeyboardEvent) {\r\n    return cacheGetEventData(event, 'DEFAULT_SHORT_COMMAND', () => {\r\n        let e = event.rawEvent;\r\n        let key =\r\n            // Need to check ALT key to be false since in some language (e.g. Polski) uses AltGr to input some special charactors\r\n            // In that case, ctrlKey and altKey are both true in Edge, but we should not trigger any shortcut function here\r\n            event.eventType == PluginEventType.KeyDown && !e.altKey\r\n                ? e.which |\r\n                  (e.metaKey && Keys.Meta) |\r\n                  (e.shiftKey && Keys.Shift) |\r\n                  (e.ctrlKey && Keys.Ctrl)\r\n                : 0;\r\n        return key && commands.filter(cmd => (Browser.isMac ? cmd.macKey : cmd.winKey) == key)[0];\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const ShortcutFeatures: Record<\r\n    keyof ShortcutFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    defaultShortcut: DefaultShortcut,\r\n};\r\n","import {\r\n    BuildInEditFeature,\r\n    IEditor,\r\n    Keys,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n    StructuredNodeFeatureSettings,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    cacheGetEventData,\r\n    fromHtml,\r\n    isPositionAtBeginningOf,\r\n    Position,\r\n    getTagOfNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Edge can sometimes lose current format when Enter to new line.\r\n// So here we add an extra SPAN for Edge to workaround this bug\r\nconst NEWLINE_HTML = Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>';\r\nconst CHILD_PARENT_TAG_MAP: { [childTag: string]: string } = {\r\n    TD: 'TABLE',\r\n    TH: 'TABLE',\r\n    LI: 'OL,UL',\r\n};\r\nconst CHILD_SELECTOR = Object.keys(CHILD_PARENT_TAG_MAP).join(',');\r\n\r\n/**\r\n * InsertLineBeforeStructuredNode edit feature, provides the ability to insert an empty line before\r\n * a structured element (bullet/numbering list, blockquote, table) if the element is at beginning of\r\n * document\r\n */\r\nconst InsertLineBeforeStructuredNodeFeature: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.ENTER],\r\n    shouldHandleEvent: cacheGetStructuredElement,\r\n    handleEvent: (event, editor) => {\r\n        let element = cacheGetStructuredElement(event, editor);\r\n        let div = fromHtml(NEWLINE_HTML, editor.getDocument())[0] as HTMLElement;\r\n        editor.addUndoSnapshot(() => {\r\n            element.parentNode.insertBefore(div, element);\r\n            // Select the new line when we are in table. This is the same behavior with Word\r\n            if (getTagOfNode(element) == 'TABLE') {\r\n                editor.select(new Position(div, PositionType.Begin).normalize());\r\n            }\r\n        });\r\n        event.rawEvent.preventDefault();\r\n    },\r\n    defaultDisabled: true,\r\n};\r\n\r\nfunction cacheGetStructuredElement(event: PluginKeyboardEvent, editor: IEditor) {\r\n    return cacheGetEventData(event, 'FIRST_STRUCTURE', () => {\r\n        // Provide a chance to keep browser default behavior by pressing SHIFT\r\n        let element = event.rawEvent.shiftKey ? null : editor.getElementAtCursor(CHILD_SELECTOR);\r\n\r\n        if (element) {\r\n            let range = editor.getSelectionRange();\r\n            if (\r\n                range &&\r\n                range.collapsed &&\r\n                isPositionAtBeginningOf(Position.getStart(range), element) &&\r\n                !editor.getBodyTraverser(element).getPreviousBlockElement()\r\n            ) {\r\n                return editor.getElementAtCursor(CHILD_PARENT_TAG_MAP[getTagOfNode(element)]);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const StructuredNodeFeatures: Record<\r\n    keyof StructuredNodeFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    insertLineBeforeStructuredNodeFeature: InsertLineBeforeStructuredNodeFeature,\r\n};\r\n","import { editTable } from 'roosterjs-editor-api';\r\nimport {\r\n    BuildInEditFeature,\r\n    IEditor,\r\n    Keys,\r\n    NodeType,\r\n    PluginEvent,\r\n    PositionType,\r\n    TableFeatureSettings,\r\n    TableOperation,\r\n    PluginKeyboardEvent,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    Browser,\r\n    cacheGetEventData,\r\n    contains,\r\n    getTagOfNode,\r\n    isVoidHtmlElement,\r\n    Position,\r\n    VTable,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * TabInTable edit feature, provides the ability to jump between cells when user press TAB in table\r\n */\r\nconst TabInTable: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.TAB],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let shift = event.rawEvent.shiftKey;\r\n        let td = cacheGetTableCell(event, editor);\r\n        for (\r\n            let vtable = new VTable(td),\r\n                step = shift ? -1 : 1,\r\n                row = vtable.row,\r\n                col = vtable.col + step;\r\n            ;\r\n            col += step\r\n        ) {\r\n            if (col < 0 || col >= vtable.cells[row].length) {\r\n                row += step;\r\n                if (row < 0) {\r\n                    editor.select(vtable.table, PositionType.Before);\r\n                    break;\r\n                } else if (row >= vtable.cells.length) {\r\n                    editTable(editor, TableOperation.InsertBelow);\r\n                    break;\r\n                }\r\n                col = shift ? vtable.cells[row].length - 1 : 0;\r\n            }\r\n            let cell = vtable.getCell(row, col);\r\n            if (cell.td) {\r\n                editor.select(cell.td, PositionType.Begin);\r\n                break;\r\n            }\r\n        }\r\n        event.rawEvent.preventDefault();\r\n    },\r\n};\r\n\r\n/**\r\n * UpDownInTable edit feature, provides the ability to jump to cell above/below when user press UP/DOWN\r\n * in table\r\n */\r\nconst UpDownInTable: BuildInEditFeature<PluginKeyboardEvent> = {\r\n    keys: [Keys.UP, Keys.DOWN],\r\n    shouldHandleEvent: cacheGetTableCell,\r\n    handleEvent: (event, editor) => {\r\n        let td = cacheGetTableCell(event, editor);\r\n        let vtable = new VTable(td);\r\n        let isUp = event.rawEvent.which == Keys.UP;\r\n        let step = isUp ? -1 : 1;\r\n        let targetTd: HTMLTableCellElement = null;\r\n        let hasShiftKey = event.rawEvent.shiftKey;\r\n        let { anchorNode, anchorOffset } = editor.getDocument().defaultView.getSelection();\r\n\r\n        for (let row = vtable.row; row >= 0 && row < vtable.cells.length; row += step) {\r\n            let cell = vtable.getCell(row, vtable.col);\r\n            if (cell.td && cell.td != td) {\r\n                targetTd = cell.td;\r\n                break;\r\n            }\r\n        }\r\n\r\n        editor.runAsync(editor => {\r\n            let newContainer = editor.getElementAtCursor();\r\n            if (\r\n                contains(vtable.table, newContainer) &&\r\n                !contains(td, newContainer, true /*treatSameNodeAsContain*/)\r\n            ) {\r\n                let newPos = targetTd\r\n                    ? new Position(targetTd, PositionType.Begin)\r\n                    : new Position(vtable.table, isUp ? PositionType.Before : PositionType.After);\r\n                if (hasShiftKey) {\r\n                    newPos =\r\n                        newPos.node.nodeType == NodeType.Element && isVoidHtmlElement(newPos.node)\r\n                            ? new Position(\r\n                                  newPos.node,\r\n                                  newPos.isAtEnd ? PositionType.After : PositionType.Before\r\n                              )\r\n                            : newPos;\r\n                    const selection = editor.getDocument().defaultView.getSelection();\r\n                    selection.setBaseAndExtent(\r\n                        anchorNode,\r\n                        anchorOffset,\r\n                        newPos.node,\r\n                        newPos.offset\r\n                    );\r\n                } else {\r\n                    editor.select(newPos);\r\n                }\r\n            }\r\n        });\r\n    },\r\n    defaultDisabled: !Browser.isChrome && !Browser.isSafari,\r\n};\r\n\r\nfunction cacheGetTableCell(event: PluginEvent, editor: IEditor): HTMLTableCellElement {\r\n    return cacheGetEventData(event, 'TABLECELL_FOR_TABLE_FEATURES', () => {\r\n        let pos = editor.getFocusedPosition();\r\n        let firstTd = pos && editor.getElementAtCursor('TD,TH,LI', pos.node);\r\n        return (\r\n            firstTd && (getTagOfNode(firstTd) == 'LI' ? null : (firstTd as HTMLTableCellElement))\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const TableFeatures: Record<\r\n    keyof TableFeatureSettings,\r\n    BuildInEditFeature<PluginKeyboardEvent>\r\n> = {\r\n    tabInTable: TabInTable,\r\n    upDownInTable: UpDownInTable,\r\n};\r\n","import { coreApiMap } from '../coreApi/coreApiMap';\r\nimport createCorePlugins, {\r\n    getPluginState,\r\n    PLACEHOLDER_PLUGIN_NAME,\r\n} from '../corePlugins/createCorePlugins';\r\nimport {\r\n    BlockElement,\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ColorTransformDirection,\r\n    ContentPosition,\r\n    CorePlugins,\r\n    DefaultFormat,\r\n    DOMEventHandler,\r\n    EditorCore,\r\n    EditorOptions,\r\n    EditorPlugin,\r\n    EditorUndoState,\r\n    ExperimentalFeatures,\r\n    GenericContentEditFeature,\r\n    GetContentMode,\r\n    IContentTraverser,\r\n    IEditor,\r\n    InsertOption,\r\n    IPositionContentSearcher,\r\n    NodePosition,\r\n    PluginEvent,\r\n    PluginEventData,\r\n    PluginEventFromType,\r\n    PluginEventType,\r\n    PositionType,\r\n    QueryScope,\r\n    Region,\r\n    RegionType,\r\n    SelectionPath,\r\n    StyleBasedFormatState,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    cacheGetEventData,\r\n    collapseNodes,\r\n    contains,\r\n    ContentTraverser,\r\n    createRange,\r\n    deleteSelectedContent,\r\n    getRegionsFromRange,\r\n    findClosestElementAncestor,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    getSelectionPath,\r\n    getTagOfNode,\r\n    isNodeEmpty,\r\n    safeInstanceOf,\r\n    Position,\r\n    PositionContentSearcher,\r\n    queryElements,\r\n    wrap,\r\n    isPositionAtBeginningOf,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * RoosterJs core editor class\r\n */\r\nexport default class Editor implements IEditor {\r\n    private core: EditorCore;\r\n\r\n    //#region Lifecycle\r\n\r\n    /**\r\n     * Creates an instance of Editor\r\n     * @param contentDiv The DIV HTML element which will be the container element of editor\r\n     * @param options An optional options object to customize the editor\r\n     */\r\n    constructor(contentDiv: HTMLDivElement, options: EditorOptions = {}) {\r\n        // 1. Make sure all parameters are valid\r\n        if (getTagOfNode(contentDiv) != 'DIV') {\r\n            throw new Error('contentDiv must be an HTML DIV element');\r\n        }\r\n\r\n        // 2. Store options values to local variables\r\n        const corePlugins = createCorePlugins(contentDiv, options);\r\n        const plugins: EditorPlugin[] = [];\r\n        Object.keys(corePlugins).forEach(\r\n            (name: typeof PLACEHOLDER_PLUGIN_NAME | keyof CorePlugins) => {\r\n                if (name == PLACEHOLDER_PLUGIN_NAME) {\r\n                    arrayPush(plugins, options.plugins);\r\n                } else {\r\n                    plugins.push(corePlugins[name]);\r\n                }\r\n            }\r\n        );\r\n        this.core = {\r\n            contentDiv,\r\n            api: {\r\n                ...coreApiMap,\r\n                ...(options.coreApiOverride || {}),\r\n            },\r\n            plugins: plugins.filter(x => !!x),\r\n            ...getPluginState(corePlugins),\r\n        };\r\n\r\n        // 3. Initialize plugins\r\n        this.core.plugins.forEach(plugin => plugin.initialize(this));\r\n\r\n        // 4. Ensure user will type in a container node, not the editor content DIV\r\n        this.ensureTypeInContainer(\r\n            new Position(this.core.contentDiv, PositionType.Begin).normalize()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this editor, dispose all plugins and custom data\r\n     */\r\n    public dispose(): void {\r\n        this.core.plugins.reverse().forEach(plugin => plugin.dispose());\r\n        this.core = null;\r\n    }\r\n\r\n    /**\r\n     * Get whether this editor is disposed\r\n     * @returns True if editor is disposed, otherwise false\r\n     */\r\n    public isDisposed(): boolean {\r\n        return !this.core;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Node API\r\n\r\n    /**\r\n     * Insert node into editor\r\n     * @param node The node to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     * @returns true if node is inserted. Otherwise false\r\n     */\r\n    public insertNode(node: Node, option?: InsertOption): boolean {\r\n        return node ? this.core.api.insertNode(this.core, node, option) : false;\r\n    }\r\n\r\n    /**\r\n     * Delete a node from editor content\r\n     * @param node The node to delete\r\n     * @returns true if node is deleted. Otherwise false\r\n     */\r\n    public deleteNode(node: Node): boolean {\r\n        // Only remove the node when it falls within editor\r\n        if (node && this.contains(node)) {\r\n            node.parentNode.removeChild(node);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Replace a node in editor content with another node\r\n     * @param existingNode The existing node to be replaced\r\n     * @param toNode node to replace to\r\n     * @param transformColorForDarkMode (optional) Whether to transform new node to dark mode. Default is false\r\n     * @returns true if node is replaced. Otherwise false\r\n     */\r\n    public replaceNode(\r\n        existingNode: Node,\r\n        toNode: Node,\r\n        transformColorForDarkMode?: boolean\r\n    ): boolean {\r\n        // Only replace the node when it falls within editor\r\n        if (this.contains(existingNode) && toNode) {\r\n            this.core.api.transformColor(\r\n                this.core,\r\n                transformColorForDarkMode ? toNode : null,\r\n                true /*includeSelf*/,\r\n                () => existingNode.parentNode.replaceChild(toNode, existingNode),\r\n                ColorTransformDirection.LightToDark\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get BlockElement at given node\r\n     * @param node The node to create InlineElement\r\n     * @returns The BlockElement result\r\n     */\r\n    public getBlockElementAtNode(node: Node): BlockElement {\r\n        return getBlockElementAtNode(this.core.contentDiv, node);\r\n    }\r\n\r\n    public contains(arg: Node | Range): boolean {\r\n        return contains(this.core.contentDiv, <Node>arg);\r\n    }\r\n\r\n    public queryElements(\r\n        selector: string,\r\n        scopeOrCallback: QueryScope | ((node: Node) => any) = QueryScope.Body,\r\n        callback?: (node: Node) => any\r\n    ) {\r\n        let scope = scopeOrCallback instanceof Function ? QueryScope.Body : scopeOrCallback;\r\n        callback = scopeOrCallback instanceof Function ? scopeOrCallback : callback;\r\n\r\n        let range = scope == QueryScope.Body ? null : this.getSelectionRange();\r\n        return queryElements(this.core.contentDiv, selector, callback, scope, range);\r\n    }\r\n\r\n    /**\r\n     * Collapse nodes within the given start and end nodes to their common ascenstor node,\r\n     * split parent nodes if necessary\r\n     * @param start The start node\r\n     * @param end The end node\r\n     * @param canSplitParent True to allow split parent node there are nodes before start or after end under the same parent\r\n     * and the returned nodes will be all nodes from start trhough end after splitting\r\n     * False to disallow split parent\r\n     * @returns When cansplitParent is true, returns all node from start through end after splitting,\r\n     * otherwise just return start and end\r\n     */\r\n    public collapseNodes(start: Node, end: Node, canSplitParent: boolean): Node[] {\r\n        return collapseNodes(this.core.contentDiv, start, end, canSplitParent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Content API\r\n\r\n    /**\r\n     * Check whether the editor contains any visible content\r\n     * @param trim Whether trime the content string before check. Default is false\r\n     * @returns True if there's no visible content, otherwise false\r\n     */\r\n    public isEmpty(trim?: boolean): boolean {\r\n        return isNodeEmpty(this.core.contentDiv, trim);\r\n    }\r\n\r\n    /**\r\n     * Get current editor content as HTML string\r\n     * @param mode specify what kind of HTML content to retrieve\r\n     * @returns HTML string representing current editor content\r\n     */\r\n    public getContent(mode: GetContentMode = GetContentMode.CleanHTML): string {\r\n        return this.core.api.getContent(this.core, mode);\r\n    }\r\n\r\n    /**\r\n     * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n     * @param content HTML content to set in\r\n     * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n     */\r\n    public setContent(content: string, triggerContentChangedEvent: boolean = true) {\r\n        this.core.api.setContent(this.core, content, triggerContentChangedEvent);\r\n    }\r\n\r\n    /**\r\n     * Insert HTML content into editor\r\n     * @param HTML content to insert\r\n     * @param option Insert options. Default value is:\r\n     *  position: ContentPosition.SelectionStart\r\n     *  updateCursor: true\r\n     *  replaceSelection: true\r\n     *  insertOnNewLine: false\r\n     */\r\n    public insertContent(content: string, option?: InsertOption) {\r\n        if (content) {\r\n            const doc = this.getDocument();\r\n            let allNodes = fromHtml(content, doc);\r\n\r\n            // If it is to insert on new line, and there are more than one node in the collection, wrap all nodes with\r\n            // a parent DIV before calling insertNode on each top level sub node. Otherwise, every sub node may get wrapped\r\n            // separately to show up on its own line\r\n            if (option && option.insertOnNewLine && allNodes.length > 1) {\r\n                allNodes = [wrap(allNodes)];\r\n            }\r\n\r\n            let fragment = doc.createDocumentFragment();\r\n            allNodes.forEach(node => fragment.appendChild(node));\r\n\r\n            this.insertNode(fragment, option);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete selected content\r\n     */\r\n    public deleteSelectedContent(): NodePosition {\r\n        const range = this.getSelectionRange();\r\n        return range && !range.collapsed && deleteSelectedContent(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Paste into editor using a clipboardData object\r\n     * @param clipboardData Clipboard data retrieved from clipboard\r\n     * @param pasteAsText Force pasting as plain text. Default value is false\r\n     * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n     * false to keep original foramt.  Default value is false. When pasteAsText is true, this parameter is ignored\r\n     */\r\n    public paste(\r\n        clipboardData: ClipboardData,\r\n        pasteAsText?: boolean,\r\n        applyCurrentFormat?: boolean\r\n    ) {\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n\r\n        if (clipboardData.snapshotBeforePaste) {\r\n            // Restore original content before paste a new one\r\n            this.setContent(clipboardData.snapshotBeforePaste);\r\n        } else {\r\n            clipboardData.snapshotBeforePaste = this.getContent(\r\n                GetContentMode.RawHTMLWithSelection\r\n            );\r\n        }\r\n\r\n        const range = this.getSelectionRange();\r\n        const pos = range && Position.getStart(range);\r\n        const fragment = this.core.api.createPasteFragment(\r\n            this.core,\r\n            clipboardData,\r\n            pos,\r\n            pasteAsText,\r\n            applyCurrentFormat\r\n        );\r\n\r\n        this.addUndoSnapshot(() => {\r\n            this.insertNode(fragment);\r\n            return clipboardData;\r\n        }, ChangeSource.Paste);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Focus and Selection\r\n\r\n    /**\r\n     * Get current selection range from Editor.\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now.\r\n     * Default value is true\r\n     * @returns current selection range, or null if editor never got focus before\r\n     */\r\n    public getSelectionRange(tryGetFromCache: boolean = true): Range {\r\n        return this.core.api.getSelectionRange(this.core, tryGetFromCache);\r\n    }\r\n\r\n    /**\r\n     * Get current selection in a serializable format\r\n     * It does a live pull on the selection, if nothing retrieved, return whatever we have in cache.\r\n     * @returns current selection path, or null if editor never got focus before\r\n     */\r\n    public getSelectionPath(): SelectionPath {\r\n        const range = this.getSelectionRange();\r\n        return range && getSelectionPath(this.core.contentDiv, range);\r\n    }\r\n\r\n    /**\r\n     * Check if focus is in editor now\r\n     * @returns true if focus is in editor, otherwise false\r\n     */\r\n    public hasFocus(): boolean {\r\n        return this.core.api.hasFocus(this.core);\r\n    }\r\n\r\n    /**\r\n     * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.\r\n     */\r\n    public focus() {\r\n        this.core.api.focus(this.core);\r\n    }\r\n\r\n    public select(arg1: any, arg2?: any, arg3?: any, arg4?: any): boolean {\r\n        let range = !arg1\r\n            ? null\r\n            : safeInstanceOf(arg1, 'Range')\r\n            ? arg1\r\n            : Array.isArray(arg1.start) && Array.isArray(arg1.end)\r\n            ? createRange(\r\n                  this.core.contentDiv,\r\n                  (<SelectionPath>arg1).start,\r\n                  (<SelectionPath>arg1).end\r\n              )\r\n            : createRange(arg1, arg2, arg3, arg4);\r\n        return this.contains(range) && this.core.api.selectRange(this.core, range);\r\n    }\r\n\r\n    /**\r\n     * Get current focused position. Return null if editor doesn't have focus at this time.\r\n     */\r\n    public getFocusedPosition(): NodePosition {\r\n        let sel = this.getDocument().defaultView.getSelection();\r\n        if (this.contains(sel && sel.focusNode)) {\r\n            return new Position(sel.focusNode, sel.focusOffset);\r\n        }\r\n\r\n        let range = this.getSelectionRange();\r\n        if (range) {\r\n            return Position.getStart(range);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an HTML element from current cursor position.\r\n     * When expectedTags is not specified, return value is the current node (if it is HTML element)\r\n     * or its parent node (if current node is a Text node).\r\n     * When expectedTags is specified, return value is the first anscestor of current node which has\r\n     * one of the expected tags.\r\n     * If no element found within editor by the given tag, return null.\r\n     * @param selector Optional, an HTML selector to find HTML element with.\r\n     * @param startFrom Start search from this node. If not specified, start from current focused position\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getElementAtCursor(\r\n        selector?: string,\r\n        startFrom?: Node,\r\n        event?: PluginEvent\r\n    ): HTMLElement {\r\n        event = startFrom ? null : event; // Only use cache when startFrom is not specified, for different start position can have different result\r\n\r\n        return cacheGetEventData(event, 'GET_ELEMENT_AT_CURSOR_' + selector, () => {\r\n            if (!startFrom) {\r\n                let position = this.getFocusedPosition();\r\n                startFrom = position && position.node;\r\n            }\r\n            return (\r\n                startFrom && findClosestElementAncestor(startFrom, this.core.contentDiv, selector)\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if this position is at beginning of the editor.\r\n     * This will return true if all nodes between the beginning of target node and the position are empty.\r\n     * @param position The position to check\r\n     * @returns True if position is at beginning of the editor, otherwise false\r\n     */\r\n    public isPositionAtBeginning(position: NodePosition): boolean {\r\n        return isPositionAtBeginningOf(position, this.core.contentDiv);\r\n    }\r\n\r\n    /**\r\n     * Get impacted regions from selection\r\n     */\r\n    public getSelectedRegions(type: RegionType = RegionType.Table): Region[] {\r\n        const range = this.getSelectionRange();\r\n        return range ? getRegionsFromRange(this.core.contentDiv, range, type) : [];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region EVENT API\r\n\r\n    public addDomEventHandler(\r\n        nameOrMap: string | Record<string, DOMEventHandler>,\r\n        handler?: DOMEventHandler\r\n    ): () => void {\r\n        const eventsToMap = typeof nameOrMap == 'string' ? { [nameOrMap]: handler } : nameOrMap;\r\n        return this.core.api.attachDomEvent(this.core, eventsToMap);\r\n    }\r\n\r\n    /**\r\n     * Trigger an event to be dispatched to all plugins\r\n     * @param eventType Type of the event\r\n     * @param data data of the event with given type, this is the rest part of PluginEvent with the given type\r\n     * @param broadcast indicates if the event needs to be dispatched to all plugins\r\n     * True means to all, false means to allow exclusive handling from one plugin unless no one wants that\r\n     * @returns the event object which is really passed into plugins. Some plugin may modify the event object so\r\n     * the result of this function provides a chance to read the modified result\r\n     */\r\n    public triggerPluginEvent<T extends PluginEventType>(\r\n        eventType: T,\r\n        data: PluginEventData<T>,\r\n        broadcast?: boolean\r\n    ): PluginEventFromType<T> {\r\n        let event = ({\r\n            eventType,\r\n            ...data,\r\n        } as any) as PluginEventFromType<T>;\r\n        this.core.api.triggerEvent(this.core, event, broadcast);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Trigger a ContentChangedEvent\r\n     * @param source Source of this event, by default is 'SetContent'\r\n     * @param data additional data for this event\r\n     */\r\n    public triggerContentChangedEvent(\r\n        source: ChangeSource | string = ChangeSource.SetContent,\r\n        data?: any\r\n    ) {\r\n        this.triggerPluginEvent(PluginEventType.ContentChanged, {\r\n            source,\r\n            data,\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Undo API\r\n\r\n    /**\r\n     * Undo last edit operation\r\n     */\r\n    public undo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, -1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Redo next edit operation\r\n     */\r\n    public redo() {\r\n        this.focus();\r\n        this.core.api.restoreUndoSnapshot(this.core, 1 /*step*/);\r\n    }\r\n\r\n    /**\r\n     * Add undo snapshot, and execute a format callback function, then add another undo snapshot, then trigger\r\n     * ContentChangedEvent with given change source.\r\n     * If this function is called nested, undo snapshot will only be added in the outside one\r\n     * @param callback The callback function to perform formatting, returns a data object which will be used as\r\n     * the data field in ContentChangedEvent if changeSource is not null.\r\n     * @param changeSource The change source to use when fire ContentChangedEvent. When the value is not null,\r\n     * a ContentChangedEvent will be fired with change source equal to this value\r\n     * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n     */\r\n    public addUndoSnapshot(\r\n        callback?: (start: NodePosition, end: NodePosition) => any,\r\n        changeSource?: ChangeSource | string,\r\n        canUndoByBackspace?: boolean\r\n    ) {\r\n        this.core.api.addUndoSnapshot(this.core, callback, changeSource, canUndoByBackspace);\r\n    }\r\n\r\n    /**\r\n     * Whether there is an available undo/redo snapshot\r\n     */\r\n    getUndoState(): EditorUndoState {\r\n        const { hasNewContent, snapshotsService } = this.core.undo;\r\n        return {\r\n            canUndo: hasNewContent || snapshotsService.canMove(-1 /*previousSnapshot*/),\r\n            canRedo: snapshotsService.canMove(1 /*nextSnapshot*/),\r\n        };\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Misc\r\n\r\n    /**\r\n     * Get document which contains this editor\r\n     * @returns The HTML document which contains this editor\r\n     */\r\n    public getDocument(): Document {\r\n        return this.core.contentDiv.ownerDocument;\r\n    }\r\n\r\n    /**\r\n     * Get the scroll container of the editor\r\n     */\r\n    public getScrollContainer(): HTMLElement {\r\n        return this.core.domEvent.scrollContainer;\r\n    }\r\n\r\n    /**\r\n     * Get custom data related to this editor\r\n     * @param key Key of the custom data\r\n     * @param getter Getter function. If custom data for the given key doesn't exist,\r\n     * call this function to get one and store it if it is specified. Otherwise return undefined\r\n     * @param disposer An optional disposer function to dispose this custom data when\r\n     * dispose editor.\r\n     */\r\n    public getCustomData<T>(key: string, getter?: () => T, disposer?: (value: T) => void): T {\r\n        return (this.core.lifecycle.customData[key] = this.core.lifecycle.customData[key] || {\r\n            value: getter ? getter() : undefined,\r\n            disposer,\r\n        }).value as T;\r\n    }\r\n\r\n    /**\r\n     * Check if editor is in IME input sequence\r\n     * @returns True if editor is in IME input sequence, otherwise false\r\n     */\r\n    public isInIME(): boolean {\r\n        return this.core.domEvent.isInIME;\r\n    }\r\n\r\n    /**\r\n     * Get default format of this editor\r\n     * @returns Default format object of this editor\r\n     */\r\n    public getDefaultFormat(): DefaultFormat {\r\n        return this.core.lifecycle.defaultFormat;\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for the whole editor\r\n     * @param startNode The node to start from. If not passed, it will start from the beginning of the body\r\n     */\r\n    public getBodyTraverser(startNode?: Node): IContentTraverser {\r\n        return ContentTraverser.createBodyTraverser(this.core.contentDiv, startNode);\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current selection\r\n     */\r\n    public getSelectionTraverser(): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range &&\r\n            ContentTraverser.createSelectionTraverser(\r\n                this.core.contentDiv,\r\n                this.getSelectionRange()\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a content traverser for current block element start from specified position\r\n     * @param startFrom Start position of the traverser. Default value is ContentPosition.SelectionStart\r\n     */\r\n    public getBlockTraverser(\r\n        startFrom: ContentPosition = ContentPosition.SelectionStart\r\n    ): IContentTraverser {\r\n        let range = this.getSelectionRange();\r\n        return (\r\n            range && ContentTraverser.createBlockTraverser(this.core.contentDiv, range, startFrom)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a text traverser of current selection\r\n     * @param event Optional, if specified, editor will try to get cached result from the event object first.\r\n     * If it is not cached before, query from DOM and cache the result into the event object\r\n     */\r\n    public getContentSearcherOfCursor(event?: PluginEvent): IPositionContentSearcher {\r\n        return cacheGetEventData(event, 'CONTENTSEARCHER', () => {\r\n            let range = this.getSelectionRange();\r\n            return (\r\n                range && new PositionContentSearcher(this.core.contentDiv, Position.getStart(range))\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Run a callback function asynchronously\r\n     * @param callback The callback function to run\r\n     */\r\n    public runAsync(callback: (editor: IEditor) => void) {\r\n        let win = this.core.contentDiv.ownerDocument.defaultView || window;\r\n        win.requestAnimationFrame(() => {\r\n            if (!this.isDisposed() && callback) {\r\n                callback(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     * @param value Value of the attribute\r\n     */\r\n    public setEditorDomAttribute(name: string, value: string) {\r\n        if (value === null) {\r\n            this.core.contentDiv.removeAttribute(name);\r\n        } else {\r\n            this.core.contentDiv.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get DOM attribute of editor content DIV\r\n     * @param name Name of the attribute\r\n     */\r\n    public getEditorDomAttribute(name: string): string {\r\n        return this.core.contentDiv.getAttribute(name);\r\n    }\r\n\r\n    /**\r\n     * Add a Content Edit feature.\r\n     * @param feature The feature to add\r\n     */\r\n    public addContentEditFeature(feature: GenericContentEditFeature<PluginEvent>) {\r\n        feature?.keys.forEach(key => {\r\n            let array = this.core.edit.features[key] || [];\r\n            array.push(feature);\r\n            this.core.edit.features[key] = array;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get style based format state from current selection, including font name/size and colors\r\n     */\r\n    public getStyleBasedFormatState(node?: Node): StyleBasedFormatState {\r\n        if (!node) {\r\n            const range = this.getSelectionRange();\r\n            node = range && Position.getStart(range).normalize().node;\r\n        }\r\n        return this.core.api.getStyleBasedFormatState(this.core, node);\r\n    }\r\n\r\n    /**\r\n     * Ensure user will type into a container element rather than into the editor content DIV directly\r\n     * @param position The position that user is about to type to\r\n     * @param keyboardEvent Optional keyboard event object\r\n     */\r\n    public ensureTypeInContainer(position: NodePosition, keyboardEvent?: KeyboardEvent) {\r\n        this.core.api.ensureTypeInContainer(this.core, position, keyboardEvent);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Dark mode APIs\r\n\r\n    /**\r\n     * Set the dark mode state and transforms the content to match the new state.\r\n     * @param nextDarkMode The next status of dark mode. True if the editor should be in dark mode, false if not.\r\n     */\r\n    public setDarkModeState(nextDarkMode?: boolean) {\r\n        if (this.isDarkMode() == nextDarkMode) {\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContent(GetContentMode.CleanHTML);\r\n\r\n        this.triggerContentChangedEvent(\r\n            nextDarkMode ? ChangeSource.SwitchToDarkMode : ChangeSource.SwitchToLightMode\r\n        );\r\n        this.setContent(currentContent);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor is in dark mode\r\n     * @returns True if the editor is in dark mode, otherwise false\r\n     */\r\n    public isDarkMode(): boolean {\r\n        return this.core.lifecycle.isDarkMode;\r\n    }\r\n\r\n    /**\r\n     * Check if the given experimental feature is enabled\r\n     * @param feature The feature to check\r\n     */\r\n    public isFeatureEnabled(feature: ExperimentalFeatures): boolean {\r\n        return this.core.lifecycle.experimentalFeatures.indexOf(feature) >= 0;\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","import { addUndoSnapshot } from './addUndoSnapshot';\r\nimport { attachDomEvent } from './attachDomEvent';\r\nimport { CoreApiMap } from 'roosterjs-editor-types';\r\nimport { createPasteFragment } from './createPasteFragment';\r\nimport { ensureTypeInContainer } from './ensureTypeInContainer';\r\nimport { focus } from './focus';\r\nimport { getContent } from './getContent';\r\nimport { getSelectionRange } from './getSelectionRange';\r\nimport { getStyleBasedFormatState } from './getStyleBasedFormatState';\r\nimport { hasFocus } from './hasFocus';\r\nimport { insertNode } from './insertNode';\r\nimport { restoreUndoSnapshot } from './restoreUndoSnapshot';\r\nimport { selectRange } from './selectRange';\r\nimport { setContent } from './setContent';\r\nimport { transformColor } from './transformColor';\r\nimport { triggerEvent } from './triggerEvent';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const coreApiMap: CoreApiMap = {\r\n    attachDomEvent,\r\n    addUndoSnapshot,\r\n    createPasteFragment,\r\n    ensureTypeInContainer,\r\n    focus,\r\n    getContent,\r\n    getSelectionRange,\r\n    getStyleBasedFormatState,\r\n    hasFocus,\r\n    insertNode,\r\n    restoreUndoSnapshot,\r\n    selectRange,\r\n    setContent,\r\n    transformColor,\r\n    triggerEvent,\r\n};\r\n","import { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    AddUndoSnapshot,\r\n    ChangeSource,\r\n    ContentChangedEvent,\r\n    EditorCore,\r\n    NodePosition,\r\n    PluginEventType,\r\n    GetContentMode,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Call an editing callback with adding undo snapshots around, and trigger a ContentChanged event if change source is specified.\r\n * Undo snapshot will not be added if this call is nested inside another addUndoSnapshot() call.\r\n * @param core The EditorCore object\r\n * @param callback The editing callback, accepting current selection start and end position, returns an optional object used as the data field of ContentChangedEvent.\r\n * @param changeSource The ChangeSource string of ContentChangedEvent. @default ChangeSource.Format. Set to null to avoid triggering ContentChangedEvent\r\n * @param canUndoByBackspace True if this action can be undone when user press Backspace key (aka Auto Complelte).\r\n */\r\nexport const addUndoSnapshot: AddUndoSnapshot = (\r\n    core: EditorCore,\r\n    callback: (start: NodePosition, end: NodePosition) => any,\r\n    changeSource: ChangeSource | string,\r\n    canUndoByBackspace: boolean\r\n) => {\r\n    const undoState = core.undo;\r\n    let isNested = undoState.isNested;\r\n    let data: any;\r\n\r\n    if (!isNested) {\r\n        undoState.isNested = true;\r\n        undoState.snapshotsService.addSnapshot(\r\n            core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\r\n            canUndoByBackspace\r\n        );\r\n        undoState.hasNewContent = false;\r\n    }\r\n\r\n    try {\r\n        if (callback) {\r\n            let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n            data = callback(\r\n                range && Position.getStart(range).normalize(),\r\n                range && Position.getEnd(range).normalize()\r\n            );\r\n\r\n            if (!isNested) {\r\n                undoState.snapshotsService.addSnapshot(\r\n                    core.api.getContent(core, GetContentMode.RawHTMLWithSelection),\r\n                    false /*isAutoCompleteSnapshot*/\r\n                );\r\n                undoState.hasNewContent = false;\r\n            }\r\n        }\r\n    } finally {\r\n        if (!isNested) {\r\n            undoState.isNested = false;\r\n        }\r\n    }\r\n\r\n    if (callback && changeSource) {\r\n        let event: ContentChangedEvent = {\r\n            eventType: PluginEventType.ContentChanged,\r\n            source: changeSource,\r\n            data: data,\r\n        };\r\n        core.api.triggerEvent(core, event, true /*broadcast*/);\r\n    }\r\n\r\n    if (canUndoByBackspace) {\r\n        const range = core.api.getSelectionRange(core, false /*tryGetFromCache*/);\r\n\r\n        if (range) {\r\n            core.undo.hasNewContent = false;\r\n            core.undo.autoCompletePosition = Position.getStart(range);\r\n        }\r\n    }\r\n};\r\n","import {\r\n    AttachDomEvent,\r\n    DOMEventHandler,\r\n    DOMEventHandlerObject,\r\n    EditorCore,\r\n    PluginDomEvent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Attach a DOM event to the editor content DIV\r\n * @param core The EditorCore object\r\n * @param eventName The DOM event name\r\n * @param pluginEventType Optional event type. When specified, editor will trigger a plugin event with this name when the DOM event is triggered\r\n * @param beforeDispatch Optional callback function to be invoked when the DOM event is triggered before trigger plugin event\r\n */\r\nexport const attachDomEvent: AttachDomEvent = (\r\n    core: EditorCore,\r\n    eventMap: Record<string, DOMEventHandler>\r\n) => {\r\n    const disposers = Object.keys(eventMap || {}).map(eventName => {\r\n        const { pluginEventType, beforeDispatch } = extractHandler(eventMap[eventName]);\r\n        let onEvent = (event: UIEvent) => {\r\n            if (beforeDispatch) {\r\n                beforeDispatch(event);\r\n            }\r\n            if (pluginEventType != null) {\r\n                core.api.triggerEvent(\r\n                    core,\r\n                    <PluginDomEvent>{\r\n                        eventType: pluginEventType,\r\n                        rawEvent: event,\r\n                    },\r\n                    false /*broadcast*/\r\n                );\r\n            }\r\n        };\r\n        core.contentDiv.addEventListener(eventName, onEvent);\r\n        return () => {\r\n            core.contentDiv.removeEventListener(eventName, onEvent);\r\n        };\r\n    });\r\n    return () => disposers.forEach(disposers => disposers());\r\n};\r\n\r\nfunction extractHandler(handlerObj: DOMEventHandler): DOMEventHandlerObject {\r\n    let result: DOMEventHandlerObject = {\r\n        pluginEventType: null,\r\n        beforeDispatch: null,\r\n    };\r\n\r\n    if (typeof handlerObj === 'number') {\r\n        result.pluginEventType = handlerObj;\r\n    } else if (typeof handlerObj === 'function') {\r\n        result.beforeDispatch = handlerObj;\r\n    } else if (typeof handlerObj === 'object') {\r\n        result = handlerObj;\r\n    }\r\n    return result;\r\n}\r\n","import {\r\n    applyFormat,\r\n    applyTextStyle,\r\n    createDefaultHtmlSanitizerOptions,\r\n    getInheritableStyles,\r\n    getPendableFormatState,\r\n    HtmlSanitizer,\r\n    toArray,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    BeforePasteEvent,\r\n    ClipboardData,\r\n    CreatePasteFragment,\r\n    EditorCore,\r\n    PluginEventType,\r\n    DefaultFormat,\r\n    NodePosition,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst START_FRAGMENT = '<!--StartFragment-->';\r\nconst END_FRAGMENT = '<!--EndFragment-->';\r\nconst NBSP_HTML = '\\u00A0';\r\n\r\n/**\r\n * @internal\r\n * Create a DocumentFragment for paste from a ClipboardData\r\n * @param core The EditorCore object.\r\n * @param clipboardData Clipboard data retrieved from clipboard\r\n * @param position The position to paste to\r\n * @param pasteAsText True to force use plain text as the content to paste, false to choose HTML or Image if any\r\n * @param applyCurrentStyle True if apply format of current selection to the pasted content,\r\n * false to keep original foramt\r\n */\r\nexport const createPasteFragment: CreatePasteFragment = (\r\n    core: EditorCore,\r\n    clipboardData: ClipboardData,\r\n    position: NodePosition,\r\n    pasteAsText: boolean,\r\n    applyCurrentStyle: boolean\r\n) => {\r\n    if (!clipboardData) {\r\n        return null;\r\n    }\r\n\r\n    // Step 1: Prepare BeforePasteEvent object\r\n    const event = createBeforePasteEvent(core, clipboardData);\r\n    const { fragment, sanitizingOption } = event;\r\n    const { rawHtml, text, imageDataUri } = clipboardData;\r\n    const document = core.contentDiv.ownerDocument;\r\n    let doc: HTMLDocument;\r\n\r\n    // Step 2: Fill the BeforePasteEvent object, especially the fragment for paste\r\n    if (!pasteAsText && !text && imageDataUri) {\r\n        // Paste image\r\n        const img = document.createElement('img');\r\n        img.style.maxWidth = '100%';\r\n        img.src = imageDataUri;\r\n        fragment.appendChild(img);\r\n    } else if (\r\n        !pasteAsText &&\r\n        rawHtml &&\r\n        (doc = new DOMParser().parseFromString(rawHtml, 'text/html'))?.body\r\n    ) {\r\n        // Paste HTML\r\n        const attributes = doc.querySelector('html')?.attributes;\r\n        (attributes ? toArray(attributes) : []).reduce((attrs, attr) => {\r\n            attrs[attr.name] = attr.value;\r\n            return attrs;\r\n        }, event.htmlAttributes);\r\n        toArray(doc.querySelectorAll('meta')).reduce((attrs, meta) => {\r\n            attrs[meta.name] = meta.content;\r\n            return attrs;\r\n        }, event.htmlAttributes);\r\n\r\n        // Move all STYLE nodes into header, and save them into sanitizing options.\r\n        // Because if we directly move them into a fragment, all sheets under STYLE will be lost.\r\n        processStyles(doc, style => {\r\n            doc.head.appendChild(style);\r\n            sanitizingOption.additionalGlobalStyleNodes.push(style);\r\n        });\r\n\r\n        const startIndex = rawHtml.indexOf(START_FRAGMENT);\r\n        const endIndex = rawHtml.lastIndexOf(END_FRAGMENT);\r\n\r\n        if (startIndex >= 0 && endIndex >= startIndex + START_FRAGMENT.length) {\r\n            event.htmlBefore = rawHtml.substr(0, startIndex);\r\n            event.htmlAfter = rawHtml.substr(endIndex + END_FRAGMENT.length);\r\n            doc.body.innerHTML = clipboardData.html = rawHtml.substring(\r\n                startIndex + START_FRAGMENT.length,\r\n                endIndex\r\n            );\r\n\r\n            // Remove style nodes just added by setting innerHTML of body since we already have all\r\n            // style nodes in header.\r\n            // Here we use doc.body instead of doc because we only want to remove STYLE nodes under BODY\r\n            // and the nodes under HEAD are still used when convert global CSS to inline\r\n            processStyles(doc.body, style => style.parentNode?.removeChild(style));\r\n        }\r\n\r\n        while (doc.body.firstChild) {\r\n            fragment.appendChild(doc.body.firstChild);\r\n        }\r\n\r\n        if (applyCurrentStyle && position) {\r\n            const format = getCurrentFormat(core, position.node);\r\n            applyTextStyle(fragment, node => applyFormat(node, format));\r\n        }\r\n    } else if (text) {\r\n        // Paste text\r\n        text.split('\\n').forEach((line, index, lines) => {\r\n            line = line\r\n                .replace(/^ /g, NBSP_HTML)\r\n                .replace(/\\r/g, '')\r\n                .replace(/ {2}/g, ' ' + NBSP_HTML);\r\n\r\n            const node = line == '' ? document.createElement('br') : document.createTextNode(line);\r\n\r\n            fragment.appendChild(index == 0 || index == lines.length - 1 ? node : wrap(node));\r\n        });\r\n    }\r\n\r\n    // Step 3: Trigger BeforePasteEvent so that plugins can do proper change before paste\r\n    core.api.triggerEvent(core, event, true /*broadcast*/);\r\n\r\n    // Step 4. Sanitize the fragment before paste to make sure the content is safe\r\n    const sanitizer = new HtmlSanitizer(event.sanitizingOption);\r\n\r\n    sanitizer.convertGlobalCssToInlineCss(fragment);\r\n    sanitizer.sanitize(fragment, position && getInheritableStyles(position.element));\r\n\r\n    return fragment;\r\n};\r\n\r\nfunction getCurrentFormat(core: EditorCore, node: Node): DefaultFormat {\r\n    const pendableFormat = getPendableFormatState(core.contentDiv.ownerDocument);\r\n    const styleBasedForamt = core.api.getStyleBasedFormatState(core, node);\r\n    return {\r\n        fontFamily: styleBasedForamt.fontName,\r\n        fontSize: styleBasedForamt.fontSize,\r\n        textColor: styleBasedForamt.textColor,\r\n        backgroundColor: styleBasedForamt.backgroundColor,\r\n        textColors: styleBasedForamt.textColors,\r\n        backgroundColors: styleBasedForamt.backgroundColors,\r\n        bold: pendableFormat.isBold,\r\n        italic: pendableFormat.isItalic,\r\n        underline: pendableFormat.isUnderline,\r\n    };\r\n}\r\n\r\nfunction createBeforePasteEvent(core: EditorCore, clipboardData: ClipboardData): BeforePasteEvent {\r\n    return {\r\n        eventType: PluginEventType.BeforePaste,\r\n        clipboardData,\r\n        fragment: core.contentDiv.ownerDocument.createDocumentFragment(),\r\n        sanitizingOption: createDefaultHtmlSanitizerOptions(),\r\n        htmlBefore: '',\r\n        htmlAfter: '',\r\n        htmlAttributes: {},\r\n    };\r\n}\r\n\r\nfunction processStyles(node: ParentNode, callback: (style: HTMLStyleElement) => void) {\r\n    toArray(node.querySelectorAll('style')).forEach(callback);\r\n}\r\n","import {\r\n    ContentPosition,\r\n    EditorCore,\r\n    EnsureTypeInContainer,\r\n    NodePosition,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    applyFormat,\r\n    Browser,\r\n    createRange,\r\n    fromHtml,\r\n    getBlockElementAtNode,\r\n    isNodeEmpty,\r\n    Position,\r\n    safeInstanceOf,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * When typing goes directly under content div, many things can go wrong\r\n * We fix it by wrapping it with a div and reposition cursor within the div\r\n */\r\nexport const ensureTypeInContainer: EnsureTypeInContainer = (\r\n    core: EditorCore,\r\n    position: NodePosition,\r\n    keyboardEvent?: KeyboardEvent\r\n) => {\r\n    position = position.normalize();\r\n    const block = getBlockElementAtNode(core.contentDiv, position.node);\r\n    let formatNode: HTMLElement;\r\n\r\n    if (block) {\r\n        formatNode = block.collapseToSingleElement();\r\n\r\n        // if the block is empty, apply default format\r\n        // Otherwise, leave it as it is as we don't want to change the style for existing data\r\n        // unless the block was just created by the keyboard event (e.g. ctrl+a & start typing)\r\n        const shouldSetNodeStyles =\r\n            isNodeEmpty(formatNode) ||\r\n            (keyboardEvent && wasNodeJustCreatedByKeyboardEvent(keyboardEvent, formatNode));\r\n        formatNode = formatNode && shouldSetNodeStyles ? formatNode : null;\r\n    } else {\r\n        // Only reason we don't get the selection block is that we have an empty content div\r\n        // which can happen when users removes everything (i.e. select all and DEL, or backspace from very end to begin)\r\n        // The fix is to add a DIV wrapping, apply default format and move cursor over\r\n        formatNode = fromHtml(\r\n            Browser.isEdge ? '<div><span><br></span></div>' : '<div><br></div>',\r\n            core.contentDiv.ownerDocument\r\n        )[0] as HTMLElement;\r\n        core.api.insertNode(core, formatNode, {\r\n            position: ContentPosition.End,\r\n            updateCursor: false,\r\n            replaceSelection: false,\r\n            insertOnNewLine: false,\r\n        });\r\n\r\n        // element points to a wrapping node we added \"<div><br></div>\". We should move the selection left to <br>\r\n        position = new Position(formatNode.firstChild, PositionType.Begin);\r\n    }\r\n\r\n    if (formatNode) {\r\n        applyFormat(formatNode, core.lifecycle.defaultFormat, core.lifecycle.isDarkMode);\r\n    }\r\n\r\n    // If this is triggered by a keyboard event, let's select the new position\r\n    if (keyboardEvent) {\r\n        core.api.selectRange(core, createRange(position));\r\n    }\r\n};\r\n\r\nfunction wasNodeJustCreatedByKeyboardEvent(event: KeyboardEvent, formatNode: HTMLElement) {\r\n    return (\r\n        safeInstanceOf(event.target, 'Node') &&\r\n        event.target.contains(formatNode) &&\r\n        event.key === formatNode.innerText\r\n    );\r\n}\r\n","import { createRange, getFirstLeafNode } from 'roosterjs-editor-dom';\r\nimport { EditorCore, Focus, PositionType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Focus to editor. If there is a cached selection range, use it as current selection\r\n * @param core The EditorCore object\r\n */\r\nexport const focus: Focus = (core: EditorCore) => {\r\n    if (!core.api.hasFocus(core) || !core.api.getSelectionRange(core, false /*tryGetFromCache*/)) {\r\n        // Focus (document.activeElement indicates) and selection are mostly in sync, but could be out of sync in some extreme cases.\r\n        // i.e. if you programmatically change window selection to point to a non-focusable DOM element (i.e. tabindex=-1 etc.).\r\n        // On Chrome/Firefox, it does not change document.activeElement. On Edge/IE, it change document.activeElement to be body\r\n        // Although on Chrome/Firefox, document.activeElement points to editor, you cannot really type which we don't want (no cursor).\r\n        // So here we always do a live selection pull on DOM and make it point in Editor. The pitfall is, the cursor could be reset\r\n        // to very begin to of editor since we don't really have last saved selection (created on blur which does not fire in this case).\r\n        // It should be better than the case you cannot type\r\n        if (\r\n            !core.domEvent.selectionRange ||\r\n            !core.api.selectRange(core, core.domEvent.selectionRange, true /*skipSameRange*/)\r\n        ) {\r\n            let node = getFirstLeafNode(core.contentDiv) || core.contentDiv;\r\n            core.api.selectRange(\r\n                core,\r\n                createRange(node, PositionType.Begin),\r\n                true /*skipSameRange*/\r\n            );\r\n        }\r\n    }\r\n\r\n    // remember to clear cached selection range\r\n    core.domEvent.selectionRange = null;\r\n\r\n    // This is more a fallback to ensure editor gets focus if it didn't manage to move focus to editor\r\n    if (!core.api.hasFocus(core)) {\r\n        core.contentDiv.focus();\r\n    }\r\n};\r\n","import {\r\n    ColorTransformDirection,\r\n    EditorCore,\r\n    GetContent,\r\n    GetContentMode,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    createRange,\r\n    getHtmlWithSelectionPath,\r\n    getSelectionPath,\r\n    getTextContent,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Get current editor content as HTML string\r\n * @param core The EditorCore object\r\n * @param mode specify what kind of HTML content to retrieve\r\n * @returns HTML string representing current editor content\r\n */\r\nexport const getContent: GetContent = (core: EditorCore, mode: GetContentMode): string => {\r\n    let content = '';\r\n    const triggerExtractContentEvent = mode == GetContentMode.CleanHTML;\r\n    const includeSelectionMarker = mode == GetContentMode.RawHTMLWithSelection;\r\n\r\n    if (mode == GetContentMode.PlainText) {\r\n        content = getTextContent(core.contentDiv);\r\n    } else if (triggerExtractContentEvent || core.lifecycle.isDarkMode) {\r\n        const clonedRoot = core.contentDiv.cloneNode(true /*deep*/) as HTMLElement;\r\n        const originalRange = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n        const path =\r\n            includeSelectionMarker &&\r\n            originalRange &&\r\n            getSelectionPath(core.contentDiv, originalRange);\r\n        const range = path && createRange(clonedRoot, path.start, path.end);\r\n\r\n        core.api.transformColor(\r\n            core,\r\n            clonedRoot,\r\n            false /*includeSelf*/,\r\n            null /*callback*/,\r\n            ColorTransformDirection.DarkToLight\r\n        );\r\n\r\n        if (triggerExtractContentEvent) {\r\n            core.api.triggerEvent(\r\n                core,\r\n                {\r\n                    eventType: PluginEventType.ExtractContentWithDom,\r\n                    clonedRoot,\r\n                },\r\n                true /*broadcast*/\r\n            );\r\n\r\n            content = clonedRoot.innerHTML;\r\n        } else if (range) {\r\n            // range is not null, which means we want to include a selection path in the content\r\n            content = getHtmlWithSelectionPath(clonedRoot, range);\r\n        } else {\r\n            content = clonedRoot.innerHTML;\r\n        }\r\n    } else {\r\n        content = getHtmlWithSelectionPath(\r\n            core.contentDiv,\r\n            includeSelectionMarker && core.api.getSelectionRange(core, true /*tryGetFromCache*/)\r\n        );\r\n    }\r\n\r\n    return content;\r\n};\r\n","import { contains } from 'roosterjs-editor-dom';\r\nimport { EditorCore, GetSelectionRange } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Get current or cached selection range\r\n * @param core The EditorCore object\r\n * @param tryGetFromCache Set to true to retrieve the selection range from cache if editor doesn't own the focus now\r\n * @returns A Range object of the selection range\r\n */\r\nexport const getSelectionRange: GetSelectionRange = (\r\n    core: EditorCore,\r\n    tryGetFromCache: boolean\r\n) => {\r\n    let result: Range = null;\r\n\r\n    if (!tryGetFromCache || core.api.hasFocus(core)) {\r\n        let selection = core.contentDiv.ownerDocument.defaultView.getSelection();\r\n        if (selection && selection.rangeCount > 0) {\r\n            let range = selection.getRangeAt(0);\r\n            if (contains(core.contentDiv, range)) {\r\n                result = range;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!result && tryGetFromCache) {\r\n        result = core.domEvent.selectionRange;\r\n    }\r\n\r\n    return result;\r\n};\r\n","import { DarkModeDatasetNames, EditorCore, GetStyleBasedFormatState } from 'roosterjs-editor-types';\r\nimport { findClosestElementAncestor, getComputedStyles } from 'roosterjs-editor-dom';\r\n\r\nconst ORIGINAL_STYLE_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleColor}],[data-${DarkModeDatasetNames.OriginalAttributeColor}]`;\r\nconst ORIGINAL_STYLE_BACK_COLOR_SELECTOR = `[data-${DarkModeDatasetNames.OriginalStyleBackgroundColor}],[data-${DarkModeDatasetNames.OriginalAttributeBackgroundColor}]`;\r\n\r\n/**\r\n * @internal\r\n * Get style based format state from current selection, including font name/size and colors\r\n * @param core The EditorCore objects\r\n * @param node The node to get style from\r\n */\r\nexport const getStyleBasedFormatState: GetStyleBasedFormatState = (\r\n    core: EditorCore,\r\n    node: Node\r\n) => {\r\n    if (!node) {\r\n        return {};\r\n    }\r\n    const styles = node ? getComputedStyles(node) : [];\r\n    const isDarkMode = core.lifecycle.isDarkMode;\r\n    const root = core.contentDiv;\r\n    const ogTextColorNode =\r\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_COLOR_SELECTOR);\r\n    const ogBackgroundColorNode =\r\n        isDarkMode && findClosestElementAncestor(node, root, ORIGINAL_STYLE_BACK_COLOR_SELECTOR);\r\n\r\n    return {\r\n        fontName: styles[0],\r\n        fontSize: styles[1],\r\n        textColor: styles[2],\r\n        backgroundColor: styles[3],\r\n        textColors: ogTextColorNode\r\n            ? {\r\n                  darkModeColor: styles[2],\r\n                  lightModeColor:\r\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalStyleColor] ||\r\n                      ogTextColorNode.dataset[DarkModeDatasetNames.OriginalAttributeColor],\r\n              }\r\n            : undefined,\r\n        backgroundColors: ogBackgroundColorNode\r\n            ? {\r\n                  darkModeColor: styles[3],\r\n                  lightModeColor:\r\n                      ogBackgroundColorNode.dataset[\r\n                          DarkModeDatasetNames.OriginalStyleBackgroundColor\r\n                      ] ||\r\n                      ogBackgroundColorNode.dataset[\r\n                          DarkModeDatasetNames.OriginalAttributeBackgroundColor\r\n                      ],\r\n              }\r\n            : undefined,\r\n    };\r\n};\r\n","import {\r\n    BlockElement,\r\n    ContentPosition,\r\n    ColorTransformDirection,\r\n    EditorCore,\r\n    InsertNode,\r\n    InsertOption,\r\n    NodeType,\r\n    NodePosition,\r\n    PositionType,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    changeElementTag,\r\n    contains,\r\n    createRange,\r\n    findClosestElementAncestor,\r\n    getBlockElementAtNode,\r\n    getFirstLastBlockElement,\r\n    getTagOfNode,\r\n    isBlockElement,\r\n    isNodeEmpty,\r\n    isPositionAtBeginningOf,\r\n    isVoidHtmlElement,\r\n    Position,\r\n    queryElements,\r\n    safeInstanceOf,\r\n    splitBalancedNodeRange,\r\n    splitTextNode,\r\n    toArray,\r\n    unwrap,\r\n    VTable,\r\n    wrap,\r\n} from 'roosterjs-editor-dom';\r\n\r\nconst adjustSteps: ((\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n) => NodePosition)[] = [handleHyperLink, handleStructuredNode, handleParagraph, handleVoidElement];\r\n\r\nfunction getInitialRange(\r\n    core: EditorCore,\r\n    option: InsertOption\r\n): { range: Range; rangeToRestore: Range } {\r\n    // Selection start replaces based on the current selection.\r\n    // Range inserts based on a provided range.\r\n    // Both have the potential to use the current selection to restore cursor position\r\n    // So in both cases we need to store the selection state.\r\n    let range = core.api.getSelectionRange(core, true /*tryGetFromCache*/);\r\n    let rangeToRestore = null;\r\n    if (option.position == ContentPosition.Range) {\r\n        rangeToRestore = range;\r\n        range = option.range;\r\n    } else if (range) {\r\n        rangeToRestore = range.cloneRange();\r\n    }\r\n\r\n    return { range, rangeToRestore };\r\n}\r\n\r\n/**\r\n * @internal\r\n * Insert a DOM node into editor content\r\n * @param core The EditorCore object. No op if null.\r\n * @param option An insert option object to specify how to insert the node\r\n */\r\nexport const insertNode: InsertNode = (core: EditorCore, node: Node, option: InsertOption) => {\r\n    option = option || {\r\n        position: ContentPosition.SelectionStart,\r\n        insertOnNewLine: false,\r\n        updateCursor: true,\r\n        replaceSelection: true,\r\n    };\r\n    let contentDiv = core.contentDiv;\r\n\r\n    if (option.updateCursor) {\r\n        core.api.focus(core);\r\n    }\r\n\r\n    if (option.position == ContentPosition.Outside) {\r\n        contentDiv.parentNode.insertBefore(node, contentDiv.nextSibling);\r\n        return true;\r\n    }\r\n\r\n    core.api.transformColor(\r\n        core,\r\n        node,\r\n        true /*includeSelf*/,\r\n        () => {\r\n            switch (option.position) {\r\n                case ContentPosition.Begin:\r\n                case ContentPosition.End: {\r\n                    let isBegin = option.position == ContentPosition.Begin;\r\n                    let block = getFirstLastBlockElement(contentDiv, isBegin);\r\n                    let insertedNode: Node | Node[];\r\n                    if (block) {\r\n                        let refNode = isBegin ? block.getStartNode() : block.getEndNode();\r\n                        if (\r\n                            option.insertOnNewLine ||\r\n                            refNode.nodeType == NodeType.Text ||\r\n                            isVoidHtmlElement(refNode)\r\n                        ) {\r\n                            // For insert on new line, or refNode is text or void html element (HR, BR etc.)\r\n                            // which cannot have children, i.e. <div>hello<br>world</div>. 'hello', 'world' are the\r\n                            // first and last node. Insert before 'hello' or after 'world', but still inside DIV\r\n                            if (safeInstanceOf(node, 'DocumentFragment')) {\r\n                                // if the node to be inserted is DocumentFragment, use its childNodes as insertedNode\r\n                                // because insertBefore() returns an empty DocumentFragment\r\n                                insertedNode = toArray(node.childNodes);\r\n                                refNode.parentNode.insertBefore(\r\n                                    node,\r\n                                    isBegin ? refNode : refNode.nextSibling\r\n                                );\r\n                            } else {\r\n                                insertedNode = refNode.parentNode.insertBefore(\r\n                                    node,\r\n                                    isBegin ? refNode : refNode.nextSibling\r\n                                );\r\n                            }\r\n                        } else {\r\n                            // if the refNode can have child, use appendChild (which is like to insert as first/last child)\r\n                            // i.e. <div>hello</div>, the content will be inserted before/after hello\r\n                            insertedNode = refNode.insertBefore(\r\n                                node,\r\n                                isBegin ? refNode.firstChild : null\r\n                            );\r\n                        }\r\n                    } else {\r\n                        // No first block, this can happen when editor is empty. Use appendChild to insert the content in contentDiv\r\n                        insertedNode = contentDiv.appendChild(node);\r\n                    }\r\n\r\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n                    // add a DIV wrapping\r\n                    if (insertedNode && option.insertOnNewLine) {\r\n                        const nodes = Array.isArray(insertedNode) ? insertedNode : [insertedNode];\r\n                        if (!isBlockElement(nodes[0]) || !isBlockElement(nodes[nodes.length - 1])) {\r\n                            wrap(nodes);\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case ContentPosition.DomEnd:\r\n                    // Use appendChild to insert the node at the end of the content div.\r\n                    let insertedNode = contentDiv.appendChild(node);\r\n                    // Final check to see if the inserted node is a block. If not block and the ask is to insert on new line,\r\n                    // add a DIV wrapping\r\n                    if (insertedNode && option.insertOnNewLine && !isBlockElement(insertedNode)) {\r\n                        wrap(insertedNode);\r\n                    }\r\n                    break;\r\n                case ContentPosition.Range:\r\n                case ContentPosition.SelectionStart:\r\n                    let { range, rangeToRestore } = getInitialRange(core, option);\r\n\r\n                    if (!range) {\r\n                        return;\r\n                    }\r\n\r\n                    // if to replace the selection and the selection is not collapsed, remove the the content at selection first\r\n                    if (option.replaceSelection && !range.collapsed) {\r\n                        range.deleteContents();\r\n                    }\r\n\r\n                    let pos = Position.getStart(range);\r\n                    let blockElement: BlockElement;\r\n\r\n                    if (\r\n                        option.insertOnNewLine &&\r\n                        (blockElement = getBlockElementAtNode(contentDiv, pos.normalize().node))\r\n                    ) {\r\n                        pos = new Position(blockElement.getEndNode(), PositionType.After);\r\n                    } else {\r\n                        adjustSteps.forEach(handler => {\r\n                            pos = handler(contentDiv, node, pos);\r\n                        });\r\n                    }\r\n\r\n                    let nodeForCursor =\r\n                        node.nodeType == NodeType.DocumentFragment ? node.lastChild : node;\r\n                    range = createRange(pos);\r\n                    range.insertNode(node);\r\n                    if (option.updateCursor && nodeForCursor) {\r\n                        rangeToRestore = createRange(\r\n                            new Position(nodeForCursor, PositionType.After).normalize()\r\n                        );\r\n                    }\r\n                    core.api.selectRange(core, rangeToRestore);\r\n\r\n                    break;\r\n            }\r\n        },\r\n        ColorTransformDirection.LightToDark\r\n    );\r\n\r\n    return true;\r\n};\r\n\r\nfunction handleHyperLink(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let blockElement = getBlockElementAtNode(root, position.node);\r\n\r\n    if (blockElement) {\r\n        // Find the first <A> tag within current block which covers current selection\r\n        // If there are more than one nested, let's handle the first one only since that is not a common scenario.\r\n        let anchor = queryElements(\r\n            root,\r\n            'a[href]',\r\n            null /*forEachCallback*/,\r\n            QueryScope.OnSelection,\r\n            createRange(position)\r\n        ).filter(a => blockElement.contains(a))[0];\r\n\r\n        // If this is about to insert node to an empty A tag, clear the A tag and reset position\r\n        if (anchor && isNodeEmpty(anchor)) {\r\n            position = new Position(anchor, PositionType.Before);\r\n            safeRemove(anchor);\r\n            anchor = null;\r\n        }\r\n\r\n        // If this is about to insert nodes which contains A tag into another A tag, need to break current A tag\r\n        // otherwise we will have nested A tags which is a wrong HTML structure\r\n        if (\r\n            anchor &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector &&\r\n            (<ParentNode>(<any>nodeToInsert)).querySelector('a[href]')\r\n        ) {\r\n            let normalizedPosition = position.normalize();\r\n            let parentNode = normalizedPosition.node.parentNode;\r\n            let nextNode =\r\n                normalizedPosition.node.nodeType == NodeType.Text\r\n                    ? splitTextNode(\r\n                          <Text>normalizedPosition.node,\r\n                          normalizedPosition.offset,\r\n                          false /*returnFirstPart*/\r\n                      )\r\n                    : normalizedPosition.isAtEnd\r\n                    ? normalizedPosition.node.nextSibling\r\n                    : normalizedPosition.node;\r\n            let splitter: Node = root.ownerDocument.createTextNode('');\r\n            parentNode.insertBefore(splitter, nextNode);\r\n\r\n            while (contains(anchor, splitter)) {\r\n                splitter = splitBalancedNodeRange(splitter);\r\n            }\r\n\r\n            position = new Position(splitter, PositionType.Before);\r\n            safeRemove(splitter);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleStructuredNode(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    let rootNodeToInsert = nodeToInsert;\r\n\r\n    if (rootNodeToInsert.nodeType == NodeType.DocumentFragment) {\r\n        let rootNodes = toArray(rootNodeToInsert.childNodes).filter(n => getTagOfNode(n) != 'BR');\r\n        rootNodeToInsert = rootNodes.length == 1 ? rootNodes[0] : null;\r\n    }\r\n\r\n    let tag = getTagOfNode(rootNodeToInsert);\r\n    let hasBrNextToRoot = tag && getTagOfNode(rootNodeToInsert.nextSibling) == 'BR';\r\n    let listItem = findClosestElementAncestor(position.node, root, 'LI');\r\n    let listNode = listItem && findClosestElementAncestor(listItem, root, 'OL,UL');\r\n    let tdNode = findClosestElementAncestor(position.node, root, 'TD,TH');\r\n    let trNode = tdNode && findClosestElementAncestor(tdNode, root, 'TR');\r\n\r\n    if (tag == 'LI') {\r\n        tag = listNode ? getTagOfNode(listNode) : 'UL';\r\n        rootNodeToInsert = wrap(rootNodeToInsert, tag);\r\n    }\r\n\r\n    if ((tag == 'OL' || tag == 'UL') && getTagOfNode(rootNodeToInsert.firstChild) == 'LI') {\r\n        let shouldInsertListAsText = !rootNodeToInsert.firstChild.nextSibling && !hasBrNextToRoot;\r\n\r\n        if (hasBrNextToRoot && rootNodeToInsert.parentNode) {\r\n            safeRemove(rootNodeToInsert.nextSibling);\r\n        }\r\n\r\n        if (shouldInsertListAsText) {\r\n            unwrap(rootNodeToInsert.firstChild);\r\n            unwrap(rootNodeToInsert);\r\n        } else if (getTagOfNode(listNode) == tag) {\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(\r\n                listItem,\r\n                isPositionAtBeginningOf(position, listItem)\r\n                    ? PositionType.Before\r\n                    : PositionType.After\r\n            );\r\n        }\r\n    } else if (tag == 'TABLE' && trNode) {\r\n        // When inserting a table into a table, if these tables have the same column count, and\r\n        // current position is at beginning of a row, then merge these two tables\r\n        let newTable = new VTable(<HTMLTableElement>rootNodeToInsert);\r\n        let currentTable = new VTable(<HTMLTableCellElement>tdNode);\r\n        if (\r\n            currentTable.col == 0 &&\r\n            tdNode == currentTable.getCell(currentTable.row, 0).td &&\r\n            newTable.cells[0] &&\r\n            newTable.cells[0].length == currentTable.cells[0].length &&\r\n            isPositionAtBeginningOf(position, tdNode)\r\n        ) {\r\n            if (\r\n                getTagOfNode(rootNodeToInsert.firstChild) == 'TBODY' &&\r\n                !rootNodeToInsert.firstChild.nextSibling\r\n            ) {\r\n                unwrap(rootNodeToInsert.firstChild);\r\n            }\r\n            unwrap(rootNodeToInsert);\r\n            position = new Position(trNode, PositionType.After);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleParagraph(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (getTagOfNode(position.node) == 'P') {\r\n        // Insert into a P tag may cause issues when the inserted content contains any block element.\r\n        // Change P tag to DIV to make sure it works well\r\n        let pos = position.normalize();\r\n        let div = changeElementTag(<HTMLElement>position.node, 'div');\r\n        if (pos.node != div) {\r\n            position = pos;\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction handleVoidElement(\r\n    root: HTMLElement,\r\n    nodeToInsert: Node,\r\n    position: NodePosition\r\n): NodePosition {\r\n    if (isVoidHtmlElement(position.node)) {\r\n        position = new Position(\r\n            position.node,\r\n            position.isAtEnd ? PositionType.After : PositionType.Before\r\n        );\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\nfunction safeRemove(node: Node) {\r\n    node?.parentNode?.removeChild(node);\r\n}\r\n","import { EditorCore, RestoreUndoSnapshot } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Restore an undo snapshot into editor\r\n * @param core The editor core object\r\n * @param step Steps to move, can be 0, positive or negative\r\n */\r\nexport const restoreUndoSnapshot: RestoreUndoSnapshot = (core: EditorCore, step: number) => {\r\n    if (core.undo.hasNewContent && step < 0) {\r\n        core.api.addUndoSnapshot(\r\n            core,\r\n            null /*callback*/,\r\n            null /*changeSource*/,\r\n            false /*canUndoByBackspace*/\r\n        );\r\n    }\r\n\r\n    const snapshot = core.undo.snapshotsService.move(step);\r\n\r\n    if (snapshot != null) {\r\n        try {\r\n            core.undo.isRestoring = true;\r\n            core.api.setContent(core, snapshot, true /*triggerContentChangedEvent*/);\r\n        } finally {\r\n            core.undo.isRestoring = false;\r\n        }\r\n    }\r\n};\r\n","import { EditorCore, SelectRange } from 'roosterjs-editor-types';\r\nimport { hasFocus } from './hasFocus';\r\nimport {\r\n    contains,\r\n    getPendableFormatState,\r\n    Position,\r\n    PendableFormatNames,\r\n    PendableFormatCommandMap,\r\n    addRangeToSelection,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Change the editor selection to the given range\r\n * @param core The EditorCore object\r\n * @param range The range to select\r\n * @param skipSameRange When set to true, do nothing if the given range is the same with current selection\r\n * in editor, otherwise it will always remove current selection ranage and set to the given one.\r\n * This parameter is always treat as true in Edge to avoid some weird runtime exception.\r\n */\r\nexport const selectRange: SelectRange = (\r\n    core: EditorCore,\r\n    range: Range,\r\n    skipSameRange?: boolean\r\n) => {\r\n    if (contains(core.contentDiv, range)) {\r\n        addRangeToSelection(range, skipSameRange);\r\n\r\n        if (!hasFocus(core)) {\r\n            core.domEvent.selectionRange = range;\r\n        }\r\n\r\n        if (range.collapsed) {\r\n            // If selected, and current selection is collapsed,\r\n            // need to restore pending format state if exists.\r\n            restorePendingFormatState(core);\r\n        }\r\n\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Restore cached pending format state (if exist) to current selection\r\n */\r\nfunction restorePendingFormatState(core: EditorCore) {\r\n    const {\r\n        contentDiv,\r\n        pendingFormatState,\r\n        api: { getSelectionRange },\r\n    } = core;\r\n\r\n    if (pendingFormatState.pendableFormatState) {\r\n        const document = contentDiv.ownerDocument;\r\n        let formatState = getPendableFormatState(document);\r\n        (<PendableFormatNames[]>Object.keys(PendableFormatCommandMap)).forEach(key => {\r\n            if (!!pendingFormatState.pendableFormatState[key] != formatState[key]) {\r\n                document.execCommand(PendableFormatCommandMap[key], false, null);\r\n            }\r\n        });\r\n\r\n        const range = getSelectionRange(core, true /*tryGetFromCache*/);\r\n        pendingFormatState.pendableFormatPosition = range && Position.getStart(range);\r\n    }\r\n}\r\n","import { setHtmlWithSelectionPath } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ColorTransformDirection,\r\n    EditorCore,\r\n    PluginEventType,\r\n    SetContent,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered\r\n * if triggerContentChangedEvent is set to true\r\n * @param core The EditorCore object\r\n * @param content HTML content to set in\r\n * @param triggerContentChangedEvent True to trigger a ContentChanged event. Default value is true\r\n */\r\nexport const setContent: SetContent = (\r\n    core: EditorCore,\r\n    content: string,\r\n    triggerContentChangedEvent: boolean\r\n) => {\r\n    let contentChanged = false;\r\n    if (core.contentDiv.innerHTML != content) {\r\n        const range = setHtmlWithSelectionPath(core.contentDiv, content);\r\n        core.api.selectRange(core, range);\r\n        contentChanged = true;\r\n    }\r\n\r\n    // Convert content even if it hasn't changed.\r\n    core.api.transformColor(\r\n        core,\r\n        core.contentDiv,\r\n        false /*includeSelf*/,\r\n        null /*callback*/,\r\n        ColorTransformDirection.LightToDark\r\n    );\r\n\r\n    if (triggerContentChangedEvent && (contentChanged || core.lifecycle.isDarkMode)) {\r\n        core.api.triggerEvent(\r\n            core,\r\n            {\r\n                eventType: PluginEventType.ContentChanged,\r\n                source: ChangeSource.SetContent,\r\n            },\r\n            false /*broadcast*/\r\n        );\r\n    }\r\n};\r\n","import { arrayPush, safeInstanceOf, toArray } from 'roosterjs-editor-dom';\r\nimport {\r\n    ColorTransformDirection,\r\n    DarkModeDatasetNames,\r\n    EditorCore,\r\n    TransformColor,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst STYLE_DATASET_MAP = {\r\n    /**\r\n     * Original style color\r\n     */\r\n    [DarkModeDatasetNames.OriginalStyleColor]: (element: HTMLElement, value: string) =>\r\n        (element.style.color = value),\r\n\r\n    /**\r\n     * Original style background color\r\n     */\r\n    [DarkModeDatasetNames.OriginalStyleBackgroundColor]: (element: HTMLElement, value: string) =>\r\n        (element.style.backgroundColor = value),\r\n};\r\nconst ATTR_DATASET_MAP = {\r\n    /**\r\n     * Original attribute color\r\n     */\r\n    [DarkModeDatasetNames.OriginalAttributeColor]: 'color',\r\n\r\n    /**\r\n     * Original attribute background color\r\n     */\r\n    [DarkModeDatasetNames.OriginalAttributeBackgroundColor]: 'bgcolor',\r\n};\r\n\r\n/**\r\n * @internal\r\n * Edit and transform color of elements between light mode and dark mode\r\n * @param core The EditorCore object\r\n * @param rootNode The root HTML elements to transform\r\n * @param includeSelf True to transform the root node as well, otherwise false\r\n * @param callback The callback function to invoke before do color transformation\r\n * @param direction To specify the transform direction, light to dark, or dark to light\r\n */\r\nexport const transformColor: TransformColor = (\r\n    core: EditorCore,\r\n    rootNode: Node,\r\n    includeSelf: boolean,\r\n    callback: () => void,\r\n    direction: ColorTransformDirection\r\n) => {\r\n    let elementsToTransform = core.lifecycle.isDarkMode ? getAll(rootNode, includeSelf) : [];\r\n\r\n    callback?.();\r\n\r\n    elementsToTransform.forEach(element => {\r\n        if (direction == ColorTransformDirection.DarkToLight && element?.dataset) {\r\n            // Reset color styles based on the content of the ogsc/ogsb data element.\r\n            // If those data properties are empty or do not exist, set them anyway to clear the content.\r\n            Object.keys(STYLE_DATASET_MAP).forEach((name: keyof typeof STYLE_DATASET_MAP) => {\r\n                STYLE_DATASET_MAP[name](element, getValueOrDefault(element.dataset[name], ''));\r\n                delete element.dataset[name];\r\n            });\r\n\r\n            // Some elements might have set attribute colors. We need to reset these as well.\r\n            Object.keys(ATTR_DATASET_MAP).forEach((name: keyof typeof ATTR_DATASET_MAP) => {\r\n                const value = element.dataset[name];\r\n                if (getValueOrDefault(value, null)) {\r\n                    element.setAttribute(ATTR_DATASET_MAP[name], value);\r\n                } else {\r\n                    element.removeAttribute(ATTR_DATASET_MAP[name]);\r\n                }\r\n                delete element.dataset[name];\r\n            });\r\n        } else if (element) {\r\n            if (core.lifecycle.onExternalContentTransform) {\r\n                core.lifecycle.onExternalContentTransform(element);\r\n            } else {\r\n                element.style.color = null;\r\n                element.style.backgroundColor = null;\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nfunction getValueOrDefault(value: string, defualtValue: string | null) {\r\n    return value && value != 'undefined' && value != 'null' ? value : defualtValue;\r\n}\r\n\r\nfunction getAll(rootNode: Node, includeSelf: boolean): HTMLElement[] {\r\n    const result: HTMLElement[] = [];\r\n\r\n    if (safeInstanceOf(rootNode, 'HTMLElement')) {\r\n        if (includeSelf) {\r\n            result.push(rootNode);\r\n        }\r\n        const allChildren = rootNode.getElementsByTagName('*');\r\n        arrayPush(result, toArray(allChildren));\r\n    } else if (safeInstanceOf(rootNode, 'DocumentFragment')) {\r\n        const allChildren = rootNode.querySelectorAll('*');\r\n        arrayPush(result, toArray(allChildren));\r\n    }\r\n\r\n    return result;\r\n}\r\n","import { EditorCore, EditorPlugin, PluginEvent, TriggerEvent } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Trigger a plugin event\r\n * @param core The EditorCore object\r\n * @param pluginEvent The event object to trigger\r\n * @param broadcast Set to true to skip the shouldHandleEventExclusively check\r\n */\r\nexport const triggerEvent: TriggerEvent = (\r\n    core: EditorCore,\r\n    pluginEvent: PluginEvent,\r\n    broadcast: boolean\r\n) => {\r\n    if (broadcast || !core.plugins.some(plugin => handledExclusively(pluginEvent, plugin))) {\r\n        core.plugins.forEach(plugin => {\r\n            if (plugin.onPluginEvent) {\r\n                plugin.onPluginEvent(pluginEvent);\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\nfunction handledExclusively(event: PluginEvent, plugin: EditorPlugin): boolean {\r\n    if (plugin.onPluginEvent && plugin.willHandleEventExclusively?.(event)) {\r\n        plugin.onPluginEvent(event);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n","import CopyPastePlugin from './CopyPastePlugin';\r\nimport DOMEventPlugin from './DOMEventPlugin';\r\nimport EditPlugin from './EditPlugin';\r\nimport EntityPlugin from './EntityPlugin';\r\nimport LifecyclePlugin from './LifecyclePlugin';\r\nimport MouseUpPlugin from './MouseUpPlugin';\r\nimport PendingFormatStatePlugin from './PendingFormatStatePlugin';\r\nimport TypeAfterLinkPlugin from './TypeAfterLinkPlugin';\r\nimport TypeInContainerPlugin from './TypeInContainerPlugin';\r\nimport UndoPlugin from './UndoPlugin';\r\nimport { CorePlugins, EditorOptions, PluginState } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const PLACEHOLDER_PLUGIN_NAME = '_placeholder';\r\n\r\n/**\r\n * @internal\r\n * Create Core Plugins\r\n * @param contentDiv Content DIV of editor\r\n * @param options Editor options\r\n */\r\nexport default function createCorePlugins(\r\n    contentDiv: HTMLDivElement,\r\n    options: EditorOptions\r\n): CorePlugins & { [PLACEHOLDER_PLUGIN_NAME]: null } {\r\n    const map = options.corePluginOverride || {};\r\n    // The order matters, some plugin needs to be put before/after others to make sure event\r\n    // can be handled in right order\r\n    return {\r\n        typeInContainer: map.typeInContainer || new TypeInContainerPlugin(),\r\n        edit: map.edit || new EditPlugin(),\r\n        _placeholder: null,\r\n        typeAfterLink: map.typeAfterLink || new TypeAfterLinkPlugin(),\r\n        undo: map.undo || new UndoPlugin(options),\r\n        domEvent: map.domEvent || new DOMEventPlugin(options, contentDiv),\r\n        pendingFormatState: map.pendingFormatState || new PendingFormatStatePlugin(),\r\n        mouseUp: map.mouseUp || new MouseUpPlugin(),\r\n        copyPaste: map.copyPaste || new CopyPastePlugin(),\r\n        entity: map.entity || new EntityPlugin(),\r\n        lifecycle: map.lifecycle || new LifecyclePlugin(options, contentDiv),\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * Get plugin state of core plugins\r\n * @param corePlugins CorePlugins object\r\n */\r\nexport function getPluginState(corePlugins: CorePlugins): PluginState {\r\n    return {\r\n        domEvent: corePlugins.domEvent.getState(),\r\n        pendingFormatState: corePlugins.pendingFormatState.getState(),\r\n        edit: corePlugins.edit.getState(),\r\n        lifecycle: corePlugins.lifecycle.getState(),\r\n        undo: corePlugins.undo.getState(),\r\n        entity: corePlugins.entity.getState(),\r\n    };\r\n}\r\n","import {\r\n    addRangeToSelection,\r\n    extractClipboardEvent,\r\n    fromHtml,\r\n    readFile,\r\n    setHtmlWithSelectionPath,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ClipboardData,\r\n    ContentPosition,\r\n    EditorPlugin,\r\n    GetContentMode,\r\n    IEditor,\r\n    PluginEventType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst CONTAINER_HTML =\r\n    '<div contenteditable style=\"width: 1px; height: 1px; overflow: hidden; position: fixed; top: 0; left; 0; -webkit-user-select: text\"></div>';\r\n\r\n/**\r\n * @internal\r\n * Copy and paste plugin for handling onCopy and onPaste event\r\n */\r\nexport default class CopyPastePlugin implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'CopyPaste';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.disposer = this.editor.addDomEventHandler({\r\n            paste: this.onPaste,\r\n            copy: e => this.onCutCopy(e, false /*isCut*/),\r\n            cut: e => this.onCutCopy(e, true /*isCut*/),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    private onCutCopy(event: Event, isCut: boolean) {\r\n        const originalRange = this.editor.getSelectionRange();\r\n        if (originalRange && !originalRange.collapsed) {\r\n            const html = this.editor.getContent(GetContentMode.RawHTMLWithSelection);\r\n            const tempDiv = this.getTempDiv(true /*forceInLightMode*/);\r\n            const newRange = setHtmlWithSelectionPath(tempDiv, html);\r\n\r\n            if (newRange) {\r\n                addRangeToSelection(newRange);\r\n            }\r\n\r\n            this.editor.triggerPluginEvent(PluginEventType.BeforeCutCopy, {\r\n                clonedRoot: tempDiv,\r\n                range: newRange,\r\n                rawEvent: event as ClipboardEvent,\r\n                isCut,\r\n            });\r\n\r\n            this.editor.runAsync(editor => {\r\n                this.cleanUpAndRestoreSelection(tempDiv, originalRange);\r\n\r\n                if (isCut) {\r\n                    editor.addUndoSnapshot(() => {\r\n                        const position = this.editor.deleteSelectedContent();\r\n                        editor.focus();\r\n                        editor.select(position);\r\n                    }, ChangeSource.Cut);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private onPaste = (event: Event) => {\r\n        extractClipboardEvent(\r\n            event as ClipboardEvent,\r\n            items => {\r\n                if (items.rawHtml === undefined) {\r\n                    // Can't get pasted HTML directly, need to use a temp DIV to retrieve pasted content.\r\n                    // This is mostly for IE\r\n                    const originalSelectionRange = this.editor.getSelectionRange();\r\n                    const tempDiv = this.getTempDiv();\r\n\r\n                    this.editor.runAsync(() => {\r\n                        items.rawHtml = tempDiv.innerHTML;\r\n                        this.cleanUpAndRestoreSelection(tempDiv, originalSelectionRange);\r\n                        this.paste(items);\r\n                    });\r\n                } else {\r\n                    this.paste(items);\r\n                }\r\n            },\r\n            {\r\n                allowLinkPreview: this.editor.isFeatureEnabled(\r\n                    ExperimentalFeatures.PasteWithLinkPreview\r\n                ),\r\n            }\r\n        );\r\n    };\r\n\r\n    private paste(clipboardData: ClipboardData) {\r\n        if (clipboardData.image) {\r\n            readFile(clipboardData.image, dataUrl => {\r\n                clipboardData.imageDataUri = dataUrl;\r\n                this.editor.paste(clipboardData);\r\n            });\r\n        } else {\r\n            this.editor.paste(clipboardData);\r\n        }\r\n    }\r\n\r\n    private getTempDiv(forceInLightMode?: boolean) {\r\n        const div = this.editor.getCustomData(\r\n            'CopyPasteTempDiv',\r\n            () => {\r\n                const tempDiv = fromHtml(\r\n                    CONTAINER_HTML,\r\n                    this.editor.getDocument()\r\n                )[0] as HTMLDivElement;\r\n                this.editor.insertNode(tempDiv, {\r\n                    position: ContentPosition.Outside,\r\n                });\r\n\r\n                return tempDiv;\r\n            },\r\n            tempDiv => tempDiv.parentNode?.removeChild(tempDiv)\r\n        );\r\n\r\n        if (forceInLightMode) {\r\n            div.style.backgroundColor = 'white';\r\n            div.style.color = 'black';\r\n        }\r\n\r\n        div.style.display = '';\r\n        div.focus();\r\n\r\n        return div;\r\n    }\r\n\r\n    private cleanUpAndRestoreSelection(tempDiv: HTMLDivElement, range: Range) {\r\n        this.editor.select(range);\r\n        tempDiv.style.backgroundColor = '';\r\n        tempDiv.style.color = '';\r\n        tempDiv.style.display = 'none';\r\n        tempDiv.innerHTML = '';\r\n    }\r\n}\r\n","import { arrayPush, Browser, isCharacterValue } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContextMenuProvider,\r\n    DOMEventHandler,\r\n    DOMEventPluginState,\r\n    EditorOptions,\r\n    IEditor,\r\n    PluginEventType,\r\n    PluginWithState,\r\n    EditorPlugin,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * DOMEventPlugin handles customized DOM events, including:\r\n * 1. Keyboard event\r\n * 2. Mouse event\r\n * 3. IME state\r\n * 4. Drop event\r\n * 5. Focus and blur event\r\n * 6. Input event\r\n * 7. Scroll event\r\n */\r\nexport default class DOMEventPlugin implements PluginWithState<DOMEventPluginState> {\r\n    private editor: IEditor;\r\n    private disposer: () => void;\r\n    private state: DOMEventPluginState;\r\n\r\n    /**\r\n     * Construct a new instance of DOMEventPlugin\r\n     * @param options The editor options\r\n     * @param contentDiv The editor content DIV\r\n     */\r\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\r\n        this.state = {\r\n            isInIME: false,\r\n            scrollContainer: options.scrollContainer || contentDiv,\r\n            selectionRange: null,\r\n            stopPrintableKeyboardEventPropagation: !options.allowKeyboardEventPropagation,\r\n            contextMenuProviders:\r\n                options.plugins?.filter<ContextMenuProvider<any>>(isContextMenuProvider) || [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'DOMEvent';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n\r\n        this.disposer = editor.addDomEventHandler({\r\n            // 1. Keyboard event\r\n            keypress: this.getEventHandler(PluginEventType.KeyPress),\r\n            keydown: this.getEventHandler(PluginEventType.KeyDown),\r\n            keyup: this.getEventHandler(PluginEventType.KeyUp),\r\n\r\n            // 2. Mouse event\r\n            mousedown: PluginEventType.MouseDown,\r\n            contextmenu: this.onContextMenuEvent,\r\n\r\n            // 3. IME state management\r\n            compositionstart: () => (this.state.isInIME = true),\r\n            compositionend: (rawEvent: CompositionEvent) => {\r\n                this.state.isInIME = false;\r\n                editor.triggerPluginEvent(PluginEventType.CompositionEnd, {\r\n                    rawEvent,\r\n                });\r\n            },\r\n\r\n            // 4. Drop event\r\n            drop: this.onDrop,\r\n\r\n            // 5. Focus mangement\r\n            focus: this.onFocus,\r\n            [Browser.isIEOrEdge ? 'beforedeactivate' : 'blur']: this.onBlur,\r\n\r\n            // 6. Input event\r\n            [Browser.isIE ? 'textinput' : 'input']: this.getEventHandler(PluginEventType.Input),\r\n        });\r\n\r\n        // 7. Scroll event\r\n        this.state.scrollContainer.addEventListener('scroll', this.onScroll);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.state.scrollContainer.removeEventListener('scroll', this.onScroll);\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    private onDrop = (e: UIEvent) => {\r\n        this.editor.runAsync(editor => {\r\n            editor.addUndoSnapshot(() => {}, ChangeSource.Drop);\r\n        });\r\n    };\r\n\r\n    private onFocus = () => {\r\n        this.editor.select(this.state.selectionRange);\r\n        this.state.selectionRange = null;\r\n    };\r\n\r\n    private onBlur = () => {\r\n        this.state.selectionRange = this.editor.getSelectionRange(false /*tryGetFromCache*/);\r\n    };\r\n\r\n    private onScroll = (e: UIEvent) => {\r\n        this.editor.triggerPluginEvent(PluginEventType.Scroll, {\r\n            rawEvent: e,\r\n            scrollContainer: this.state.scrollContainer,\r\n        });\r\n    };\r\n\r\n    private getEventHandler(eventType: PluginEventType): DOMEventHandler {\r\n        return this.state.stopPrintableKeyboardEventPropagation\r\n            ? {\r\n                  pluginEventType: eventType,\r\n                  beforeDispatch:\r\n                      eventType == PluginEventType.Input ? this.onInputEvent : this.onKeybaordEvent,\r\n              }\r\n            : eventType;\r\n    }\r\n\r\n    private onKeybaordEvent = (event: KeyboardEvent) => {\r\n        if (isCharacterValue(event)) {\r\n            event.stopPropagation();\r\n        }\r\n    };\r\n\r\n    private onInputEvent = (event: InputEvent) => {\r\n        event.stopPropagation();\r\n    };\r\n\r\n    private onContextMenuEvent = (event: MouseEvent) => {\r\n        const allItems: any[] = [];\r\n        const searcher = this.editor.getContentSearcherOfCursor();\r\n        const elementBeforeCursor = searcher?.getInlineElementBefore();\r\n\r\n        let eventTargetNode = event.target as Node;\r\n        if (event.button != 2) {\r\n            eventTargetNode = elementBeforeCursor?.getContainerNode();\r\n        }\r\n        this.state.contextMenuProviders.forEach(provider => {\r\n            const items = provider.getContextMenuItems(eventTargetNode);\r\n            if (items?.length > 0) {\r\n                if (allItems.length > 0) {\r\n                    allItems.push(null);\r\n                }\r\n                arrayPush(allItems, items);\r\n            }\r\n        });\r\n        this.editor.triggerPluginEvent(PluginEventType.ContextMenu, {\r\n            rawEvent: event,\r\n            items: allItems,\r\n        });\r\n    };\r\n}\r\n\r\nfunction isContextMenuProvider(source: EditorPlugin): source is ContextMenuProvider<any> {\r\n    return !!(<ContextMenuProvider<any>>source)?.getContextMenuItems;\r\n}\r\n","import { isCtrlOrMetaPressed } from 'roosterjs-editor-dom';\r\nimport {\r\n    EditPluginState,\r\n    GenericContentEditFeature,\r\n    IEditor,\r\n    Keys,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginWithState,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * Edit Component helps handle Content edit features\r\n */\r\nexport default class EditPlugin implements PluginWithState<EditPluginState> {\r\n    private editor: IEditor;\r\n    private state: EditPluginState;\r\n\r\n    /**\r\n     * Construct a new instance of EditPlugin\r\n     * @param options The editor options\r\n     */\r\n    constructor() {\r\n        this.state = {\r\n            features: {},\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Edit';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        let hasFunctionKey = false;\r\n        let features: GenericContentEditFeature<PluginEvent>[];\r\n        let ctrlOrMeta = false;\r\n\r\n        if (event.eventType == PluginEventType.KeyDown) {\r\n            const rawEvent = event.rawEvent;\r\n            const range = this.editor.getSelectionRange();\r\n\r\n            ctrlOrMeta = isCtrlOrMetaPressed(rawEvent);\r\n            hasFunctionKey = ctrlOrMeta || rawEvent.altKey;\r\n            features =\r\n                this.state.features[rawEvent.which] ||\r\n                (range && !range.collapsed && this.state.features[Keys.RANGE]);\r\n        } else if (event.eventType == PluginEventType.ContentChanged) {\r\n            features = this.state.features[Keys.CONTENTCHANGED];\r\n        }\r\n\r\n        for (let i = 0; i < features?.length; i++) {\r\n            const feature = features[i];\r\n            if (\r\n                (feature.allowFunctionKeys || !hasFunctionKey) &&\r\n                feature.shouldHandleEvent(event, this.editor, ctrlOrMeta)\r\n            ) {\r\n                feature.handleEvent(event, this.editor);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import {\r\n    Browser,\r\n    commitEntity,\r\n    getEntityFromElement,\r\n    getEntitySelector,\r\n    isCharacterValue,\r\n    toArray,\r\n    arrayPush,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    ContentPosition,\r\n    Entity,\r\n    EntityClasses,\r\n    EntityOperation,\r\n    EntityPluginState,\r\n    HtmlSanitizerOptions,\r\n    IEditor,\r\n    Keys,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginWithState,\r\n    QueryScope,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst ENTITY_ID_REGEX = /_\\d{1,8}$/;\r\n\r\nconst ENTITY_CSS_REGEX = '^' + EntityClasses.ENTITY_INFO_NAME + '$';\r\nconst ENTITY_ID_CSS_REGEX = '^' + EntityClasses.ENTITY_ID_PREFIX;\r\nconst ENTITY_TYPE_CSS_REGEX = '^' + EntityClasses.ENTITY_TYPE_PREFIX;\r\nconst ENTITY_READONLY_CSS_REGEX = '^' + EntityClasses.ENTITY_READONLY_PREFIX;\r\nconst ALLOWED_CSS_CLASSES = [\r\n    ENTITY_CSS_REGEX,\r\n    ENTITY_ID_CSS_REGEX,\r\n    ENTITY_TYPE_CSS_REGEX,\r\n    ENTITY_READONLY_CSS_REGEX,\r\n];\r\n\r\n/**\r\n * @internal\r\n * Entity Plugin helps handle all operations related to an entity and generate entity specified events\r\n */\r\nexport default class EntityPlugin implements PluginWithState<EntityPluginState> {\r\n    private editor: IEditor;\r\n    private state: EntityPluginState;\r\n\r\n    /**\r\n     * Construct a new instance of EntityPlugin\r\n     */\r\n    constructor() {\r\n        this.state = {\r\n            clickingPoint: null,\r\n            knownEntityElements: [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Entity';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n        this.state.knownEntityElements = [];\r\n        this.state.clickingPoint = null;\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.MouseDown:\r\n                this.handleMouseDownEvent(event.rawEvent);\r\n                break;\r\n            case PluginEventType.MouseUp:\r\n                this.handleMouseUpEvent(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.handleKeyDownEvent(event.rawEvent);\r\n                break;\r\n            case PluginEventType.BeforeCutCopy:\r\n                if (event.isCut) {\r\n                    this.handleCutEvent(event.rawEvent);\r\n                }\r\n                break;\r\n            case PluginEventType.BeforePaste:\r\n                this.handleBeforePasteEvent(event.fragment, event.sanitizingOption);\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                this.handleContentChangedEvent(event.source == ChangeSource.SetContent);\r\n                break;\r\n            case PluginEventType.EditorReady:\r\n                this.handleContentChangedEvent(true /*resetAll*/);\r\n                break;\r\n            case PluginEventType.ExtractContentWithDom:\r\n                this.handleExtractContentWithDomEvent(event.clonedRoot);\r\n                break;\r\n            case PluginEventType.ContextMenu:\r\n                this.handleContextMenuEvent(event.rawEvent);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private handleContextMenuEvent(event: UIEvent) {\r\n        const node = event.target as Node;\r\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\r\n\r\n        if (entityElement) {\r\n            event.preventDefault();\r\n            this.triggerEvent(entityElement, EntityOperation.ContextMenu, event);\r\n        }\r\n    }\r\n\r\n    private handleCutEvent = (event: ClipboardEvent) => {\r\n        const range = this.editor.getSelectionRange();\r\n        if (range && !range.collapsed) {\r\n            this.checkRemoveEntityForRange(event);\r\n        }\r\n    };\r\n\r\n    private handleMouseDownEvent(event: MouseEvent) {\r\n        const { target, pageX, pageY } = event;\r\n        const node = target as Node;\r\n        const entityElement = node && this.editor.getElementAtCursor(getEntitySelector(), node);\r\n        if (entityElement && !entityElement.isContentEditable) {\r\n            event.preventDefault();\r\n            this.state.clickingPoint = { pageX, pageY };\r\n        }\r\n    }\r\n\r\n    private handleMouseUpEvent(event: MouseEvent) {\r\n        const { target, pageX, pageY } = event;\r\n        const node = target as Node;\r\n        let entityElement: HTMLElement;\r\n\r\n        if (\r\n            this.state.clickingPoint &&\r\n            this.state.clickingPoint.pageX == pageX &&\r\n            this.state.clickingPoint.pageY == pageY &&\r\n            node &&\r\n            !!(entityElement = this.editor.getElementAtCursor(getEntitySelector(), node))\r\n        ) {\r\n            event.preventDefault();\r\n            this.triggerEvent(entityElement, EntityOperation.Click, event);\r\n\r\n            workaroundSelectionIssueForIE(this.editor);\r\n        }\r\n\r\n        this.state.clickingPoint = null;\r\n    }\r\n\r\n    private handleKeyDownEvent(event: KeyboardEvent) {\r\n        if (\r\n            isCharacterValue(event) ||\r\n            event.which == Keys.BACKSPACE ||\r\n            event.which == Keys.DELETE\r\n        ) {\r\n            const range = this.editor.getSelectionRange();\r\n            if (!range.collapsed) {\r\n                this.checkRemoveEntityForRange(event);\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleBeforePasteEvent(\r\n        fragment: DocumentFragment,\r\n        sanitizingOption: HtmlSanitizerOptions\r\n    ) {\r\n        const range = this.editor.getSelectionRange();\r\n\r\n        if (!range.collapsed) {\r\n            this.checkRemoveEntityForRange(null /*rawEvent*/);\r\n        }\r\n\r\n        arrayPush(sanitizingOption.additionalAllowedCssClasses, ALLOWED_CSS_CLASSES);\r\n    }\r\n\r\n    private handleContentChangedEvent(resetAll: boolean) {\r\n        this.state.knownEntityElements = resetAll\r\n            ? []\r\n            : this.state.knownEntityElements.filter(node => this.editor.contains(node));\r\n        const allId = this.state.knownEntityElements\r\n            .map(e => getEntityFromElement(e)?.id)\r\n            .filter(x => !!x);\r\n\r\n        this.editor.queryElements(getEntitySelector(), element => {\r\n            if (this.state.knownEntityElements.indexOf(element) < 0) {\r\n                this.state.knownEntityElements.push(element);\r\n\r\n                const entity = getEntityFromElement(element);\r\n\r\n                this.hydrateEntity(entity, allId);\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleExtractContentWithDomEvent(root: HTMLElement) {\r\n        toArray(root.querySelectorAll(getEntitySelector())).forEach(element => {\r\n            element.removeAttribute('contentEditable');\r\n\r\n            this.triggerEvent(element as HTMLElement, EntityOperation.ReplaceTemporaryContent);\r\n        });\r\n    }\r\n\r\n    private checkRemoveEntityForRange(event: Event) {\r\n        const editableEntityElements: HTMLElement[] = [];\r\n        const selector = getEntitySelector();\r\n        this.editor.queryElements(selector, QueryScope.OnSelection, element => {\r\n            if (element.isContentEditable) {\r\n                editableEntityElements.push(element);\r\n            } else {\r\n                this.triggerEvent(element, EntityOperation.Overwrite, event);\r\n            }\r\n        });\r\n\r\n        // For editable entities, we need to check if it is fully or partially covered by current selection,\r\n        // and trigger different events;\r\n        if (editableEntityElements.length > 0) {\r\n            const inSelectionEntityElements = this.editor.queryElements(\r\n                selector,\r\n                QueryScope.InSelection\r\n            );\r\n            editableEntityElements.forEach(element => {\r\n                const isFullyCovered = inSelectionEntityElements.indexOf(element) >= 0;\r\n                this.triggerEvent(\r\n                    element,\r\n                    isFullyCovered ? EntityOperation.Overwrite : EntityOperation.PartialOverwrite,\r\n                    event\r\n                );\r\n            });\r\n        }\r\n    }\r\n\r\n    private hydrateEntity(entity: Entity, knownIds: string[]) {\r\n        const { id, type, wrapper, isReadonly } = entity;\r\n        const match = ENTITY_ID_REGEX.exec(id);\r\n        const baseId = (match ? id.substr(0, id.length - match[0].length) : id) || type;\r\n\r\n        // Make sure entity id is unique\r\n        let newId = '';\r\n\r\n        for (let num = (match && parseInt(match[1])) || 0; ; num++) {\r\n            newId = num > 0 ? `${baseId}_${num}` : baseId;\r\n\r\n            if (knownIds.indexOf(newId) < 0) {\r\n                knownIds.push(newId);\r\n                break;\r\n            }\r\n        }\r\n\r\n        commitEntity(wrapper, type, isReadonly, newId);\r\n\r\n        this.triggerEvent(wrapper, EntityOperation.NewEntity);\r\n    }\r\n\r\n    private triggerEvent(element: HTMLElement, operation: EntityOperation, rawEvent?: Event) {\r\n        const entity = element && getEntityFromElement(element);\r\n\r\n        if (entity) {\r\n            this.editor.triggerPluginEvent(PluginEventType.EntityOperation, {\r\n                operation,\r\n                rawEvent,\r\n                entity,\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * IE will show a resize border around the readonly content within content editable DIV\r\n * This is a workaround to remove it by temporarily move focus out of editor\r\n */\r\nconst workaroundSelectionIssueForIE = Browser.isIE\r\n    ? (editor: IEditor) => {\r\n          editor.runAsync(editor => {\r\n              const workaroundButton = editor.getCustomData('ENTITY_IE_FOCUS_BUTTON', () => {\r\n                  const button = editor.getDocument().createElement('button');\r\n                  button.style.overflow = 'hidden';\r\n                  button.style.position = 'fixed';\r\n                  button.style.width = '0';\r\n                  button.style.height = '0';\r\n                  button.style.left = '0';\r\n                  button.style.top = '-1000px';\r\n                  button.onblur = () => {\r\n                      button.style.display = 'none';\r\n                  };\r\n\r\n                  editor.insertNode(button, {\r\n                      position: ContentPosition.Outside,\r\n                  });\r\n\r\n                  return button;\r\n              });\r\n\r\n              workaroundButton.style.display = '';\r\n              const range = editor.getDocument().createRange();\r\n              range.setStart(workaroundButton, 0);\r\n              try {\r\n                  window.getSelection().removeAllRanges();\r\n                  window.getSelection().addRange(range);\r\n              } catch {}\r\n          });\r\n      }\r\n    : () => {};\r\n","import { Browser, getComputedStyles } from 'roosterjs-editor-dom';\r\nimport {\r\n    DefaultFormat,\r\n    DocumentCommand,\r\n    EditorOptions,\r\n    IEditor,\r\n    LifecyclePluginState,\r\n    PluginEventType,\r\n    PluginWithState,\r\n    PluginEvent,\r\n    ChangeSource,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst CONTENT_EDITABLE_ATTRIBUTE_NAME = 'contenteditable';\r\nconst COMMANDS: {\r\n    [command: string]: any;\r\n} = Browser.isFirefox\r\n    ? {\r\n          /**\r\n           * Disable these object resizing for firefox since other browsers don't have these behaviors\r\n           */\r\n          [DocumentCommand.EnableObjectResizing]: false,\r\n          [DocumentCommand.EnableInlineTableEditing]: false,\r\n      }\r\n    : Browser.isIE\r\n    ? {\r\n          /**\r\n           * Change the default paragraph separater to DIV. This is mainly for IE since its default setting is P\r\n           */\r\n          [DocumentCommand.DefaultParagraphSeparator]: 'div',\r\n\r\n          /**\r\n           * Disable auto link feature in IE since we have our own implementation\r\n           */\r\n          [DocumentCommand.AutoUrlDetect]: false,\r\n      }\r\n    : {};\r\n\r\nconst DARK_MODE_DEFAULT_FORMAT = {\r\n    backgroundColors: {\r\n        darkModeColor: 'rgb(51,51,51)',\r\n        lightModeColor: 'rgb(255,255,255)',\r\n    },\r\n    textColors: {\r\n        darkModeColor: 'rgb(255,255,255)',\r\n        lightModeColor: 'rgb(0,0,0)',\r\n    },\r\n};\r\n\r\n/**\r\n * @internal\r\n * Lifecycle plugin handles editor initialization and disposing\r\n */\r\nexport default class LifecyclePlugin implements PluginWithState<LifecyclePluginState> {\r\n    private editor: IEditor;\r\n    private state: LifecyclePluginState;\r\n    private initialContent: string;\r\n    private contentDivFormat: string[];\r\n    private initializer: () => void;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Construct a new instance of LifecyclePlugin\r\n     * @param options The editor options\r\n     * @param contentDiv The editor content DIV\r\n     */\r\n    constructor(options: EditorOptions, contentDiv: HTMLDivElement) {\r\n        this.initialContent = options.initialContent || contentDiv.innerHTML || '';\r\n        this.contentDivFormat = getComputedStyles(contentDiv);\r\n\r\n        // Make the container editable and set its selection styles\r\n        if (contentDiv.getAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME) === null) {\r\n            this.initializer = () => {\r\n                contentDiv.contentEditable = 'true';\r\n                this.setSelectStyle(contentDiv, 'text');\r\n            };\r\n            this.disposer = () => {\r\n                this.setSelectStyle(contentDiv, '');\r\n                contentDiv.removeAttribute(CONTENT_EDITABLE_ATTRIBUTE_NAME);\r\n            };\r\n        }\r\n\r\n        this.state = {\r\n            customData: {},\r\n            defaultFormat: options.defaultFormat || null,\r\n            isDarkMode: !!options.inDarkMode,\r\n            onExternalContentTransform: options.onExternalContentTransform,\r\n            experimentalFeatures: options.experimentalFeatures || [],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Lifecycle';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n\r\n        // Calculate default format\r\n        this.recalculateDefaultFormat();\r\n\r\n        // Ensure initial content and its format\r\n        this.editor.setContent(this.initialContent, false /*triggerContentChangedEvent*/);\r\n\r\n        // Set content DIV to be editable\r\n        this.initializer?.();\r\n\r\n        // Do proper change for browsers to disable some browser-specified behaviors.\r\n        this.adjustBrowserBehavior();\r\n\r\n        // Let other plugins know that we are ready\r\n        this.editor.triggerPluginEvent(PluginEventType.EditorReady, {}, true /*broadcast*/);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor.triggerPluginEvent(PluginEventType.BeforeDispose, {}, true /*broadcast*/);\r\n\r\n        Object.keys(this.state.customData).forEach(key => {\r\n            const data = this.state.customData[key];\r\n\r\n            if (data && data.disposer) {\r\n                data.disposer(data.value);\r\n            }\r\n\r\n            delete this.state.customData[key];\r\n        });\r\n\r\n        if (this.disposer) {\r\n            this.disposer();\r\n            this.disposer = null;\r\n            this.initializer = null;\r\n        }\r\n\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            event.eventType == PluginEventType.ContentChanged &&\r\n            (event.source == ChangeSource.SwitchToDarkMode ||\r\n                event.source == ChangeSource.SwitchToLightMode)\r\n        ) {\r\n            this.state.isDarkMode = event.source == ChangeSource.SwitchToDarkMode;\r\n            this.recalculateDefaultFormat();\r\n        }\r\n    }\r\n\r\n    private adjustBrowserBehavior() {\r\n        Object.keys(COMMANDS).forEach(command => {\r\n            // Catch any possible exception since this should not block the initialization of editor\r\n            try {\r\n                this.editor.getDocument().execCommand(command, false, COMMANDS[command]);\r\n            } catch {}\r\n        });\r\n    }\r\n\r\n    private setSelectStyle(node: HTMLElement, value: string) {\r\n        node.style.userSelect = value;\r\n        node.style.msUserSelect = value;\r\n        node.style.webkitUserSelect = value;\r\n    }\r\n\r\n    private recalculateDefaultFormat() {\r\n        const { defaultFormat: baseFormat, isDarkMode } = this.state;\r\n\r\n        if (isDarkMode && baseFormat) {\r\n            if (!baseFormat.backgroundColors) {\r\n                baseFormat.backgroundColors = DARK_MODE_DEFAULT_FORMAT.backgroundColors;\r\n            }\r\n            if (!baseFormat.textColors) {\r\n                baseFormat.textColors = DARK_MODE_DEFAULT_FORMAT.textColors;\r\n            }\r\n        }\r\n\r\n        if (baseFormat && Object.keys(baseFormat).length === 0) {\r\n            return;\r\n        }\r\n\r\n        const {\r\n            fontFamily,\r\n            fontSize,\r\n            textColor,\r\n            textColors,\r\n            backgroundColor,\r\n            backgroundColors,\r\n            bold,\r\n            italic,\r\n            underline,\r\n        } = baseFormat || <DefaultFormat>{};\r\n        const defaultFormat = this.contentDivFormat;\r\n\r\n        this.state.defaultFormat = {\r\n            fontFamily: fontFamily || defaultFormat[0],\r\n            fontSize: fontSize || defaultFormat[1],\r\n            get textColor() {\r\n                return textColors\r\n                    ? isDarkMode\r\n                        ? textColors.darkModeColor\r\n                        : textColors.lightModeColor\r\n                    : textColor || defaultFormat[2];\r\n            },\r\n            textColors: textColors,\r\n            get backgroundColor() {\r\n                return backgroundColors\r\n                    ? isDarkMode\r\n                        ? backgroundColors.darkModeColor\r\n                        : backgroundColors.lightModeColor\r\n                    : backgroundColor || '';\r\n            },\r\n            backgroundColors: backgroundColors,\r\n            bold: bold,\r\n            italic: italic,\r\n            underline: underline,\r\n        };\r\n    }\r\n}\r\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * MouseUpPlugin help trigger MouseUp event even when mouse up happens outside editor\r\n * as long as the mouse was pressed within Editor before\r\n */\r\nexport default class MouseUpPlugin implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private mouseUpEventListerAdded: boolean;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'MouseUp';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.removeMouseUpEventListener();\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.MouseDown && !this.mouseUpEventListerAdded) {\r\n            this.editor\r\n                .getDocument()\r\n                .addEventListener('mouseup', this.onMouseUp, true /*setCapture*/);\r\n            this.mouseUpEventListerAdded = true;\r\n        }\r\n    }\r\n    private removeMouseUpEventListener() {\r\n        if (this.mouseUpEventListerAdded) {\r\n            this.mouseUpEventListerAdded = false;\r\n            this.editor.getDocument().removeEventListener('mouseup', this.onMouseUp, true);\r\n        }\r\n    }\r\n\r\n    private onMouseUp = (rawEvent: MouseEvent) => {\r\n        if (this.editor) {\r\n            this.removeMouseUpEventListener();\r\n            this.editor.triggerPluginEvent(PluginEventType.MouseUp, {\r\n                rawEvent,\r\n            });\r\n        }\r\n    };\r\n}\r\n","import { Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    IEditor,\r\n    PendingFormatStatePluginState,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginWithState,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * PendingFormatStatePlugin handles pending format state management\r\n */\r\nexport default class PendingFormatStatePlugin\r\n    implements PluginWithState<PendingFormatStatePluginState> {\r\n    private editor: IEditor;\r\n    private state: PendingFormatStatePluginState;\r\n\r\n    /**\r\n     * Construct a new instance of PendingFormatStatePlugin\r\n     * @param options The editor options\r\n     * @param contentDiv The editor content DIV\r\n     */\r\n    constructor() {\r\n        this.state = {\r\n            pendableFormatPosition: null,\r\n            pendableFormatState: null,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'PendingFormatState';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.PendingFormatStateChanged:\r\n                // Got PendingFormatStateChagned event, cache current position and pending format\r\n                this.state.pendableFormatPosition = this.getCurrentPosition();\r\n                this.state.pendableFormatState = event.formatState;\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n            case PluginEventType.MouseDown:\r\n            case PluginEventType.ContentChanged:\r\n                // If content or position is changed (by keyboard, mouse, or code),\r\n                // check if current position is still the same with the cached one (if exist),\r\n                // and clear cached format if position is changed since it is out-of-date now\r\n                if (\r\n                    this.state.pendableFormatPosition &&\r\n                    !this.state.pendableFormatPosition.equalTo(this.getCurrentPosition())\r\n                ) {\r\n                    this.clear();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private clear() {\r\n        this.state.pendableFormatPosition = null;\r\n        this.state.pendableFormatState = null;\r\n    }\r\n\r\n    private getCurrentPosition() {\r\n        let range = this.editor.getSelectionRange();\r\n        return range && Position.getStart(range).normalize();\r\n    }\r\n}\r\n","import { Browser, LinkInlineElement, Position } from 'roosterjs-editor-dom';\r\nimport {\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * @internal\r\n * TypeAfterLinkPlugin Component helps handle typing event when cursor is right after a link.\r\n * When typing/pasting after a link, browser may put the new charactor inside link.\r\n * This plugin overrides this behavior to always insert outside of link.\r\n */\r\nexport default class TypeAfterLinkPlugin implements EditorPlugin {\r\n    private editor: IEditor;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TypeAfterLink';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            (Browser.isFirefox && event.eventType == PluginEventType.KeyPress) ||\r\n            event.eventType == PluginEventType.BeforePaste\r\n        ) {\r\n            let range = this.editor.getSelectionRange();\r\n            if (range && range.collapsed && this.editor.getElementAtCursor('A[href]')) {\r\n                let searcher = this.editor.getContentSearcherOfCursor(event);\r\n                let inlineElement = searcher.getInlineElementBefore();\r\n                if (inlineElement instanceof LinkInlineElement) {\r\n                    this.editor.select(\r\n                        new Position(inlineElement.getContainerNode(), PositionType.After)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { EditorPlugin, IEditor, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\nimport { findClosestElementAncestor, Position } from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n * Typing Component helps to ensure typing is always happening under a DOM container\r\n */\r\nexport default class TypeInContainerPlugin implements EditorPlugin {\r\n    private editor: IEditor;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TypeInContainer';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.KeyPress) {\r\n            // If normalization was not possible before the keypress,\r\n            // check again after the keyboard event has been processed by browser native behaviour.\r\n            //\r\n            // This handles the case where the keyboard event that first inserts content happens when\r\n            // there is already content under the selection (e.g. Ctrl+a -> type new content).\r\n            //\r\n            // Only scheudle when the range is not collapsed to catch this edge case.\r\n            let range = this.editor.getSelectionRange();\r\n\r\n            if (!range || this.editor.contains(findClosestElementAncestor(range.startContainer))) {\r\n                return;\r\n            }\r\n\r\n            if (range.collapsed) {\r\n                this.editor.ensureTypeInContainer(Position.getStart(range), event.rawEvent);\r\n            } else {\r\n                this.editor.runAsync(editor => {\r\n                    editor.ensureTypeInContainer(editor.getFocusedPosition(), event.rawEvent);\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n","import {\r\n    EditorOptions,\r\n    IEditor,\r\n    Keys,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginWithState,\r\n    UndoPluginState,\r\n    UndoSnapshotsService,\r\n} from 'roosterjs-editor-types';\r\nimport {\r\n    addSnapshot,\r\n    canMoveCurrentSnapshot,\r\n    clearProceedingSnapshots,\r\n    createSnapshots,\r\n    isCtrlOrMetaPressed,\r\n    moveCurrentSnapsnot,\r\n    canUndoAutoComplete,\r\n} from 'roosterjs-editor-dom';\r\n\r\n// Max stack size that cannot be exceeded. When exceeded, old undo history will be dropped\r\n// to keep size under limit. This is kept at 10MB\r\nconst MAXSIZELIMIT = 1e7;\r\n\r\n/**\r\n * @internal\r\n * Provides snapshot based undo service for Editor\r\n */\r\nexport default class UndoPlugin implements PluginWithState<UndoPluginState> {\r\n    private editor: IEditor;\r\n    private lastKeyPress: number;\r\n    private state: UndoPluginState;\r\n\r\n    /**\r\n     * Construct a new instance of UndoPlugin\r\n     * @param options The wrapper of the state object\r\n     */\r\n    constructor(options: EditorOptions) {\r\n        this.state = {\r\n            snapshotsService: options.undoSnapshotService || createUndoSnapshots(),\r\n            isRestoring: false,\r\n            hasNewContent: false,\r\n            isNested: false,\r\n            autoCompletePosition: null,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Undo';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Get plugin state object\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Check if the plugin should handle the given event exclusively.\r\n     * @param event The event to check\r\n     */\r\n    willHandleEventExclusively(event: PluginEvent) {\r\n        return (\r\n            event.eventType == PluginEventType.KeyDown &&\r\n            event.rawEvent.which == Keys.BACKSPACE &&\r\n            this.canUndoAutoComplete()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent): void {\r\n        // if editor is in IME, don't do anything\r\n        if (!this.editor || this.editor.isInIME()) {\r\n            return;\r\n        }\r\n\r\n        switch (event.eventType) {\r\n            case PluginEventType.EditorReady:\r\n                const undoState = this.editor.getUndoState();\r\n                if (!undoState.canUndo && !undoState.canRedo) {\r\n                    // Only add initial snapshot when there is no existing snapshot\r\n                    // Otherwise preserved undo/redo state may be ruined\r\n                    this.addUndoSnapshot();\r\n                }\r\n                break;\r\n            case PluginEventType.KeyDown:\r\n                this.onKeyDown(event.rawEvent);\r\n                break;\r\n            case PluginEventType.KeyPress:\r\n                this.onKeyPress(event.rawEvent);\r\n                break;\r\n            case PluginEventType.CompositionEnd:\r\n                this.clearRedoForInput();\r\n                this.addUndoSnapshot();\r\n                break;\r\n            case PluginEventType.ContentChanged:\r\n                if (!this.state.isRestoring) {\r\n                    this.clearRedoForInput();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onKeyDown(evt: KeyboardEvent): void {\r\n        // Handle backspace/delete when there is a selection to take a snapshot\r\n        // since we want the state prior to deletion restorable\r\n        if (evt.which == Keys.BACKSPACE || evt.which == Keys.DELETE) {\r\n            if (evt.which == Keys.BACKSPACE && this.canUndoAutoComplete()) {\r\n                evt.preventDefault();\r\n                this.editor.undo();\r\n                this.state.autoCompletePosition = null;\r\n                this.lastKeyPress = evt.which;\r\n            } else {\r\n                let selectionRange = this.editor.getSelectionRange();\r\n\r\n                // Add snapshot when\r\n                // 1. Something has been selected (not collapsed), or\r\n                // 2. It has a different key code from the last keyDown event (to prevent adding too many snapshot when keeping press the same key), or\r\n                // 3. Ctrl/Meta key is pressed so that a whole word will be deleted\r\n                if (\r\n                    selectionRange &&\r\n                    (!selectionRange.collapsed ||\r\n                        this.lastKeyPress != evt.which ||\r\n                        isCtrlOrMetaPressed(evt))\r\n                ) {\r\n                    this.addUndoSnapshot();\r\n                }\r\n\r\n                // Since some content is deleted, always set hasNewContent to true so that we will take undo snapshot next time\r\n                this.state.hasNewContent = true;\r\n                this.lastKeyPress = evt.which;\r\n            }\r\n        } else if (evt.which >= Keys.PAGEUP && evt.which <= Keys.DOWN) {\r\n            // PageUp, PageDown, Home, End, Left, Right, Up, Down\r\n            if (this.state.hasNewContent) {\r\n                this.addUndoSnapshot();\r\n            }\r\n            this.lastKeyPress = 0;\r\n        }\r\n    }\r\n\r\n    private onKeyPress(evt: KeyboardEvent): void {\r\n        if (evt.metaKey) {\r\n            // if metaKey is pressed, simply return since no actual effect will be taken on the editor.\r\n            // this is to prevent changing hasNewContent to true when meta + v to paste on Safari.\r\n            return;\r\n        }\r\n\r\n        let range = this.editor.getSelectionRange();\r\n        if (\r\n            (range && !range.collapsed) ||\r\n            (evt.which == Keys.SPACE && this.lastKeyPress != Keys.SPACE) ||\r\n            evt.which == Keys.ENTER\r\n        ) {\r\n            this.addUndoSnapshot();\r\n            if (evt.which == Keys.ENTER) {\r\n                // Treat ENTER as new content so if there is no input after ENTER and undo,\r\n                // we restore the snapshot before ENTER\r\n                this.state.hasNewContent = true;\r\n            }\r\n        } else {\r\n            this.clearRedoForInput();\r\n        }\r\n\r\n        this.lastKeyPress = evt.which;\r\n    }\r\n\r\n    private clearRedoForInput() {\r\n        this.state.snapshotsService.clearRedo();\r\n        this.lastKeyPress = 0;\r\n        this.state.hasNewContent = true;\r\n    }\r\n\r\n    private canUndoAutoComplete() {\r\n        return (\r\n            this.state.snapshotsService.canUndoAutoComplete() &&\r\n            this.state.autoCompletePosition?.equalTo(this.editor.getFocusedPosition())\r\n        );\r\n    }\r\n\r\n    private addUndoSnapshot() {\r\n        this.editor.addUndoSnapshot();\r\n        this.state.autoCompletePosition = null;\r\n    }\r\n}\r\n\r\nfunction createUndoSnapshots(): UndoSnapshotsService {\r\n    const snapshots = createSnapshots(MAXSIZELIMIT);\r\n\r\n    return {\r\n        canMove: (delta: number): boolean => canMoveCurrentSnapshot(snapshots, delta),\r\n        move: (delta: number): string => moveCurrentSnapsnot(snapshots, delta),\r\n        addSnapshot: (snapshot: string, isAutoCompleteSnapshot: boolean) =>\r\n            addSnapshot(snapshots, snapshot, isAutoCompleteSnapshot),\r\n        clearRedo: () => clearProceedingSnapshots(snapshots),\r\n        canUndoAutoComplete: () => canUndoAutoComplete(snapshots),\r\n    };\r\n}\r\n","export { default as HyperLink } from './HyperLink';\r\n","import { Browser, isCharacterValue, isCtrlOrMetaPressed, matchLink } from 'roosterjs-editor-dom';\r\nimport { EditorPlugin, IEditor, Keys, PluginEvent, PluginEventType } from 'roosterjs-editor-types';\r\n\r\n/**\r\n * An editor plugin that show a tooltip for existing link\r\n */\r\nexport default class HyperLink implements EditorPlugin {\r\n    private originalHref: string;\r\n    private trackedLink: HTMLAnchorElement = null;\r\n    private editor: IEditor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of HyperLink class\r\n     * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.\r\n     * Default value is to return the href itself. If null, there will be no tooltip text.\r\n     * @param target (Optional) Target window name for hyperlink. If null, will use \"_blank\"\r\n     * @param onLinkClick (Optional) Open link callback (return false to use default behavior)\r\n     */\r\n    constructor(\r\n        private getTooltipCallback: (href: string, a: HTMLAnchorElement) => string = href => href,\r\n        private target?: string,\r\n        private onLinkClick?: (anchor: HTMLAnchorElement, mouseEvent: MouseEvent) => boolean | void\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Hyperlink';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: IEditor): void {\r\n        this.editor = editor;\r\n        this.disposer =\r\n            this.getTooltipCallback &&\r\n            editor.addDomEventHandler({\r\n                mouseover: this.onMouse,\r\n                mouseout: this.onMouse,\r\n                blur: this.onBlur,\r\n            });\r\n    }\r\n\r\n    protected onMouse = (e: MouseEvent) => {\r\n        const a = this.editor.getElementAtCursor('a[href]', <Node>e.target) as HTMLAnchorElement;\r\n        const href = this.tryGetHref(a);\r\n\r\n        if (href) {\r\n            this.editor.setEditorDomAttribute(\r\n                'title',\r\n                e.type == 'mouseover' ? this.getTooltipCallback(href, a) : null\r\n            );\r\n        }\r\n    };\r\n\r\n    protected onBlur = (e: FocusEvent) => {\r\n        if (this.trackedLink) {\r\n            this.updateLinkHrefIfShouldUpdate();\r\n        }\r\n\r\n        this.resetLinkTracking();\r\n    };\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        if (this.disposer) {\r\n            this.disposer();\r\n            this.disposer = null;\r\n        }\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent): void {\r\n        if (\r\n            event.eventType == PluginEventType.MouseUp ||\r\n            (event.eventType == PluginEventType.KeyUp &&\r\n                (!this.isContentEditValue(event.rawEvent) || event.rawEvent.which == Keys.SPACE)) ||\r\n            event.eventType == PluginEventType.ContentChanged\r\n        ) {\r\n            const anchor = this.editor.getElementAtCursor(\r\n                'A[href]',\r\n                null /*startFrom*/,\r\n                event\r\n            ) as HTMLAnchorElement;\r\n\r\n            const shouldCheckUpdateLink =\r\n                anchor !== this.trackedLink ||\r\n                event.eventType == PluginEventType.KeyUp ||\r\n                event.eventType == PluginEventType.ContentChanged;\r\n\r\n            if (\r\n                this.trackedLink &&\r\n                (shouldCheckUpdateLink || this.tryGetHref(this.trackedLink) !== this.originalHref)\r\n            ) {\r\n                // If cursor has moved out of previously tracked link\r\n                // update link href if display text doesn't match href anymore.\r\n                if (shouldCheckUpdateLink) {\r\n                    this.updateLinkHrefIfShouldUpdate();\r\n                }\r\n\r\n                // If the link's href value was edited, or the cursor has moved out of the\r\n                // previously tracked link, stop tracking the link.\r\n                this.resetLinkTracking();\r\n            }\r\n\r\n            // Cache link and href value if its href attribute currently matches its display text\r\n            if (!this.trackedLink && this.doesLinkDisplayMatchHref(anchor)) {\r\n                this.trackedLink = anchor;\r\n                this.originalHref = this.tryGetHref(anchor);\r\n            }\r\n        }\r\n\r\n        if (event.eventType == PluginEventType.MouseUp) {\r\n            const anchor = this.editor.getElementAtCursor(\r\n                'A',\r\n                <Node>event.rawEvent.srcElement\r\n            ) as HTMLAnchorElement;\r\n\r\n            if (anchor) {\r\n                if (this.onLinkClick && this.onLinkClick(anchor, event.rawEvent) !== false) {\r\n                    return;\r\n                }\r\n\r\n                let href: string;\r\n                if (\r\n                    !Browser.isFirefox &&\r\n                    (href = this.tryGetHref(anchor)) &&\r\n                    isCtrlOrMetaPressed(event.rawEvent) &&\r\n                    event.rawEvent.button === 0\r\n                ) {\r\n                    try {\r\n                        const target = this.target || '_blank';\r\n                        const window = this.editor.getDocument().defaultView;\r\n                        window.open(href, target);\r\n                    } catch {}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try get href from an anchor element\r\n     * The reason this is put in a try-catch is that\r\n     * it has been seen that accessing href may throw an exception, in particular on IE/Edge\r\n     */\r\n    private tryGetHref(anchor: HTMLAnchorElement): string {\r\n        try {\r\n            return anchor ? anchor.href : null;\r\n        } catch {}\r\n    }\r\n\r\n    /**\r\n     * Determines if KeyboardEvent is meant to edit content\r\n     */\r\n    private isContentEditValue(event: KeyboardEvent): boolean {\r\n        return (\r\n            isCharacterValue(event) || event.which == Keys.BACKSPACE || event.which == Keys.DELETE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Updates the href of the tracked link if the display text doesn't match href anymore\r\n     */\r\n    private updateLinkHrefIfShouldUpdate() {\r\n        if (!this.doesLinkDisplayMatchHref(this.trackedLink)) {\r\n            this.updateLinkHref();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the tracked link and its original href value so that it's back to default state\r\n     */\r\n    private resetLinkTracking() {\r\n        this.trackedLink = null;\r\n        this.originalHref = '';\r\n    }\r\n\r\n    /**\r\n     * Compares the normalized URL of inner text of element to its href to see if they match.\r\n     */\r\n    private doesLinkDisplayMatchHref(element: HTMLAnchorElement): boolean {\r\n        if (element) {\r\n            let display = element.innerText.trim();\r\n\r\n            // We first escape the display text so that any text passed into the regex is not\r\n            // treated as a special character.\r\n            let escapedDisplay = display.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n            let rule = new RegExp(`^(?:https?:\\\\/\\\\/)?${escapedDisplay}\\\\/?`, 'i');\r\n            let href = this.tryGetHref(element);\r\n            if (href !== null) {\r\n                return rule.test(href);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Update href of an element in place to new display text if it's a valid URL\r\n     */\r\n    private updateLinkHref() {\r\n        if (this.trackedLink) {\r\n            let linkData = matchLink(this.trackedLink.innerText.trim());\r\n            if (linkData !== null) {\r\n                this.editor.addUndoSnapshot(() => {\r\n                    this.trackedLink.href = linkData.normalizedUrl;\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n","export { default as Paste } from './Paste';\r\n","import convertPastedContentFromExcel from './excelConverter/convertPastedContentFromExcel';\r\nimport convertPastedContentFromWord from './wordConverter/convertPastedContentFromWord';\r\nimport handleLineMerge from './lineMerge/handleLineMerge';\r\nimport { toArray } from 'roosterjs-editor-dom';\r\nimport { WAC_IDENTIFING_SELECTOR } from './officeOnlineConverter/constants';\r\nimport {\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\nimport convertPastedContentFromWordOnline, {\r\n    isWordOnlineWithList,\r\n} from './officeOnlineConverter/convertPastedContentFromWordOnline';\r\n\r\nconst WORD_ATTRIBUTE_NAME = 'xmlns:w';\r\nconst WORD_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:word';\r\nconst EXCEL_ATTRIBUTE_NAME = 'xmlns:x';\r\nconst EXCEL_ATTRIBUTE_VALUE = 'urn:schemas-microsoft-com:office:excel';\r\nconst EXCEL_ONLINE_ATTRIBUTE_NAME = 'ProgId';\r\nconst EXCEL_ONLINE_ATTRIBUTE_VALUE = 'Excel.Sheet';\r\nconst GOOGLE_SHEET_NODE_NAME = 'google-sheets-html-origin';\r\n\r\n/**\r\n * Paste plugin, handles BeforePaste event and reformat some special content, including:\r\n * 1. Content copied from Word\r\n * 2. Content copied from Excel\r\n * 3. Content copied from Word Online or Onenote Online\r\n */\r\nexport default class Paste implements EditorPlugin {\r\n    private editor: IEditor;\r\n\r\n    /**\r\n     * Construct a new instance of Paste class\r\n     * @param unknownTagReplacement Replace solution of unknown tags, default behavior is to replace with SPAN\r\n     */\r\n    constructor(private unknownTagReplacement: string = 'SPAN') {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Paste';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {}\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.BeforePaste) {\r\n            const { htmlAttributes, fragment, sanitizingOption } = event;\r\n            let wacListElements: Node[];\r\n\r\n            if (htmlAttributes[WORD_ATTRIBUTE_NAME] == WORD_ATTRIBUTE_VALUE) {\r\n                // Handle HTML copied from Word\r\n                convertPastedContentFromWord(event);\r\n            } else if (\r\n                htmlAttributes[EXCEL_ATTRIBUTE_NAME] == EXCEL_ATTRIBUTE_VALUE ||\r\n                htmlAttributes[EXCEL_ONLINE_ATTRIBUTE_NAME] == EXCEL_ONLINE_ATTRIBUTE_VALUE\r\n            ) {\r\n                // Handle HTML copied from Excel\r\n                convertPastedContentFromExcel(event);\r\n            } else if (\r\n                (wacListElements = toArray(fragment.querySelectorAll(WAC_IDENTIFING_SELECTOR))) &&\r\n                wacListElements.length > 0\r\n            ) {\r\n                // Once it is known that the document is from WAC\r\n                // We need to remove the display property and margin from all the list item\r\n                wacListElements.forEach((el: HTMLElement) => {\r\n                    el.style.display = null;\r\n                    el.style.margin = null;\r\n                });\r\n                // call conversion function if the pasted content is from word online and\r\n                // has list element in the pasted content.\r\n                if (isWordOnlineWithList(fragment)) {\r\n                    convertPastedContentFromWordOnline(fragment);\r\n                }\r\n            } else if (fragment.querySelector(GOOGLE_SHEET_NODE_NAME)) {\r\n                sanitizingOption.additionalTagReplacements[GOOGLE_SHEET_NODE_NAME] = '*';\r\n            } else if (this.editor.isFeatureEnabled(ExperimentalFeatures.MergePastedLine)) {\r\n                handleLineMerge(fragment);\r\n            }\r\n\r\n            // Replace unknown tags with SPAN\r\n            sanitizingOption.unknownTagReplacement = this.unknownTagReplacement;\r\n        }\r\n    }\r\n}\r\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\r\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\r\n\r\nconst LAST_TD_END_REGEX = /<\\/\\s*td\\s*>((?!<\\/\\s*tr\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_END_REGEX = /<\\/\\s*tr\\s*>((?!<\\/\\s*table\\s*>)[\\s\\S])*$/i;\r\nconst LAST_TR_REGEX = /<tr[^>]*>[^<]*/i;\r\nconst LAST_TABLE_REGEX = /<table[^>]*>[^<]*/i;\r\nconst DEFAULT_BORDER_STYLE = 'solid 1px #d4d4d4';\r\n\r\n/**\r\n * @internal\r\n * Convert pasted content from Excel, add borders when source doc doesn't have a border\r\n * @param doc HTML Document which contains the content from Excel\r\n */\r\nexport default function convertPastedContentFromExcel(event: BeforePasteEvent) {\r\n    const { fragment, sanitizingOption, htmlBefore, clipboardData } = event;\r\n    const html = excelHandler(clipboardData.html, htmlBefore);\r\n\r\n    if (clipboardData.html != html) {\r\n        const doc = new DOMParser().parseFromString(html, 'text/html');\r\n        while (fragment.firstChild) {\r\n            fragment.removeChild(fragment.firstChild);\r\n        }\r\n        while (doc?.body?.firstChild) {\r\n            fragment.appendChild(doc.body.firstChild);\r\n        }\r\n    }\r\n\r\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'TD', element => {\r\n        if (element.style.borderStyle == 'none') {\r\n            element.style.border = DEFAULT_BORDER_STYLE;\r\n        }\r\n        return true;\r\n    });\r\n}\r\n\r\n/**\r\n * @internal Export for test only\r\n * @param html Source html\r\n */\r\nexport function excelHandler(html: string, htmlBefore: string): string {\r\n    if (html.match(LAST_TD_END_REGEX)) {\r\n        const trMatch = htmlBefore.match(LAST_TR_REGEX);\r\n        const tr = trMatch ? trMatch[0] : '<TR>';\r\n        html = tr + html + '</TR>';\r\n    }\r\n    if (html.match(LAST_TR_END_REGEX)) {\r\n        let tableMatch = htmlBefore.match(LAST_TABLE_REGEX);\r\n        let table = tableMatch ? tableMatch[0] : '<TABLE>';\r\n        html = table + html + '</TABLE>';\r\n    }\r\n\r\n    return html;\r\n}\r\n","import { BeforePasteEvent } from 'roosterjs-editor-types';\r\nimport { chainSanitizerCallback } from 'roosterjs-editor-dom';\r\nimport { createWordConverter } from './wordConverter';\r\nimport { createWordConverterArguments } from './WordConverterArguments';\r\nimport { processNodeConvert, processNodesDiscovery } from './converterUtils';\r\n\r\n/**\r\n * @internal\r\n * Converts all the Word generated list items in the specified node into standard HTML UL and OL tags\r\n */\r\nexport default function convertPastedContentFromWord(event: BeforePasteEvent) {\r\n    const { sanitizingOption, fragment } = event;\r\n\r\n    // Preserve <o:p> when its innerHTML is \"&nbsp;\" to avoid dropping an empty line\r\n    chainSanitizerCallback(sanitizingOption.elementCallbacks, 'O:P', element => {\r\n        element.innerHTML = '&nbsp;';\r\n        return true;\r\n    });\r\n\r\n    let wordConverter = createWordConverter();\r\n\r\n    // First find all the nodes that we need to check for list item information\r\n    // This call will return all the p and header elements under the root node.. These are the elements that\r\n    // Word uses a list items, so we'll only process them and avoid walking the whole tree.\r\n    let elements = fragment.querySelectorAll('p');\r\n    if (elements.length > 0) {\r\n        wordConverter.wordConverterArgs = createWordConverterArguments(elements);\r\n        if (processNodesDiscovery(wordConverter)) {\r\n            processNodeConvert(wordConverter);\r\n        }\r\n    }\r\n}\r\n","import WordConverterArguments from './WordConverterArguments';\r\nimport WordCustomData, { createCustomData } from './WordCustomData';\r\n\r\n/**\r\n * @internal\r\n * Processes HTML generated by Word, converting Word Lists into standard HTML UL and OL tags\r\n */\r\nexport default interface WordConverter {\r\n    /** Next unique id to be assigned to a list */\r\n    nextUniqueId: number;\r\n\r\n    /** Number of bullets converted */\r\n    numBulletsConverted: number;\r\n\r\n    /** Number of numbering converted */\r\n    numNumberedConverted: number;\r\n\r\n    /** The structure that records the status of the conversion */\r\n    wordConverterArgs: WordConverterArguments;\r\n\r\n    /** Custom data storage for list items */\r\n    wordCustomData: WordCustomData;\r\n}\r\n\r\n/**\r\n * @internal\r\n * create an empty WordConverter\r\n */\r\nexport function createWordConverter(): WordConverter {\r\n    return {\r\n        nextUniqueId: 1,\r\n        numBulletsConverted: 0,\r\n        numNumberedConverted: 0,\r\n        wordConverterArgs: null,\r\n        wordCustomData: createCustomData(),\r\n    };\r\n}\r\n","import LevelLists, { createLevelLists } from './LevelLists';\r\nimport ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\n\r\n/**\r\n * @internal\r\n * Contains the state of the WordConverter when called back after yielding\r\n */\r\nexport default interface WordConverterArguments {\r\n    /** The list of element nodes being processed */\r\n    nodes: NodeListOf<HTMLElement>;\r\n\r\n    /** The index of the element currently being processed */\r\n    currentIndex: number;\r\n\r\n    /**\r\n     * Holds the metadata for all the lists we have found\r\n     * key: unique list id, value: list metadata\r\n     */\r\n    lists: { [key: string]: ListMetadata };\r\n\r\n    /**\r\n     * Stores the list item metatada of the items we\r\n     * have found that need to be converted\r\n     */\r\n    listItems: ListItemMetadata[];\r\n\r\n    /**\r\n     * This array holds the list id of the lists we are processing\r\n     * that are next to each other.. This list will be used to determine\r\n     * if list items are next to each other or if they are separated...\r\n     * Separated items are ignored from the conversion\r\n     */\r\n\r\n    currentListIdsByLevels: LevelLists[];\r\n\r\n    /** Remembers the item that was last processed  */\r\n    lastProcessedItem: HTMLElement;\r\n}\r\n\r\n/**\r\n * @internal\r\n * create an empty WordConverterArguments\r\n */\r\nexport function createWordConverterArguments(\r\n    nodes: NodeListOf<HTMLElement>\r\n): WordConverterArguments {\r\n    return {\r\n        nodes: nodes,\r\n        currentIndex: 0,\r\n        lists: {},\r\n        listItems: [],\r\n        currentListIdsByLevels: [createLevelLists()],\r\n        lastProcessedItem: null,\r\n    };\r\n}\r\n","import ListItemMetadata from './ListItemMetadata';\r\nimport ListMetadata from './ListMetadata';\r\nimport WordConverter from './wordConverter';\r\nimport WordConverterArguments from './WordConverterArguments';\r\nimport { createLevelLists } from './LevelLists';\r\nimport { getObject, setObject } from './WordCustomData';\r\nimport { getStyles, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { NodeType } from 'roosterjs-editor-types';\r\n\r\n/** Word list metadata style name */\r\nconst LOOKUP_DEPTH = 5;\r\n\r\n/** Name for the word list id property in the custom data */\r\nconst UNIQUE_LIST_ID_CUSTOM_DATA = 'UniqueListId';\r\n\r\n/** Word list metadata style name */\r\nconst MSO_LIST_STYLE_NAME = 'mso-list';\r\n\r\n/** Regular expression to match line breaks */\r\nconst LINE_BREAKS = /[\\n|\\r]/gi;\r\n\r\n/**\r\n * @internal\r\n * Handles the pass 1: Discovery\r\n * During discovery, we'll parse the metadata out of the elements and store it in the list items dictionary.\r\n * We'll detect cases where the list items for a particular ordered list are not next to each other. Word does these\r\n * for numbered headers, and we don't want to convert those, because the numbering would be completely wrong.\r\n */\r\nexport function processNodesDiscovery(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    while (args.currentIndex < args.nodes.length) {\r\n        let node = args.nodes.item(args.currentIndex);\r\n\r\n        // Try to get the list metadata for the specified node\r\n        let itemMetadata = getListItemMetadata(node);\r\n        if (itemMetadata) {\r\n            let levelInfo =\r\n                args.currentListIdsByLevels[itemMetadata.level - 1] || createLevelLists();\r\n            args.currentListIdsByLevels[itemMetadata.level - 1] = levelInfo;\r\n\r\n            // We need to drop some list information if this is not an item next to another\r\n            if (args.lastProcessedItem && getRealPreviousSibling(node) != args.lastProcessedItem) {\r\n                // This list item is not next to the previous one. This means that there is some content in between them\r\n                // so we need to reset our list of list ids per level\r\n                resetCurrentLists(args);\r\n            }\r\n\r\n            // Get the list metadata for the list that will hold this item\r\n            let listMetadata = levelInfo.listsMetadata[itemMetadata.wordListId];\r\n            if (!listMetadata) {\r\n                // Get the first item fake bullet.. This will be used later to check what is the right type of list\r\n                let firstFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n\r\n                // This is a the first item of a list.. We'll create the list metadata using the information\r\n                // we already have from this first item\r\n                listMetadata = {\r\n                    numberOfItems: 0,\r\n                    uniqueListId: wordConverter.nextUniqueId++,\r\n                    firstFakeBullet: firstFakeBullet,\r\n\r\n                    // If the bullet we got is emtpy or not found, we ignore the list out.. this means\r\n                    // that this is not an item we need to convert of that the format doesn't match what\r\n                    // we are expecting\r\n                    ignore: !firstFakeBullet || firstFakeBullet.length == 0,\r\n\r\n                    // We'll use the first fake bullet to try to figure out which type of list we create. If this list has a second\r\n                    // item, we'll perform a better comparasion, but for one item lists, this will be check that will determine the list type\r\n                    tagName: getFakeBulletTagName(firstFakeBullet),\r\n                };\r\n                levelInfo.listsMetadata[itemMetadata.wordListId] = listMetadata;\r\n                args.lists[listMetadata.uniqueListId.toString()] = listMetadata;\r\n            } else if (!listMetadata.ignore && listMetadata.numberOfItems == 1) {\r\n                // This is the second item we've seen for this list.. we'll compare the 2 fake bullet\r\n                // items we have an decide if we create ordered or unordered lists based on this.\r\n                // This is the best way we can do this since we cannot read the metadata that Word\r\n                // puts in the head of the HTML...\r\n                let secondFakeBullet = getFakeBulletText(node, LOOKUP_DEPTH);\r\n                listMetadata.tagName =\r\n                    listMetadata.firstFakeBullet == secondFakeBullet ? 'UL' : 'OL';\r\n            }\r\n\r\n            // Set the unique id to the list\r\n            itemMetadata.uniqueListId = listMetadata.uniqueListId;\r\n\r\n            // Check if we need to ignore this list... we'll either know already that we need to ignore\r\n            // it, or we'll know it because the previous list items are not next to this one\r\n            if (\r\n                listMetadata.ignore ||\r\n                (listMetadata.tagName == 'OL' &&\r\n                    listMetadata.numberOfItems > 0 &&\r\n                    levelInfo.currentUniqueListId != itemMetadata.uniqueListId)\r\n            ) {\r\n                // We need to ignore this item... and we also need to forget about the lists that\r\n                // are not at the root level\r\n                listMetadata.ignore = true;\r\n                args.currentListIdsByLevels[0].currentUniqueListId = -1;\r\n                args.currentListIdsByLevels = args.currentListIdsByLevels.slice(0, 1);\r\n            } else {\r\n                // This is an item we don't need to ignore... If added lists deep under this one before\r\n                // we'll drop their ids from the list of ids per level.. this is because this list item\r\n                // breaks the deeper lists.\r\n                if (args.currentListIdsByLevels.length > itemMetadata.level) {\r\n                    args.currentListIdsByLevels = args.currentListIdsByLevels.slice(\r\n                        0,\r\n                        itemMetadata.level\r\n                    );\r\n                }\r\n\r\n                levelInfo.currentUniqueListId = itemMetadata.uniqueListId;\r\n\r\n                // Add the list item into the list of items to be processed\r\n                args.listItems.push(itemMetadata);\r\n                listMetadata.numberOfItems++;\r\n            }\r\n\r\n            args.lastProcessedItem = node;\r\n        } else {\r\n            // Here, we know that this is not a list item, but we'll want to check if it is one \"no bullet\" list items...\r\n            // these can be created by creating a bullet and hitting delete on it it... The content will continue to be indented, but there will\r\n            // be no bullet and the list will continue correctly after that. Visually, it looks like the previous item has multiple lines, but\r\n            // the HTML generated has multiple paragraphs with the same class. We'll merge these when we find them, so the logic doesn't skips\r\n            // the list conversion thinking that the list items are not together...\r\n            let last = args.lastProcessedItem;\r\n            if (\r\n                last &&\r\n                getRealPreviousSibling(node) == last &&\r\n                node.tagName == last.tagName &&\r\n                node.className == last.className\r\n            ) {\r\n                // Add 2 line breaks and move all the nodes to the last item\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                last.appendChild(last.ownerDocument.createElement('br'));\r\n                while (node.firstChild != null) {\r\n                    last.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Remove the item that we don't need anymore\r\n                node.parentNode.removeChild(node);\r\n            }\r\n        }\r\n\r\n        // Move to the next element are return true if more elements need to be processed\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return args.listItems.length > 0;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Handles the pass 2: Conversion\r\n * During conversion, we'll go over the elements that belong to a list that we've marked as a list to convert, and we'll perform the\r\n * conversion needed\r\n */\r\nexport function processNodeConvert(wordConverter: WordConverter): boolean {\r\n    let args = wordConverter.wordConverterArgs;\r\n    args.currentIndex = 0;\r\n\r\n    while (args.currentIndex < args.listItems.length) {\r\n        let metadata = args.listItems[args.currentIndex];\r\n        let node = metadata.originalNode;\r\n        let listMetadata = args.lists[metadata.uniqueListId.toString()];\r\n        if (!listMetadata.ignore) {\r\n            // We have a list item that we need to convert, get or create the list\r\n            // that hold this item out\r\n            let list = getOrCreateListForNode(wordConverter, node, metadata, listMetadata);\r\n            if (list) {\r\n                // Clean the element out.. this call gets rid of the fake bullet and unneeded nodes\r\n                cleanupListIgnore(node, LOOKUP_DEPTH);\r\n\r\n                // Create a new list item and transfer the children\r\n                let li = node.ownerDocument.createElement('LI');\r\n                while (node.firstChild) {\r\n                    li.appendChild(node.firstChild);\r\n                }\r\n\r\n                // Append the list item into the list\r\n                list.appendChild(li);\r\n\r\n                // Remove the node we just converted\r\n                node.parentNode.removeChild(node);\r\n\r\n                if (listMetadata.tagName == 'UL') {\r\n                    wordConverter.numBulletsConverted++;\r\n                } else {\r\n                    wordConverter.numNumberedConverted++;\r\n                }\r\n            }\r\n        }\r\n\r\n        args.currentIndex++;\r\n    }\r\n\r\n    return wordConverter.numBulletsConverted > 0 || wordConverter.numNumberedConverted > 0;\r\n}\r\n\r\n/**\r\n * Gets or creates the list (UL or OL) that holds this item out based on the\r\n * items content and the specified metadata\r\n */\r\nfunction getOrCreateListForNode(\r\n    wordConverter: WordConverter,\r\n    node: HTMLElement,\r\n    metadata: ListItemMetadata,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // First get the last list next to this node under the specified level. This code\r\n    // path will return the list or will create lists if needed\r\n    let list = recurringGetOrCreateListAtNode(node, metadata.level, listMetadata);\r\n\r\n    // Here use the unique list ID to detect if we have the right list...\r\n    // it is possible to have 2 different lists next to each other with different formats, so\r\n    // we want to detect this an create separate lists for those cases\r\n    let listId = getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA);\r\n\r\n    // If we have a list with and ID, but the ID is different than the ID for this list item, this\r\n    // is a completely new list, so we'll append a new list for that\r\n    if ((listId && listId != metadata.uniqueListId) || (!listId && list.firstChild)) {\r\n        let newList = node.ownerDocument.createElement(listMetadata.tagName);\r\n        list.parentNode.insertBefore(newList, list.nextSibling);\r\n        list = newList;\r\n    }\r\n\r\n    // Set the list id into the custom data\r\n    setObject(\r\n        wordConverter.wordCustomData,\r\n        list,\r\n        UNIQUE_LIST_ID_CUSTOM_DATA,\r\n        metadata.uniqueListId\r\n    );\r\n\r\n    // This call will convert the list if needed to the right type of list required. This can happen\r\n    // on the cases where the first list item for this list is located after a deeper list. for that\r\n    // case, we will have created a UL for it, and we may need to convert it\r\n    return convertListIfNeeded(wordConverter, list, listMetadata);\r\n}\r\n\r\n/**\r\n * Converts the list between UL and OL if needed, by using the fake bullet and\r\n * information already stored in the list itself\r\n */\r\nfunction convertListIfNeeded(\r\n    wordConverter: WordConverter,\r\n    list: Node,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    // Check if we need to convert the list out\r\n    if (listMetadata.tagName != getTagOfNode(list)) {\r\n        // We have the wrong list type.. convert it, set the id again and tranfer all the childs\r\n        let newList = list.ownerDocument.createElement(listMetadata.tagName);\r\n        setObject(\r\n            wordConverter.wordCustomData,\r\n            newList,\r\n            UNIQUE_LIST_ID_CUSTOM_DATA,\r\n            getObject(wordConverter.wordCustomData, list, UNIQUE_LIST_ID_CUSTOM_DATA)\r\n        );\r\n        while (list.firstChild) {\r\n            newList.appendChild(list.firstChild);\r\n        }\r\n        list.parentNode.insertBefore(newList, list);\r\n        list.parentNode.removeChild(list);\r\n        list = newList;\r\n    }\r\n\r\n    return list;\r\n}\r\n\r\n/**\r\n * Gets or creates the specified list\r\n */\r\nfunction recurringGetOrCreateListAtNode(\r\n    node: HTMLElement,\r\n    level: number,\r\n    listMetadata: ListMetadata\r\n): Node {\r\n    let parent: Node = null;\r\n    let possibleList: Node;\r\n    if (level == 1) {\r\n        // Root case, we'll check if the list is the previous sibling of the node\r\n        possibleList = getRealPreviousSibling(node);\r\n    } else {\r\n        // If we get here, we are looking for level 2 or deeper... get the upper list\r\n        // and check if the last element is a list\r\n        parent = recurringGetOrCreateListAtNode(node, level - 1, null);\r\n        possibleList = parent.lastChild;\r\n    }\r\n\r\n    // Check the element that we got and verify that it is a list\r\n    if (possibleList && possibleList.nodeType == NodeType.Element) {\r\n        let tag = getTagOfNode(possibleList);\r\n        if (tag == 'UL' || tag == 'OL') {\r\n            // We have a list.. use it\r\n            return possibleList;\r\n        }\r\n    }\r\n\r\n    // If we get here, it means we don't have a list and we need to create one\r\n    // this code path will always create new lists as UL lists\r\n    let newList = node.ownerDocument.createElement(listMetadata ? listMetadata.tagName : 'UL');\r\n    if (level == 1) {\r\n        // For level 1, we'll insert the list beofre the node\r\n        node.parentNode.insertBefore(newList, node);\r\n    } else {\r\n        // Any level 2 or above, we insert the list as the last\r\n        // child of the upper level list\r\n        parent.appendChild(newList);\r\n    }\r\n\r\n    return newList;\r\n}\r\n\r\n/**\r\n * Cleans up the node children by removing the childs marked as mso-list: Ignore.\r\n * This nodes hold the fake bullet information that Word puts in and when\r\n * conversion is happening, we want to get rid of these elements\r\n */\r\nfunction cleanupListIgnore(node: Node, levels: number) {\r\n    let nodesToRemove: Node[] = [];\r\n\r\n    for (let child: Node = node.firstChild; child; child = child.nextSibling) {\r\n        // Clean up the item internally first if we need to based on the number of levels\r\n        if (child.nodeType == NodeType.Element && levels > 1) {\r\n            cleanupListIgnore(child, levels - 1);\r\n        }\r\n\r\n        // Try to convert word comments into ignore elements if we haven't done so for this element\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if we can remove this item out\r\n        if (isEmptySpan(child) || isIgnoreNode(child)) {\r\n            nodesToRemove.push(child);\r\n        }\r\n    }\r\n\r\n    nodesToRemove.forEach(child => node.removeChild(child));\r\n}\r\n\r\n/**\r\n * Reads the word list metadada out of the specified node. If the node\r\n * is not a Word list item, it returns null.\r\n */\r\nfunction getListItemMetadata(node: HTMLElement): ListItemMetadata {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0) {\r\n            try {\r\n                // Word mso-list property holds 3 space separated values in the following format: lst1 level1 lfo0\r\n                // Where:\r\n                // (0) List identified for the metadata in the &lt;head&gt; of the document. We cannot read the &lt;head&gt; metada\r\n                // (1) Level of the list. This also maps to the &lt;head&gt; metadata that we cannot read, but\r\n                // for almost all cases, it maps to the list identation (or level). We'll use it as the\r\n                // list indentation value\r\n                // (2) Contains a specific list identifier.\r\n                // Example value: \"l0 level1 lfo1\"\r\n                let listprops = listatt.split(' ');\r\n                if (listprops.length == 3) {\r\n                    return <ListItemMetadata>{\r\n                        level: parseInt(listprops[1].substr('level'.length)),\r\n                        wordListId: listatt,\r\n                        originalNode: node,\r\n                        uniqueListId: 0,\r\n                    };\r\n                }\r\n            } catch (e) {}\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isFakeBullet(fakeBullet: string): boolean {\r\n    return ['o', '·', '§', '-'].indexOf(fakeBullet) >= 0;\r\n}\r\n\r\n/** Given a fake bullet text, returns the type of list that should be used for it */\r\nfunction getFakeBulletTagName(fakeBullet: string): string {\r\n    return isFakeBullet(fakeBullet) ? 'UL' : 'OL';\r\n}\r\n\r\n/**\r\n * Finds the fake bullet text out of the specified node and returns it. For images, it will return\r\n * a bullet string. If not found, it returns null...\r\n */\r\nfunction getFakeBulletText(node: Node, levels: number): string {\r\n    // Word uses the following format for their bullets:\r\n    // &lt;p style=\"mso-list:l1 level1 lfo2\"&gt;\r\n    // &lt;span style=\"...\"&gt;\r\n    // &lt;span style=\"mso-list:Ignore\"&gt;1.&lt;span style=\"...\"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;&lt;/span&gt;\r\n    // &lt;/span&gt;\r\n    // Content here...\r\n    // &lt;/p&gt;\r\n    //\r\n    // Basically, we need to locate the mso-list:Ignore SPAN, which holds either one text or image node. That\r\n    // text or image node will be the fake bullet we are looking for\r\n    let result: string = null;\r\n    let child: Node = node.firstChild;\r\n    while (!result && child) {\r\n        // First, check if we need to convert the Word list comments into real elements\r\n        child = fixWordListComments(child, true /*removeComments*/);\r\n\r\n        // Check if this is the node that holds the fake bullets (mso-list: Ignore)\r\n        if (isIgnoreNode(child)) {\r\n            // Yes... this is the node that holds either the text or image data\r\n            result = child.textContent.trim();\r\n\r\n            // This is the case for image case\r\n            if (result.length == 0) {\r\n                result = 'o';\r\n            }\r\n        } else if (child.nodeType == NodeType.Element && levels > 1) {\r\n            // If this is an element and we are not in the last level, try to get the fake bullet\r\n            // out of the child\r\n            result = getFakeBulletText(child, levels - 1);\r\n        }\r\n\r\n        child = child.nextSibling;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * If the specified element is a Word List comments, this code verifies and fixes\r\n * the markup when needed to ensure that Chrome bullet conversions work as expected\r\n * -----\r\n * We'll convert &lt;!--[if !supportLists]--&gt; and &lt;!--[endif]--&gt; comments into\r\n * &lt;span style=\"mso-list:Ignore\"&gt;&lt;/span&gt;... Chrome has a bug where it drops the\r\n * styles of the span, but we'll use these comments to recreate them out\r\n */\r\nfunction fixWordListComments(child: Node, removeComments: boolean): Node {\r\n    if (child.nodeType == NodeType.Comment) {\r\n        let value = (child as Comment).data;\r\n        if (value && value.trim().toLowerCase() == '[if !supportlists]') {\r\n            // We have a list ignore start, find the end.. We know is not more than\r\n            // 3 nodes away, so we'll optimize our checks\r\n            let nextElement = child;\r\n            let endComment: Node = null;\r\n            for (let j = 0; j < 4; j++) {\r\n                nextElement = getRealNextSibling(nextElement);\r\n                if (!nextElement) {\r\n                    break;\r\n                }\r\n                if (nextElement.nodeType == NodeType.Comment) {\r\n                    value = (nextElement as Comment).data;\r\n                    if (value && value.trim().toLowerCase() == '[endif]') {\r\n                        endComment = nextElement;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if we found the end node, wrap everything out\r\n            if (endComment) {\r\n                let newSpan = child.ownerDocument.createElement('span');\r\n                newSpan.setAttribute('style', 'mso-list: ignore');\r\n                nextElement = getRealNextSibling(child);\r\n                while (nextElement != endComment) {\r\n                    nextElement = nextElement.nextSibling as HTMLElement;\r\n                    newSpan.appendChild(nextElement.previousSibling);\r\n                }\r\n\r\n                // Insert the element out and use that one as the current child\r\n                endComment.parentNode.insertBefore(newSpan, endComment);\r\n\r\n                // Remove the comments out if the call specified it out\r\n                if (removeComments) {\r\n                    child.parentNode.removeChild(child);\r\n                    endComment.parentNode.removeChild(endComment);\r\n                }\r\n\r\n                // Last, make sure we return the new element out instead of the comment\r\n                child = newSpan;\r\n            }\r\n        }\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/** Finds the real previous sibling, ignoring emtpy text nodes */\r\nfunction getRealPreviousSibling(node: Node): Node {\r\n    let prevSibling = node;\r\n    do {\r\n        prevSibling = prevSibling.previousSibling;\r\n    } while (prevSibling && isEmptyTextNode(prevSibling));\r\n    return prevSibling;\r\n}\r\n\r\n/** Finds the real next sibling, ignoring empty text nodes */\r\nfunction getRealNextSibling(node: Node): Node {\r\n    let nextSibling = node;\r\n    do {\r\n        nextSibling = nextSibling.nextSibling;\r\n    } while (nextSibling && isEmptyTextNode(nextSibling));\r\n\r\n    return nextSibling;\r\n}\r\n\r\n/**\r\n * Checks if the specified node is marked as a mso-list: Ignore. These\r\n * nodes need to be ignored when a list item is converted into standard\r\n * HTML lists\r\n */\r\nfunction isIgnoreNode(node: Node): boolean {\r\n    if (node.nodeType == NodeType.Element) {\r\n        let listatt = getStyleValue(node as HTMLElement, MSO_LIST_STYLE_NAME);\r\n        if (listatt && listatt.length > 0 && listatt.trim().toLowerCase() == 'ignore') {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Checks if the specified node is an empty span. */\r\nfunction isEmptySpan(node: Node): boolean {\r\n    return getTagOfNode(node) == 'SPAN' && !node.firstChild;\r\n}\r\n\r\n/** Reads the specified style value from the node */\r\nfunction getStyleValue(node: HTMLElement, styleName: string): string {\r\n    // Word uses non-standard names for the metadata that puts in the style of the element...\r\n    // Most browsers will not provide the information for those unstandard values throug the node.style\r\n    // property, so the only reliable way to read them is to get the attribute directly and do\r\n    // the required parsing..\r\n    return getStyles(node)[styleName] || null;\r\n}\r\n\r\n/** Checks if the node is an empty text node that can be ignored */\r\nfunction isEmptyTextNode(node: Node): boolean {\r\n    // No node is empty\r\n    if (!node) {\r\n        return true;\r\n    }\r\n\r\n    // Empty text node is empty\r\n    if (node.nodeType == NodeType.Text) {\r\n        let value = node.nodeValue;\r\n        value = value.replace(LINE_BREAKS, '');\r\n        return value.trim().length == 0;\r\n    }\r\n\r\n    // Span or Font with an empty child node is empty\r\n    let tagName = getTagOfNode(node);\r\n    if (node.firstChild == node.lastChild && (tagName == 'SPAN' || tagName == 'FONT')) {\r\n        return isEmptyTextNode(node.firstChild);\r\n    }\r\n\r\n    // If not found, then this is not empty\r\n    return false;\r\n}\r\n\r\n/** Resets the list */\r\nfunction resetCurrentLists(args: WordConverterArguments) {\r\n    for (let i = 0; i < args.currentListIdsByLevels.length; i++) {\r\n        let ll = args.currentListIdsByLevels[i];\r\n        if (ll) {\r\n            ll.currentUniqueListId = -1;\r\n        }\r\n    }\r\n}\r\n","import {\r\n    changeElementTag,\r\n    ContentTraverser,\r\n    getBlockElementAtNode,\r\n    getNextLeafSibling,\r\n    getPreviousLeafSibling,\r\n    getTagOfNode,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * Process pasted content, if there are multiple blocks that are not wrapped by a shared ancestor node,\r\n * change the tag of first and last node to be SPAN so that it will be merged into current block\r\n * @param root Root node of content to process\r\n */\r\nexport default function handleLineMerge(root: Node) {\r\n    const traverser = ContentTraverser.createBodyTraverser(root);\r\n    const blocks: { start: Node; end: Node }[] = [];\r\n\r\n    for (\r\n        let block = traverser?.currentBlockElement;\r\n        block;\r\n        block = traverser.getNextBlockElement()\r\n    ) {\r\n        blocks.push({\r\n            start: block.getStartNode(),\r\n            end: block.getEndNode(),\r\n        });\r\n    }\r\n\r\n    if (blocks.length > 0) {\r\n        processBlock(blocks[0]);\r\n        processBlock(blocks[blocks.length - 1]);\r\n        checkAndAddBr(root, blocks[0], true /*isFirst*/);\r\n        checkAndAddBr(root, blocks[blocks.length - 1], false /*isFirst*/);\r\n    }\r\n}\r\n\r\nfunction processBlock(block: { start: Node; end: Node }) {\r\n    const { start, end } = block;\r\n\r\n    if (start == end && getTagOfNode(start) == 'DIV') {\r\n        const node = changeElementTag(start as HTMLElement, 'SPAN');\r\n        block.start = node;\r\n        block.end = node;\r\n\r\n        if (getTagOfNode(node.lastChild) == 'BR') {\r\n            node.removeChild(node.lastChild);\r\n        }\r\n    } else if (getTagOfNode(end) == 'BR') {\r\n        const node = end.ownerDocument.createTextNode('');\r\n        end.parentNode?.insertBefore(node, end);\r\n        block.end = node;\r\n        end.parentNode?.removeChild(end);\r\n    }\r\n}\r\n\r\nfunction checkAndAddBr(root: Node, block: { start: Node; end: Node }, isFirst: boolean) {\r\n    const blockElement = getBlockElementAtNode(root, block.start);\r\n    const sibling = isFirst\r\n        ? getNextLeafSibling(root, block.end)\r\n        : getPreviousLeafSibling(root, block.start);\r\n\r\n    if (blockElement?.contains(sibling)) {\r\n        (isFirst ? block.end : block.start).parentNode?.insertBefore(\r\n            block.start.ownerDocument.createElement('br'),\r\n            isFirst ? block.end.nextSibling : block.start\r\n        );\r\n    }\r\n}\r\n","import ListItemBlock, { createListItemBlock } from './ListItemBlock';\r\nimport {\r\n    WORD_ORDERED_LIST_SELECTOR,\r\n    WORD_UNORDERED_LIST_SELECTOR,\r\n    WORD_ONLINE_IDENTIFYING_SELECTOR,\r\n    LIST_CONTAINER_ELEMENT_CLASS_NAME,\r\n    ORDERED_LIST_TAG_NAME,\r\n    UNORDERED_LIST_TAG_NAME,\r\n} from './constants';\r\n\r\nimport {\r\n    splitParentNode,\r\n    getNextLeafSibling,\r\n    getFirstLeafNode,\r\n    getTagOfNode,\r\n    collapseNodes,\r\n    unwrap,\r\n    toArray,\r\n} from 'roosterjs-editor-dom';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isWordOnlineWithList(fragment: DocumentFragment): boolean {\r\n    return !!(fragment && fragment.querySelector(WORD_ONLINE_IDENTIFYING_SELECTOR));\r\n}\r\n\r\n// Word Online pasted content DOM structure as of July 12th 2019\r\n//<html>\r\n//  <body>\r\n//      <div class='OutlineGroup'>  ----------> this layer may exist depend on the content user paste\r\n//          <div class=\"OutlineElement\">  ----------> text content\r\n//              <p></p>\r\n//          </div>\r\n//          <div class=\"ListItemWrapper\">  ----------> list items: for unordered list, all the items on the same level is under the same wrapper\r\n//              <ul>                                       list items in the same list can be divided into different ListItemWrapper\r\n//                  <li></li>                              list items in the same list can also be divided into different Outline Group;\r\n//                  <li></li>\r\n//              </ul>\r\n//          </div>\r\n//      </div>\r\n//      <div class='OutlineGroup'>\r\n//          <div class=\"ListItemWrapper\">  ----------> list items: for ordered list, each items has it's own wrapper\r\n//              <ol>\r\n//                  <li></li>\r\n//              </ol>\r\n//          </div>\r\n//          <div class=\"ListItemWrapper\">\r\n//              <ol>\r\n//                  <li></li>\r\n//              </ol>\r\n//          </div>\r\n//      </div>\r\n//  </body>\r\n//</html>\r\n//\r\n\r\n/**\r\n * @internal\r\n * Convert text copied from word online into text that's workable with rooster editor\r\n * @param fragment Document fragment that is being pasted into editor.\r\n */\r\nexport default function convertPastedContentFromWordOnline(fragment: DocumentFragment) {\r\n    sanitizeListItemContainer(fragment);\r\n    const listItemBlocks: ListItemBlock[] = getListItemBlocks(fragment);\r\n\r\n    listItemBlocks.forEach(itemBlock => {\r\n        // There are cases where consecutive List Elements are seperated into different divs:\r\n        // <div>\r\n        //   <div>\r\n        //      <ol></ol>\r\n        //   </div>\r\n        //   <div>\r\n        //      <ol></ol>\r\n        //   </div>\r\n        // </div>\r\n        // <div>\r\n        //   <div>\r\n        //      <ol></ol>\r\n        //   </div>\r\n        // </div>\r\n        // in the above case we want to collapse the two root level div into one and unwrap the list item divs.\r\n        // after the following flattening the list will become following:\r\n        //\r\n        // <div>\r\n        //    <ol></ol>\r\n        // </div>\r\n        // <div>\r\n        //    <ol></ol>\r\n        // </div>\r\n        // <div>\r\n        //    <ol></ol>\r\n        // </div>\r\n        // Then we are start processing.\r\n        flattenListBlock(fragment, itemBlock);\r\n\r\n        // Find the node to insertBefore, which is next sibling node of the end of a listItemBlock.\r\n        itemBlock.insertPositionNode = itemBlock.endElement.nextSibling;\r\n\r\n        let convertedListElement: Element;\r\n        const doc = fragment.ownerDocument;\r\n\r\n        itemBlock.listItemContainers.forEach(listItemContainer => {\r\n            let listType: 'OL' | 'UL' = getContainerListType(listItemContainer); // list type that is contained by iterator.\r\n            // Initialize processed element with propery listType if this is the first element\r\n            if (!convertedListElement) {\r\n                convertedListElement = doc.createElement(listType);\r\n            }\r\n\r\n            // Get all list items(<li>) in the current iterator element.\r\n            const currentListItems = toArray(listItemContainer.querySelectorAll('li'));\r\n            currentListItems.forEach(item => {\r\n                // If item is in root level and the type of list changes then\r\n                // insert the current list into body and then reinitialize the convertedListElement\r\n                // Word Online is using data-aria-level to determine the the depth of the list item.\r\n                const itemLevel = parseInt(item.getAttribute('data-aria-level'));\r\n                // In first level list, there are cases where a consecutive list item divs may have different list type\r\n                // When that happens we need to insert the processed elements into the document, then change the list type\r\n                // and keep the processing going.\r\n                if (getTagOfNode(convertedListElement) != listType && itemLevel == 1) {\r\n                    insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\r\n                    convertedListElement = doc.createElement(listType);\r\n                }\r\n                insertListItem(convertedListElement, item, listType, doc);\r\n            });\r\n        });\r\n\r\n        insertConvertedListToDoc(convertedListElement, fragment, itemBlock);\r\n\r\n        // Once we finish the process the list items and put them into a list.\r\n        // After inserting the processed element,\r\n        // we need to remove all the non processed node from the parent node.\r\n        const parentContainer = itemBlock.startElement.parentNode;\r\n        if (parentContainer) {\r\n            itemBlock.listItemContainers.forEach(listItemContainer => {\r\n                parentContainer.removeChild(listItemContainer);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * The node processing is based on the premise of only ol/ul is in ListContainerWrapper class\r\n * However the html might be melformed, this function is to split all the other elements out of ListContainerWrapper\r\n * @param fragment pasted document that contains all the list element.\r\n */\r\nfunction sanitizeListItemContainer(fragment: DocumentFragment) {\r\n    const listItemContainerListEl = toArray(\r\n        fragment.querySelectorAll(`${WORD_ORDERED_LIST_SELECTOR}, ${WORD_UNORDERED_LIST_SELECTOR}`)\r\n    );\r\n    listItemContainerListEl.forEach(el => {\r\n        const replaceRegex = new RegExp(`\\\\b${LIST_CONTAINER_ELEMENT_CLASS_NAME}\\\\b`, 'g');\r\n        if (el.previousSibling) {\r\n            const prevParent = splitParentNode(el, true) as HTMLElement;\r\n            prevParent.className = prevParent.className.replace(replaceRegex, '');\r\n        }\r\n        if (el.nextSibling) {\r\n            const nextParent = splitParentNode(el, false) as HTMLElement;\r\n            nextParent.className = nextParent.className.replace(replaceRegex, '');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Take all the list items in the document, and group the consecutive list times in a list block;\r\n * @param fragment pasted document that contains all the list element.\r\n */\r\nfunction getListItemBlocks(fragment: DocumentFragment): ListItemBlock[] {\r\n    const listElements = fragment.querySelectorAll('.' + LIST_CONTAINER_ELEMENT_CLASS_NAME);\r\n    const result: ListItemBlock[] = [];\r\n    let curListItemBlock: ListItemBlock;\r\n    for (let i = 0; i < listElements.length; i++) {\r\n        let curItem = listElements[i];\r\n        if (!curListItemBlock) {\r\n            curListItemBlock = createListItemBlock(curItem);\r\n        } else {\r\n            const { listItemContainers } = curListItemBlock;\r\n            const lastItemInCurBlock = listItemContainers[listItemContainers.length - 1];\r\n            if (\r\n                curItem == lastItemInCurBlock.nextSibling ||\r\n                getFirstLeafNode(curItem) ==\r\n                    getNextLeafSibling(lastItemInCurBlock.parentNode, lastItemInCurBlock)\r\n            ) {\r\n                listItemContainers.push(curItem);\r\n                curListItemBlock.endElement = curItem;\r\n            } else {\r\n                curListItemBlock.endElement = lastItemInCurBlock;\r\n                result.push(curListItemBlock);\r\n                curListItemBlock = createListItemBlock(curItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (curListItemBlock?.listItemContainers.length > 0) {\r\n        result.push(curListItemBlock);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Flatten the list items, so that all the consecutive list items are under the same parent.\r\n * @param fragment Root element of that contains the element.\r\n * @param listItemBlock The list item block needed to be flattened.\r\n */\r\nfunction flattenListBlock(fragment: DocumentFragment, listItemBlock: ListItemBlock) {\r\n    const collapsedListItemSections = collapseNodes(\r\n        fragment,\r\n        listItemBlock.startElement,\r\n        listItemBlock.endElement,\r\n        true\r\n    );\r\n    collapsedListItemSections.forEach(section => {\r\n        if (getTagOfNode(section.firstChild) == 'DIV') {\r\n            unwrap(section);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get the list type that the container contains. If there is no list in the container\r\n * return null;\r\n * @param listItemContainer Container that contains a list\r\n */\r\nfunction getContainerListType(listItemContainer: Element): 'OL' | 'UL' | null {\r\n    const tag = getTagOfNode(listItemContainer.firstChild);\r\n    return tag == UNORDERED_LIST_TAG_NAME || tag == ORDERED_LIST_TAG_NAME ? tag : null;\r\n}\r\n\r\n/**\r\n * Insert list item into the correct position of a list\r\n * @param listRootElement Root element of the list that is accepting a coming element.\r\n * @param itemToInsert List item that needed to be inserted.\r\n * @param listType Type of list(ul/ol)\r\n */\r\nfunction insertListItem(\r\n    listRootElement: Element,\r\n    itemToInsert: HTMLElement,\r\n    listType: string,\r\n    doc: HTMLDocument\r\n): void {\r\n    if (!listType) {\r\n        return;\r\n    }\r\n    // Get item level from 'data-aria-level' attribute\r\n    let itemLevel = parseInt(itemToInsert.getAttribute('data-aria-level'));\r\n    let curListLevel = listRootElement; // Level iterator to find the correct place for the current element.\r\n    // if the itemLevel is 1 it means the level iterator is at the correct place.\r\n    while (itemLevel > 1) {\r\n        if (!curListLevel.firstChild) {\r\n            // If the current level is empty, create empty list within the current level\r\n            // then move the level iterator into the next level.\r\n            curListLevel.appendChild(doc.createElement(listType));\r\n            curListLevel = curListLevel.firstElementChild;\r\n        } else {\r\n            // If the current level is not empty, the last item in the needs to be a UL or OL\r\n            // and the level iterator should move to the UL/OL at the last position.\r\n            let lastChild = curListLevel.lastElementChild;\r\n            let lastChildTag = getTagOfNode(lastChild);\r\n            if (lastChildTag == UNORDERED_LIST_TAG_NAME || lastChildTag == ORDERED_LIST_TAG_NAME) {\r\n                // If the last child is a list(UL/OL), then move the level iterator to last child.\r\n                curListLevel = lastChild;\r\n            } else {\r\n                // If the last child is not a list, then append a new list to the level\r\n                // and move the level iterator to the new level.\r\n                curListLevel.appendChild(doc.createElement(listType));\r\n                curListLevel = curListLevel.lastElementChild;\r\n            }\r\n        }\r\n        itemLevel--;\r\n    }\r\n\r\n    // Once the level iterator is at the right place, then append the list item in the level.\r\n    curListLevel.appendChild(itemToInsert);\r\n}\r\n\r\n/**\r\n * Insert the converted list item into the correct place.\r\n * @param convertedListElement List element that is converted from list item block\r\n * @param fragment Root element of that contains the converted listItemBlock\r\n * @param listItemBlock List item block that was converted.\r\n */\r\nfunction insertConvertedListToDoc(\r\n    convertedListElement: Element,\r\n    fragment: DocumentFragment,\r\n    listItemBlock: ListItemBlock\r\n) {\r\n    if (!convertedListElement) {\r\n        return;\r\n    }\r\n\r\n    const { insertPositionNode } = listItemBlock;\r\n    if (insertPositionNode) {\r\n        const parentNode = insertPositionNode.parentNode;\r\n        if (parentNode) {\r\n            parentNode.insertBefore(convertedListElement, insertPositionNode);\r\n        }\r\n    } else {\r\n        const parentNode = listItemBlock.startElement.parentNode;\r\n        if (parentNode) {\r\n            parentNode.appendChild(convertedListElement);\r\n        } else {\r\n            fragment.appendChild(convertedListElement);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @internal\r\n * Type that holds all the info of a consecutive list item block.\r\n */\r\nexport default interface ListItemBlock {\r\n    /**\r\n     * The first element in block of list item from pasted word online document.\r\n     */\r\n    startElement: Element;\r\n\r\n    /**\r\n     * The last element in block of list item from pasted word online document.\r\n     */\r\n    endElement: Element;\r\n\r\n    /**\r\n     * The position where the processed bulleted list should be inserted.\r\n     */\r\n    insertPositionNode: Node;\r\n\r\n    /**\r\n     * The list of containers that wraps each list item.\r\n     */\r\n    listItemContainers: Element[];\r\n}\r\n\r\n/**\r\n * @internal\r\n * Initialize an empty ListItemBlock\r\n */\r\nexport function createListItemBlock(listItem: Element = null): ListItemBlock {\r\n    return {\r\n        startElement: listItem,\r\n        endElement: listItem,\r\n        insertPositionNode: null,\r\n        listItemContainers: listItem ? [listItem] : [],\r\n    };\r\n}\r\n","export * from './ContentEdit';\r\nexport * from './ContextMenu';\r\nexport * from './CustomReplace';\r\nexport * from './CutPasteListChain';\r\nexport * from './HyperLink';\r\nexport * from './ImageResize';\r\nexport * from './Paste';\r\nexport * from './Picker';\r\nexport * from './TableResize';\r\nexport * from './Watermark';\r\n","export * from './plugins/ContextMenu/index';\r\n","export { default as ContextMenu, ContextMenuOptions } from './ContextMenu';\r\n","import { fromHtml } from 'roosterjs-editor-dom';\r\nimport {\r\n    ContentPosition,\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst CONTAINER_HTML = '<div style=\"position: fixed; width: 0; height: 0\"></div>';\r\n\r\nexport interface ContextMenuOptions<T> {\r\n    render: (container: HTMLElement, items: (T | null)[], onDismiss: () => void) => void;\r\n\r\n    dismiss?: (container: HTMLElement) => void;\r\n\r\n    allowDefaultMenu?: boolean;\r\n}\r\n\r\n/**\r\n * An editor plugin that support showing a context menu using render() function from options parameter\r\n */\r\nexport default class ContextMenu<T> implements EditorPlugin {\r\n    private container: HTMLElement;\r\n    private editor: IEditor;\r\n    private isMenuShowing: boolean;\r\n\r\n    /**\r\n     * Create a new instance of ContextMenu class\r\n     * @param options An options object to determine how to show/hide the context menu\r\n     */\r\n    constructor(private options: ContextMenuOptions<T>) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ContextMenu';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.onDismiss();\r\n\r\n        if (this.container) {\r\n            this.container.parentNode.removeChild(this.container);\r\n            this.container = null;\r\n        }\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (event.eventType == PluginEventType.ContextMenu && event.items.length > 0) {\r\n            const { rawEvent, items } = event;\r\n\r\n            this.onDismiss();\r\n\r\n            if (!this.options.allowDefaultMenu) {\r\n                rawEvent.preventDefault();\r\n            }\r\n\r\n            this.initContainer(rawEvent.pageX, rawEvent.pageY);\r\n            this.options.render(this.container, items as T[], this.onDismiss);\r\n            this.isMenuShowing = true;\r\n        }\r\n    }\r\n\r\n    private initContainer(x: number, y: number) {\r\n        if (!this.container) {\r\n            this.container = fromHtml(CONTAINER_HTML, this.editor.getDocument())[0] as HTMLElement;\r\n            this.editor.insertNode(this.container, {\r\n                position: ContentPosition.Outside,\r\n            });\r\n        }\r\n        this.container.style.left = x + 'px';\r\n        this.container.style.top = y + 'px';\r\n    }\r\n\r\n    private onDismiss = () => {\r\n        if (this.container && this.isMenuShowing) {\r\n            this.options.dismiss?.(this.container);\r\n            this.isMenuShowing = false;\r\n        }\r\n    };\r\n}\r\n","export * from './plugins/CustomReplace/index';\r\n","export { default as CustomReplace } from './CustomReplace';\r\n","import {\r\n    CustomReplacement,\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst makeReplacement = (\r\n    sourceString: string,\r\n    replacementHTML: string,\r\n    matchSourceCaseSensitive: boolean\r\n): CustomReplacement => ({ sourceString, replacementHTML, matchSourceCaseSensitive });\r\n\r\nconst defaultReplacements: CustomReplacement[] = [\r\n    makeReplacement(':)', '🙂', true),\r\n    makeReplacement(';)', '😉', true),\r\n    makeReplacement(':O', '😲', true),\r\n    makeReplacement(':o', '😯', true),\r\n    makeReplacement('<3', '❤️', true),\r\n];\r\n\r\n/**\r\n * Wrapper for CustomReplaceContentEditFeature that provides an API for updating the\r\n * content edit feature\r\n */\r\nexport default class CustomReplacePlugin implements EditorPlugin {\r\n    private longestReplacementLength: number;\r\n    private editor: IEditor;\r\n    private replacements: CustomReplacement[];\r\n    private replacementEndCharacters: Set<string>;\r\n\r\n    /**\r\n     * Create instance of CustomReplace plugin\r\n     * @param replacements Replacement rules. If not passed, a default replacement rule set will be applied\r\n     */\r\n    constructor(replacements: CustomReplacement[] = defaultReplacements) {\r\n        this.updateReplacements(replacements);\r\n    }\r\n\r\n    /**\r\n     * Set the replacements that this plugin is looking for.\r\n     * @param newReplacements new set of replacements for this plugin\r\n     */\r\n    updateReplacements(newReplacements: CustomReplacement[]) {\r\n        this.replacements = newReplacements;\r\n        this.longestReplacementLength = getLongestReplacementSourceLength(this.replacements);\r\n        this.replacementEndCharacters = getReplacementEndCharacters(this.replacements);\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of this plugin\r\n     */\r\n    getName() {\r\n        return 'CustomReplace';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    public initialize(editor: IEditor): void {\r\n        this.editor = editor;\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose(): void {\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent) {\r\n        if (this.editor.isInIME() || event.eventType != PluginEventType.Input) {\r\n            return;\r\n        }\r\n\r\n        // Exit early on input events that do not insert a replacement's final character.\r\n        if (!event.rawEvent.data || !this.replacementEndCharacters.has(event.rawEvent.data)) {\r\n            return;\r\n        }\r\n\r\n        // Get the matching replacement\r\n        const range = this.editor.getSelectionRange();\r\n        if (range == null) {\r\n            return;\r\n        }\r\n        const searcher = this.editor.getContentSearcherOfCursor(event);\r\n        const stringToSearch = searcher.getSubStringBefore(this.longestReplacementLength);\r\n\r\n        const replacement = this.getMatchingReplacement(stringToSearch);\r\n        if (replacement == null) {\r\n            return;\r\n        }\r\n\r\n        // Reconstruct a selection of the text on the document that matches the\r\n        // replacement we selected.\r\n        const matchingText = searcher.getSubStringBefore(replacement.sourceString.length);\r\n        const matchingRange = searcher.getRangeFromText(matchingText, true /* exactMatch */);\r\n\r\n        // parse the html string off the dom and inline the resulting element.\r\n        const document = this.editor.getDocument();\r\n        const parsingSpan = document.createElement('span');\r\n        parsingSpan.innerHTML = replacement.replacementHTML;\r\n        const nodeToInsert =\r\n            parsingSpan.childNodes.length == 1 ? parsingSpan.childNodes[0] : parsingSpan;\r\n\r\n        // Switch the node for the selection range\r\n        this.editor.addUndoSnapshot(\r\n            () => {\r\n                matchingRange.deleteContents();\r\n                matchingRange.insertNode(nodeToInsert);\r\n                this.editor.select(nodeToInsert, PositionType.End);\r\n            },\r\n            null /*changeSource*/,\r\n            true /*canUndoByBackspace*/\r\n        );\r\n    }\r\n\r\n    private getMatchingReplacement(stringToSearch: string): CustomReplacement | null {\r\n        if (stringToSearch.length == 0) {\r\n            return null;\r\n        }\r\n        const lowerCaseStringToSearch = stringToSearch.toLocaleLowerCase();\r\n        for (const replacement of this.replacements) {\r\n            const [sourceMatch, replacementMatch] = replacement.matchSourceCaseSensitive\r\n                ? [stringToSearch, replacement.sourceString]\r\n                : [lowerCaseStringToSearch, replacement.sourceString.toLocaleLowerCase()];\r\n\r\n            if (\r\n                sourceMatch.substring(sourceMatch.length - replacementMatch.length) ==\r\n                replacementMatch\r\n            ) {\r\n                return replacement;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction getLongestReplacementSourceLength(replacements: CustomReplacement[]): number {\r\n    return Math.max.apply(\r\n        null,\r\n        replacements.map(replacement => replacement.sourceString.length)\r\n    );\r\n}\r\n\r\nfunction getReplacementEndCharacters(replacements: CustomReplacement[]): Set<string> {\r\n    const endChars = new Set<string>();\r\n    for (let replacement of replacements) {\r\n        const sourceString = replacement.sourceString;\r\n        if (sourceString.length == 0) {\r\n            continue;\r\n        }\r\n        const lastChar = sourceString[sourceString.length - 1];\r\n        if (!replacement.matchSourceCaseSensitive) {\r\n            endChars.add(lastChar.toLocaleLowerCase());\r\n            endChars.add(lastChar.toLocaleUpperCase());\r\n        } else {\r\n            endChars.add(lastChar);\r\n        }\r\n    }\r\n    return endChars;\r\n}\r\n","export * from './plugins/CutPasteListChain/index';\r\n","export { default as CutPasteListChain } from './CutPasteListChain';\r\n","import { experimentCommitListChains } from 'roosterjs-editor-api';\r\nimport { VListChain } from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\n/**\r\n * Maintain list numbers of list chain when content is modified by cut/paste/drag&drop\r\n */\r\nexport default class CutPasteListChain implements EditorPlugin {\r\n    private chains: VListChain[];\r\n    private expectedChangeSource: ChangeSource;\r\n    private editor: IEditor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Get a friendly name of this plugin\r\n     */\r\n    getName() {\r\n        return 'CutPasteListChain';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin\r\n     * @param editor The editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.disposer = this.editor.addDomEventHandler('drop', this.onDrop);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer?.();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.BeforeCutCopy:\r\n                if (event.isCut) {\r\n                    this.cacheListChains(ChangeSource.Cut);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.BeforePaste:\r\n                this.cacheListChains(ChangeSource.Paste);\r\n                break;\r\n\r\n            case PluginEventType.ContentChanged:\r\n                if (this.chains?.length > 0 && this.expectedChangeSource == event.source) {\r\n                    experimentCommitListChains(this.editor, this.chains);\r\n                    this.chains = null;\r\n                    this.expectedChangeSource = null;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onDrop = () => {\r\n        this.cacheListChains(ChangeSource.Drop);\r\n    };\r\n\r\n    private cacheListChains(source: ChangeSource) {\r\n        if (this.editor.isFeatureEnabled(ExperimentalFeatures.ListChain)) {\r\n            this.chains = VListChain.createListChains(this.editor.getSelectedRegions());\r\n            this.expectedChangeSource = source;\r\n        }\r\n    }\r\n}\r\n","export * from './plugins/ImageResize/index';\r\n","export { default as ImageResize } from './ImageResize';\r\n","import { contains, fromHtml, getEntitySelector, getTagOfNode, toArray } from 'roosterjs-editor-dom';\r\nimport { insertEntity } from 'roosterjs-editor-api';\r\nimport {\r\n    ChangeSource,\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PositionType,\r\n    EntityOperation,\r\n    Entity,\r\n    ExperimentalFeatures,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst DELETE_KEYCODE = 46;\r\nconst BACKSPACE_KEYCODE = 8;\r\nconst SHIFT_KEYCODE = 16;\r\nconst CTRL_KEYCODE = 17;\r\nconst ALT_KEYCODE = 18;\r\n\r\nconst ENTITY_TYPE = 'IMAGE_RESIZE_WRAPPER';\r\n\r\nconst HANDLE_SIZE = 7;\r\nconst HANDLE_MARGIN = 3;\r\nconst CORNER_HANDLE_POSITIONS = ['nw', 'ne', 'se', 'sw'];\r\nconst SIDE_HANDLE_POSITIONS = ['n', 'e', 's', 'w'];\r\nconst ALL_HANDLE_POSITIONS = CORNER_HANDLE_POSITIONS.concat(SIDE_HANDLE_POSITIONS);\r\n\r\n/**\r\n * ImageResize plugin provides the ability to resize an inline image in editor\r\n */\r\nexport default class ImageResize implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private startPageX: number;\r\n    private startPageY: number;\r\n    private startWidth: number;\r\n    private startHeight: number;\r\n    private resizeDiv: HTMLElement;\r\n    private direction: string;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create a new instance of ImageResize\r\n     * @param minWidth Minimum width of image when resize in pixel, default value is 10\r\n     * @param minHeight Minimum height of image when resize in pixel, default value is 10\r\n     * @param selectionBorderColor Color of resize border and handles, default value is #DB626C\r\n     * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false\r\n     * @param resizableImageSelector Selector for picking which image is resizable (e.g. for all images not placeholders), note\r\n     * that the tag must be IMG regardless what the selector is\r\n     */\r\n    constructor(\r\n        private minWidth: number = 10,\r\n        private minHeight: number = 10,\r\n        private selectionBorderColor: string = '#DB626C',\r\n        private forcePreserveRatio: boolean = false,\r\n        private resizableImageSelector: string = 'img'\r\n    ) {}\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'ImageResize';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.disposer = editor.addDomEventHandler({\r\n            dragstart: this.onDragStart,\r\n            blur: this.onBlur,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.hideResizeHandle();\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(e: PluginEvent) {\r\n        if (e.eventType == PluginEventType.MouseDown) {\r\n            const event = e.rawEvent;\r\n            const target = <HTMLElement>(event.srcElement || event.target);\r\n\r\n            if (getTagOfNode(target) == 'IMG') {\r\n                const parent = target.parentNode as HTMLElement;\r\n                const elements = parent\r\n                    ? toArray(parent.querySelectorAll(this.resizableImageSelector))\r\n                    : [];\r\n                if (elements.indexOf(target) < 0) {\r\n                    return;\r\n                }\r\n\r\n                const currentImg = this.getSelectedImage();\r\n                if (currentImg && currentImg != target) {\r\n                    this.hideResizeHandle();\r\n                }\r\n\r\n                if (!this.resizeDiv) {\r\n                    this.showResizeHandle(<HTMLImageElement>target);\r\n                }\r\n            } else if (this.resizeDiv && !contains(this.resizeDiv, target)) {\r\n                this.hideResizeHandle();\r\n            }\r\n        } else if (e.eventType == PluginEventType.KeyDown && this.resizeDiv) {\r\n            const event = e.rawEvent;\r\n            if (event.which == DELETE_KEYCODE || event.which == BACKSPACE_KEYCODE) {\r\n                this.editor.addUndoSnapshot(() => {\r\n                    this.editor.deleteNode(this.resizeDiv);\r\n                });\r\n                this.resizeDiv = null;\r\n                event.preventDefault();\r\n            } else if (\r\n                event.which != SHIFT_KEYCODE &&\r\n                event.which != CTRL_KEYCODE &&\r\n                event.which != ALT_KEYCODE\r\n            ) {\r\n                this.hideResizeHandle(true /*selectImage*/);\r\n            }\r\n        } else if (\r\n            e.eventType == PluginEventType.ContentChanged &&\r\n            e.source != ChangeSource.ImageResize &&\r\n            (e.source != ChangeSource.InsertEntity || (<Entity>e.data)?.type != ENTITY_TYPE)\r\n        ) {\r\n            this.editor.queryElements(getEntitySelector(ENTITY_TYPE), this.removeResizeDiv);\r\n            this.resizeDiv = null;\r\n        } else if (e.eventType == PluginEventType.EntityOperation && e.entity.type == ENTITY_TYPE) {\r\n            if (e.operation == EntityOperation.ReplaceTemporaryContent) {\r\n                this.removeResizeDiv(e.entity.wrapper);\r\n            } else if (e.operation == EntityOperation.Click) {\r\n                this.stopEvent(e.rawEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select a given IMG element, show the resize handle\r\n     * @param img The IMG element to select\r\n     */\r\n    showResizeHandle(img: HTMLImageElement) {\r\n        this.resizeDiv = this.createResizeDiv(img);\r\n        this.editor.select(this.resizeDiv, PositionType.After);\r\n    }\r\n\r\n    /**\r\n     * Hide resize handle of current selected image\r\n     * @param selectImageAfterUnSelect Optional, when set to true, select the image element after hide the resize handle\r\n     */\r\n    hideResizeHandle(selectImageAfterUnSelect?: boolean) {\r\n        if (this.resizeDiv) {\r\n            const transform = this.resizeDiv.style.transform;\r\n            const img = this.removeResizeDiv(this.resizeDiv);\r\n\r\n            if (img) {\r\n                img.style.transform = transform;\r\n\r\n                if (selectImageAfterUnSelect) {\r\n                    this.editor.select(img);\r\n                }\r\n            }\r\n\r\n            this.resizeDiv = null;\r\n        }\r\n    }\r\n\r\n    private startResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            this.startPageX = e.pageX;\r\n            this.startPageY = e.pageY;\r\n            this.startWidth = img.clientWidth;\r\n            this.startHeight = img.clientHeight;\r\n            this.editor.addUndoSnapshot();\r\n\r\n            let document = this.editor.getDocument();\r\n            document.addEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.addEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            this.direction = (<HTMLElement>(e.srcElement || e.target)).dataset.direction;\r\n        }\r\n\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private doResize = (e: MouseEvent) => {\r\n        let img = this.getSelectedImage();\r\n        if (this.editor && img) {\r\n            let widthChange = e.pageX - this.startPageX;\r\n            let heightChange = e.pageY - this.startPageY;\r\n            let newWidth = this.calculateNewWidth(widthChange);\r\n            let newHeight = this.calculateNewHeight(heightChange);\r\n            const isSingleDirection =\r\n                this.isSingleDirectionNS(this.direction) ||\r\n                this.isSingleDirectionWE(this.direction);\r\n            const shouldPreserveRatio =\r\n                !isSingleDirection && (this.forcePreserveRatio || e.shiftKey);\r\n\r\n            if (shouldPreserveRatio) {\r\n                newHeight = Math.min(newHeight, (newWidth * this.startHeight) / this.startWidth);\r\n                newWidth = Math.min(newWidth, (newHeight * this.startWidth) / this.startHeight);\r\n\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n                if (ratio > 0) {\r\n                    if (newWidth < newHeight * ratio) {\r\n                        newWidth = newHeight * ratio;\r\n                    } else {\r\n                        newHeight = newWidth / ratio;\r\n                    }\r\n                }\r\n            }\r\n\r\n            img.style.width = newWidth + 'px';\r\n            img.style.height = newHeight + 'px';\r\n\r\n            // double check\r\n            if (shouldPreserveRatio) {\r\n                let ratio =\r\n                    this.startWidth > 0 && this.startHeight > 0\r\n                        ? (this.startWidth * 1.0) / this.startHeight\r\n                        : 0;\r\n\r\n                const clientWidth = Math.floor(img.clientWidth);\r\n                const clientHeight = Math.floor(img.clientHeight);\r\n                newWidth = Math.floor(newWidth);\r\n                newHeight = Math.floor(newHeight);\r\n                if (clientHeight !== newHeight || clientWidth !== newWidth) {\r\n                    if (clientHeight < newHeight) {\r\n                        newWidth = clientHeight * ratio;\r\n                    } else {\r\n                        newHeight = clientWidth / ratio;\r\n                    }\r\n                    img.style.width = newWidth + 'px';\r\n                    img.style.height = newHeight + 'px';\r\n                }\r\n            }\r\n        }\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private calculateNewWidth(widthChange: number): number {\r\n        let newWidth = this.startWidth;\r\n        if (!this.isSingleDirectionNS(this.direction)) {\r\n            newWidth = Math.max(\r\n                this.startWidth + (this.isWest(this.direction) ? -widthChange : widthChange),\r\n                this.minWidth\r\n            );\r\n        }\r\n        return newWidth;\r\n    }\r\n\r\n    private calculateNewHeight(heightChange: number): number {\r\n        let newHeight = this.startHeight;\r\n        if (!this.isSingleDirectionWE(this.direction)) {\r\n            newHeight = Math.max(\r\n                this.startHeight + (this.isNorth(this.direction) ? -heightChange : heightChange),\r\n                this.minHeight\r\n            );\r\n        }\r\n        return newHeight;\r\n    }\r\n\r\n    private finishResize = (e: MouseEvent) => {\r\n        var img = this.getSelectedImage() as HTMLImageElement;\r\n        if (this.editor && img) {\r\n            let document = this.editor.getDocument();\r\n            document.removeEventListener('mousemove', this.doResize, true /*useCapture*/);\r\n            document.removeEventListener('mouseup', this.finishResize, true /*useCapture*/);\r\n            let width = img.clientWidth;\r\n            let height = img.clientHeight;\r\n            img.style.width = width + 'px';\r\n            img.style.height = height + 'px';\r\n            img.width = width;\r\n            img.height = height;\r\n            this.resizeDiv.style.width = '';\r\n            this.resizeDiv.style.height = '';\r\n        }\r\n        this.direction = null;\r\n        this.editor.addUndoSnapshot();\r\n        this.editor.triggerContentChangedEvent(ChangeSource.ImageResize, img);\r\n        this.stopEvent(e);\r\n    };\r\n\r\n    private createResizeDiv(target: HTMLElement) {\r\n        const { wrapper } = insertEntity(\r\n            this.editor,\r\n            ENTITY_TYPE,\r\n            target,\r\n            false /*isBlock*/,\r\n            true /*isReadonly*/\r\n        );\r\n\r\n        wrapper.style.position = 'relative';\r\n        wrapper.style.display = 'inline-flex';\r\n\r\n        const html =\r\n            (this.editor.isFeatureEnabled(ExperimentalFeatures.SingleDirectionResize)\r\n                ? ALL_HANDLE_POSITIONS\r\n                : CORNER_HANDLE_POSITIONS\r\n            )\r\n                .map(\r\n                    pos =>\r\n                        `<div style=\"position:absolute;${this.isWest(pos) ? 'left' : 'right'}:${\r\n                            this.isSingleDirectionNS(pos) ? '50%' : '0px'\r\n                        };${this.isNorth(pos) ? 'top' : 'bottom'}:${\r\n                            this.isSingleDirectionWE(pos) ? '50%' : '0px'\r\n                        }\">\r\n                            <div id=${pos}-handle data-direction=\"${pos}\" style=\"position:relative;width:${HANDLE_SIZE}px;height:${HANDLE_SIZE}px;background-color: ${\r\n                            this.selectionBorderColor\r\n                        };cursor: ${pos}-resize;${\r\n                            this.isNorth(pos) ? 'top' : 'bottom'\r\n                        }:-${HANDLE_MARGIN}px;${\r\n                            this.isWest(pos) ? 'left' : 'right'\r\n                        }:-${HANDLE_MARGIN}px\"></div></div>`\r\n                )\r\n                .join('') +\r\n            `<div style=\"position:absolute;left:0;right:0;top:0;bottom:0;border:solid 1px ${this.selectionBorderColor};pointer-events:none;\">`;\r\n\r\n        fromHtml(html, this.editor.getDocument()).forEach(div => {\r\n            wrapper.appendChild(div);\r\n            div.addEventListener('mousedown', this.startResize);\r\n        });\r\n\r\n        // If the resizeDiv's image has a transform, apply it to the container\r\n        const selectedImage = this.getSelectedImage(wrapper);\r\n        if (selectedImage && selectedImage.style && selectedImage.style.transform) {\r\n            wrapper.style.transform = selectedImage.style.transform;\r\n            selectedImage.style.transform = '';\r\n        }\r\n\r\n        return wrapper;\r\n    }\r\n\r\n    private stopEvent = (e: Event) => {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    };\r\n\r\n    private removeResizeDiv = (resizeDiv: HTMLElement): HTMLImageElement => {\r\n        if (resizeDiv?.parentNode) {\r\n            const img = resizeDiv.querySelector('img');\r\n            if (img) {\r\n                resizeDiv.parentNode.insertBefore(img, resizeDiv);\r\n            }\r\n            resizeDiv.parentNode.removeChild(resizeDiv);\r\n            return img;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    private onBlur = (e: FocusEvent) => {\r\n        this.hideResizeHandle();\r\n    };\r\n\r\n    private getSelectedImage(div?: HTMLElement): HTMLElement {\r\n        const divWithImage = div || this.resizeDiv;\r\n        return divWithImage ? <HTMLElement>divWithImage.getElementsByTagName('IMG')[0] : null;\r\n    }\r\n\r\n    private isNorth(direction: string): boolean {\r\n        return direction && direction.substr(0, 1) == 'n';\r\n    }\r\n\r\n    private isWest(direction: string): boolean {\r\n        return direction && (direction.substr(1, 1) == 'w' || direction == 'w');\r\n    }\r\n\r\n    private isSingleDirectionNS(direction: string): boolean {\r\n        return direction && (direction == 'n' || direction == 's');\r\n    }\r\n\r\n    private isSingleDirectionWE(direction: string): boolean {\r\n        return direction && (direction == 'w' || direction == 'e');\r\n    }\r\n\r\n    private onDragStart = (e: DragEvent) => {\r\n        if ((e.srcElement || e.target) == this.getSelectedImage()) {\r\n            this.hideResizeHandle(true);\r\n        }\r\n    };\r\n}\r\n","export * from './plugins/Picker/index';\r\n","export { default as PickerPlugin } from './PickerPlugin';\r\n","import { replaceWithNode } from 'roosterjs-editor-api';\r\nimport {\r\n    Browser,\r\n    createRange,\r\n    isCharacterValue,\r\n    isModifierKey,\r\n    PartialInlineElement,\r\n} from 'roosterjs-editor-dom';\r\nimport {\r\n    ChangeSource,\r\n    EditorPlugin,\r\n    IEditor,\r\n    NodePosition,\r\n    PickerDataProvider,\r\n    PickerPluginOptions,\r\n    PluginDomEvent,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    PluginInputEvent,\r\n    PluginKeyboardEvent,\r\n    PositionType,\r\n} from 'roosterjs-editor-types';\r\n\r\n// Character codes.\r\n// IE11 uses different character codes. which are noted below.\r\n// If adding a new key, test in IE to figure out what the code is.\r\nconst BACKSPACE_CHARCODE = 'Backspace';\r\nconst TAB_CHARCODE = 'Tab';\r\nconst ENTER_CHARCODE = 'Enter';\r\nconst ESC_CHARCODE = !Browser.isIE ? 'Escape' : 'Esc';\r\nconst LEFT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowLeft' : 'Left';\r\nconst UP_ARROW_CHARCODE = !Browser.isIE ? 'ArrowUp' : 'Up';\r\nconst RIGHT_ARROW_CHARCODE = !Browser.isIE ? 'ArrowRight' : 'Right';\r\nconst DOWN_ARROW_CHARCODE = !Browser.isIE ? 'ArrowDown' : 'Down';\r\nconst DELETE_CHARCODE = !Browser.isIE ? 'Delete' : 'Del';\r\n\r\n// Input event input types.\r\nconst DELETE_CONTENT_BACKWARDS_INPUT_TYPE = 'deleteContentBackwards';\r\n\r\n// Unidentified key, the code for Android keyboard events.\r\nconst UNIDENTIFIED_KEY = 'Unidentified';\r\n// the char code for Android keyboard events on Webview below 51.\r\nconst UNIDENTIFIED_CODE = [0, 229];\r\n\r\n/**\r\n * PickerPlugin represents a plugin of editor which can handle picker related behaviors, including\r\n * - Show picker when special trigger key is pressed\r\n * - Hide picker\r\n * - Change selection in picker by Up/Down/Left/Right\r\n * - Apply selected item in picker\r\n *\r\n * PickerPlugin doesn't provide any UI, it just wraps related DOM events and invoke callback functions.\r\n * To show a picker UI, you need to build your own UI component. Please reference to\r\n * https://github.com/microsoft/roosterjs/tree/master/demo/scripts/controls/samplepicker\r\n */\r\nexport default class PickerPlugin<T extends PickerDataProvider = PickerDataProvider>\r\n    implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private eventHandledOnKeyDown: boolean;\r\n    private blockSuggestions: boolean;\r\n    private isSuggesting: boolean;\r\n    private lastKnownRange: Range;\r\n\r\n    // For detecting backspace in Android\r\n    private isPendingInputEventHandling: boolean = false;\r\n    private currentInputLength: number;\r\n    private newInputLength: number;\r\n\r\n    constructor(public readonly dataProvider: T, private pickerOptions: PickerPluginOptions) {}\r\n\r\n    /**\r\n     * Get a friendly name\r\n     */\r\n    getName() {\r\n        return 'Picker';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    public initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.dataProvider.onInitalize(\r\n            (htmlNode: Node) => {\r\n                this.editor.focus();\r\n\r\n                let wordToReplace = this.getWord(null);\r\n\r\n                // Safari drops our focus out so we get an empty word to replace when we call getWord.\r\n                // We fall back to using the lastKnownRange to try to get around this.\r\n                if ((!wordToReplace || wordToReplace.length == 0) && this.lastKnownRange) {\r\n                    this.editor.select(this.lastKnownRange);\r\n                    wordToReplace = this.getWord(null);\r\n                }\r\n\r\n                let insertNode = () => {\r\n                    if (wordToReplace) {\r\n                        replaceWithNode(\r\n                            this.editor,\r\n                            wordToReplace,\r\n                            htmlNode,\r\n                            true /* exactMatch */\r\n                        );\r\n                    } else {\r\n                        this.editor.insertNode(htmlNode);\r\n                    }\r\n                    this.setIsSuggesting(false);\r\n                };\r\n\r\n                this.editor.addUndoSnapshot(\r\n                    insertNode,\r\n                    this.pickerOptions.changeSource,\r\n                    this.pickerOptions.handleAutoComplete\r\n                );\r\n            },\r\n            (isSuggesting: boolean) => {\r\n                this.setIsSuggesting(isSuggesting);\r\n            },\r\n            editor\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    public dispose() {\r\n        this.editor = null;\r\n        this.dataProvider.onDispose();\r\n    }\r\n\r\n    /**\r\n     * Check if the plugin should handle the given event exclusively.\r\n     * Handle an event exclusively means other plugin will not receive this event in\r\n     * onPluginEvent method.\r\n     * If two plugins will return true in willHandleEventExclusively() for the same event,\r\n     * the final result depends on the order of the plugins are added into editor\r\n     * @param event The event to check\r\n     */\r\n    public willHandleEventExclusively(event: PluginEvent) {\r\n        return (\r\n            this.isSuggesting &&\r\n            (event.eventType == PluginEventType.KeyDown ||\r\n                event.eventType == PluginEventType.KeyUp ||\r\n                event.eventType == PluginEventType.Input)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    public onPluginEvent(event: PluginEvent) {\r\n        switch (event.eventType) {\r\n            case PluginEventType.ContentChanged:\r\n                if (event.source == ChangeSource.SetContent && this.dataProvider.onContentChanged) {\r\n                    // Stop suggesting since content is fully changed\r\n                    if (this.isSuggesting) {\r\n                        this.setIsSuggesting(false);\r\n                    }\r\n\r\n                    // Undos and other major changes to document content fire this type of event.\r\n                    // Inform the data provider of the current picker placed elements in the body.\r\n                    let elementIds: string[] = [];\r\n                    this.editor.queryElements(\r\n                        \"[id^='\" + this.pickerOptions.elementIdPrefix + \"']\",\r\n                        element => {\r\n                            if (element.id) {\r\n                                elementIds.push(element.id);\r\n                            }\r\n                        }\r\n                    );\r\n                    this.dataProvider.onContentChanged(elementIds);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyDown:\r\n                this.eventHandledOnKeyDown = false;\r\n                if (this.isAndroidKeyboardEvent(event)) {\r\n                    // On Android, the key for KeyboardEvent is \"Unidentified\" or undefined,\r\n                    // so handling should be done using the input rather than key down event\r\n                    // Since the key down event happens right before the input event, calculate the input\r\n                    // length here in preparation for onAndroidInputEvent\r\n                    this.currentInputLength = this.calcInputLength(event);\r\n                    this.isPendingInputEventHandling = true;\r\n                } else {\r\n                    this.onKeyDownEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Input:\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.onAndroidInputEvent(event);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.KeyUp:\r\n                if (!this.eventHandledOnKeyDown && this.shouldHandleKeyUpEvent(event)) {\r\n                    this.onKeyUpDomEvent(event);\r\n                    this.isPendingInputEventHandling = false;\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.MouseUp:\r\n                if (this.isSuggesting) {\r\n                    this.setIsSuggesting(false);\r\n                }\r\n                break;\r\n\r\n            case PluginEventType.Scroll:\r\n                if (this.dataProvider.onScroll) {\r\n                    // Dispatch scroll event to data provider\r\n                    this.dataProvider.onScroll(event.scrollContainer);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private setLastKnownRange(range: Range) {\r\n        this.lastKnownRange = range;\r\n    }\r\n\r\n    private setIsSuggesting(isSuggesting: boolean) {\r\n        this.isSuggesting = isSuggesting;\r\n\r\n        if (!isSuggesting) {\r\n            this.setLastKnownRange(null);\r\n        }\r\n        this.dataProvider.onIsSuggestingChanged(isSuggesting);\r\n\r\n        this.setAriaOwns(isSuggesting);\r\n        this.setAriaActiveDescendant(isSuggesting ? 0 : null);\r\n    }\r\n\r\n    private cancelDefaultKeyDownEvent(event: PluginKeyboardEvent) {\r\n        this.eventHandledOnKeyDown = true;\r\n        event.rawEvent.preventDefault();\r\n        event.rawEvent.stopImmediatePropagation();\r\n    }\r\n\r\n    private getIdValue(node: Node): string {\r\n        let element = node as Element;\r\n        return element.attributes && element.attributes.getNamedItem('id')\r\n            ? (element.attributes.getNamedItem('id').value as string)\r\n            : null;\r\n    }\r\n\r\n    private getWordBeforeCursor(event: PluginKeyboardEvent): string {\r\n        let searcher = this.editor.getContentSearcherOfCursor(event);\r\n        return searcher ? searcher.getWordBefore() : null;\r\n    }\r\n\r\n    private replaceNode(currentNode: Node, replacementNode: Node) {\r\n        if (currentNode) {\r\n            this.editor.deleteNode(currentNode);\r\n        }\r\n        if (replacementNode) {\r\n            this.editor.insertNode(replacementNode);\r\n        }\r\n    }\r\n\r\n    private getRangeUntilAt(event: PluginKeyboardEvent): Range {\r\n        let positionContentSearcher = this.editor.getContentSearcherOfCursor(event);\r\n        let startPos: NodePosition;\r\n        let endPos: NodePosition;\r\n        positionContentSearcher.forEachTextInlineElement(textInline => {\r\n            let hasMatched = false;\r\n            let nodeContent = textInline.getTextContent();\r\n            let nodeIndex = nodeContent ? nodeContent.length : -1;\r\n            while (nodeIndex >= 0) {\r\n                if (nodeContent[nodeIndex] == this.pickerOptions.triggerCharacter) {\r\n                    startPos = textInline.getStartPosition().move(nodeIndex);\r\n                    hasMatched = true;\r\n                    break;\r\n                }\r\n                nodeIndex--;\r\n            }\r\n\r\n            if (hasMatched) {\r\n                endPos = textInline.getEndPosition();\r\n            }\r\n\r\n            return hasMatched;\r\n        });\r\n        return createRange(startPos, endPos) || this.editor.getDocument().createRange();\r\n    }\r\n\r\n    private shouldHandleKeyUpEvent(event: PluginKeyboardEvent) {\r\n        // onKeyUpDomEvent should only be called when a key that produces a character value is pressed\r\n        // This check will always fail on Android since the KeyboardEvent's key is \"Unidentified\" or undefined\r\n        // However, we don't need to check for modifier events on mobile, so can ignore this check\r\n        return (\r\n            this.isAndroidKeyboardEvent(event) ||\r\n            isCharacterValue(event.rawEvent) ||\r\n            (this.isSuggesting && !isModifierKey(event.rawEvent))\r\n        );\r\n    }\r\n\r\n    private onKeyUpDomEvent(event: PluginKeyboardEvent) {\r\n        if (this.isSuggesting) {\r\n            // Word before cursor represents the text prior to the cursor, up to and including the trigger symbol.\r\n            const wordBeforeCursor = this.getWord(event);\r\n            const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n            const trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n\r\n            // If we hit a case where wordBeforeCursor is just the trigger character,\r\n            // that means we've gotten a onKeyUp event right after it's been typed.\r\n            // Otherwise, update the query string when:\r\n            // 1. There's an actual value\r\n            // 2. That actual value isn't just pure whitespace\r\n            // 3. That actual value isn't more than 4 words long (at which point we assume the person kept typing)\r\n            // Otherwise, we want to dismiss the picker plugin's UX.\r\n            if (\r\n                wordBeforeCursor == this.pickerOptions.triggerCharacter ||\r\n                (trimmedWordBeforeCursor &&\r\n                    trimmedWordBeforeCursor.length > 0 &&\r\n                    trimmedWordBeforeCursor.split(' ').length <= 4)\r\n            ) {\r\n                this.dataProvider.queryStringUpdated(\r\n                    trimmedWordBeforeCursor,\r\n                    wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                );\r\n                this.setLastKnownRange(this.editor.getSelectionRange());\r\n            } else {\r\n                this.setIsSuggesting(false);\r\n            }\r\n        } else {\r\n            let wordBeforeCursor = this.getWordBeforeCursor(event);\r\n            if (!this.blockSuggestions) {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor.split(' ').length <= 4 &&\r\n                    wordBeforeCursor[0] == this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.setIsSuggesting(true);\r\n                    const wordBeforeCursorWithoutTriggerChar = wordBeforeCursor.substring(1);\r\n                    let trimmedWordBeforeCursor = wordBeforeCursorWithoutTriggerChar.trim();\r\n                    this.dataProvider.queryStringUpdated(\r\n                        trimmedWordBeforeCursor,\r\n                        wordBeforeCursorWithoutTriggerChar == trimmedWordBeforeCursor\r\n                    );\r\n                    this.setLastKnownRange(this.editor.getSelectionRange());\r\n                    if (this.dataProvider.setCursorPoint) {\r\n                        // Determine the bounding rectangle for the @mention\r\n                        let searcher = this.editor.getContentSearcherOfCursor(event);\r\n                        let rangeNode = this.editor.getDocument().createRange();\r\n                        let nodeBeforeCursor = searcher.getInlineElementBefore().getContainerNode();\r\n                        let rangeStartSuccessfullySet = this.setRangeStart(\r\n                            rangeNode,\r\n                            nodeBeforeCursor,\r\n                            wordBeforeCursor\r\n                        );\r\n                        if (!rangeStartSuccessfullySet) {\r\n                            // VSO 24891: Out of range error is occurring because nodeBeforeCursor\r\n                            // is not including the trigger character. In this case, the node before\r\n                            // the node before cursor is the trigger character, and this is where the range should start.\r\n                            let nodeBeforeNodeBeforeCursor = nodeBeforeCursor.previousSibling;\r\n                            this.setRangeStart(\r\n                                rangeNode,\r\n                                nodeBeforeNodeBeforeCursor,\r\n                                this.pickerOptions.triggerCharacter\r\n                            );\r\n                        }\r\n                        let rect = rangeNode.getBoundingClientRect();\r\n\r\n                        // Safari's support for range.getBoundingClientRect is incomplete.\r\n                        // We perform this check to fall back to getClientRects in case it's at the page origin.\r\n                        if (rect.left == 0 && rect.bottom == 0 && rect.top == 0) {\r\n                            rect = rangeNode.getClientRects()[0];\r\n                        }\r\n\r\n                        if (rect) {\r\n                            rangeNode.detach();\r\n\r\n                            // Display the @mention popup in the correct place\r\n                            let targetPoint = { x: rect.left, y: (rect.bottom + rect.top) / 2 };\r\n                            let bufferZone = (rect.bottom - rect.top) / 2;\r\n                            this.dataProvider.setCursorPoint(targetPoint, bufferZone);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (\r\n                    wordBeforeCursor != null &&\r\n                    wordBeforeCursor[0] != this.pickerOptions.triggerCharacter\r\n                ) {\r\n                    this.blockSuggestions = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onKeyDownEvent(event: PluginKeyboardEvent) {\r\n        let keyboardEvent = event.rawEvent;\r\n        if (this.isSuggesting) {\r\n            if (keyboardEvent.key == ESC_CHARCODE) {\r\n                this.setIsSuggesting(false);\r\n                this.blockSuggestions = true;\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (keyboardEvent.key == BACKSPACE_CHARCODE) {\r\n                // #483: If we are backspacing over the trigger character that triggered this Picker\r\n                // then we need to hide the Picker\r\n                const wordBeforeCursor = this.getWord(event);\r\n                if (wordBeforeCursor == this.pickerOptions.triggerCharacter) {\r\n                    this.setIsSuggesting(false);\r\n                }\r\n            } else if (\r\n                this.dataProvider.shiftHighlight &&\r\n                (this.pickerOptions.isHorizontal\r\n                    ? keyboardEvent.key == LEFT_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                    : keyboardEvent.key == UP_ARROW_CHARCODE ||\r\n                      keyboardEvent.key == DOWN_ARROW_CHARCODE)\r\n            ) {\r\n                this.dataProvider.shiftHighlight(\r\n                    this.pickerOptions.isHorizontal\r\n                        ? keyboardEvent.key == RIGHT_ARROW_CHARCODE\r\n                        : keyboardEvent.key == DOWN_ARROW_CHARCODE\r\n                );\r\n\r\n                if (this.dataProvider.getSelectedIndex) {\r\n                    this.setAriaActiveDescendant(this.dataProvider.getSelectedIndex());\r\n                }\r\n\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else if (\r\n                this.dataProvider.selectOption &&\r\n                (keyboardEvent.key == ENTER_CHARCODE || keyboardEvent.key == TAB_CHARCODE)\r\n            ) {\r\n                this.dataProvider.selectOption();\r\n                this.cancelDefaultKeyDownEvent(event);\r\n            } else {\r\n                // Currently no op.\r\n            }\r\n        } else {\r\n            if (keyboardEvent.key == BACKSPACE_CHARCODE) {\r\n                const nodeRemoved = this.tryRemoveNode(event);\r\n                if (nodeRemoved) {\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            } else if (keyboardEvent.key == DELETE_CHARCODE) {\r\n                let searcher = this.editor.getContentSearcherOfCursor(event);\r\n                let nodeAfterCursor = searcher.getInlineElementAfter()\r\n                    ? searcher.getInlineElementAfter().getContainerNode()\r\n                    : null;\r\n                let nodeId = nodeAfterCursor ? this.getIdValue(nodeAfterCursor) : null;\r\n                if (nodeId && nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0) {\r\n                    let replacementNode = this.dataProvider.onRemove(nodeAfterCursor, false);\r\n                    this.replaceNode(nodeAfterCursor, replacementNode);\r\n                    this.cancelDefaultKeyDownEvent(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onAndroidInputEvent(event: PluginInputEvent) {\r\n        this.newInputLength = this.calcInputLength(event);\r\n\r\n        if (\r\n            this.newInputLength < this.currentInputLength ||\r\n            (event.rawEvent as any).inputType === DELETE_CONTENT_BACKWARDS_INPUT_TYPE\r\n        ) {\r\n            const nodeRemoved = this.tryRemoveNode(event);\r\n            if (nodeRemoved) {\r\n                this.eventHandledOnKeyDown = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private calcInputLength(event: PluginEvent) {\r\n        const wordBeforCursor = this.getInlineElementBeforeCursor(event);\r\n        return wordBeforCursor ? wordBeforCursor.length : 0;\r\n    }\r\n\r\n    private tryRemoveNode(event: PluginDomEvent): boolean {\r\n        const searcher = this.editor.getContentSearcherOfCursor(event);\r\n        const inlineElementBefore = searcher.getInlineElementBefore();\r\n        const nodeBeforeCursor = inlineElementBefore\r\n            ? inlineElementBefore.getContainerNode()\r\n            : null;\r\n        const nodeId = nodeBeforeCursor ? this.getIdValue(nodeBeforeCursor) : null;\r\n        const inlineElementAfter = searcher.getInlineElementAfter();\r\n\r\n        if (\r\n            nodeId &&\r\n            nodeId.indexOf(this.pickerOptions.elementIdPrefix) == 0 &&\r\n            (inlineElementAfter == null || !(inlineElementAfter instanceof PartialInlineElement))\r\n        ) {\r\n            const replacementNode = this.dataProvider.onRemove(nodeBeforeCursor, true);\r\n            if (replacementNode) {\r\n                this.replaceNode(nodeBeforeCursor, replacementNode);\r\n                if (this.isPendingInputEventHandling) {\r\n                    this.editor.runAsync(editor => {\r\n                        editor.select(replacementNode, PositionType.After);\r\n                    });\r\n                } else {\r\n                    this.editor.select(replacementNode, PositionType.After);\r\n                }\r\n            } else {\r\n                this.editor.deleteNode(nodeBeforeCursor);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private getWord(event: PluginKeyboardEvent) {\r\n        let wordFromRange = this.getRangeUntilAt(event).toString();\r\n        let wordFromCache = this.getWordBeforeCursor(event);\r\n        // VSO 24891: In picker, trigger and mention are separated into two nodes.\r\n        // In this case, wordFromRange is the trigger character while wordFromCache is the whole string,\r\n        // so wordFromCache is what we want to return.\r\n        if (\r\n            wordFromRange == this.pickerOptions.triggerCharacter &&\r\n            wordFromRange != wordFromCache\r\n        ) {\r\n            return wordFromCache;\r\n        }\r\n        return wordFromRange;\r\n    }\r\n\r\n    private setRangeStart(rangeNode: Range, node: Node, target: string) {\r\n        let nodeOffset = node ? node.textContent.lastIndexOf(target) : -1;\r\n        if (nodeOffset > -1) {\r\n            rangeNode.setStart(node, nodeOffset);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private setAriaOwns(isSuggesting: boolean) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-owns',\r\n            isSuggesting && this.pickerOptions.suggestionsLabel\r\n                ? this.pickerOptions.suggestionsLabel\r\n                : null\r\n        );\r\n    }\r\n\r\n    private setAriaActiveDescendant(selectedIndex: number) {\r\n        this.editor.setEditorDomAttribute(\r\n            'aria-activedescendant',\r\n            selectedIndex != null && this.pickerOptions.suggestionLabelPrefix\r\n                ? this.pickerOptions.suggestionLabelPrefix + selectedIndex.toString()\r\n                : null\r\n        );\r\n    }\r\n\r\n    private getInlineElementBeforeCursor(event: PluginEvent): string {\r\n        const searcher = this.editor.getContentSearcherOfCursor(event);\r\n        const element = searcher ? searcher.getInlineElementBefore() : null;\r\n        return element ? element.getTextContent() : null;\r\n    }\r\n\r\n    private isAndroidKeyboardEvent(event: PluginKeyboardEvent): boolean {\r\n        // Check keyboard events on Android for further handling.\r\n        // On Android Webview later 51, the KeyboardEvent's key is \"Unidentified\".\r\n        // On Android Webview below 51, the KeyboardEvent's key is not supported and always returns undefined,\r\n        // so using the charCode property, which is 0 or 229.\r\n        return (\r\n            event.rawEvent.key == UNIDENTIFIED_KEY ||\r\n            (event.rawEvent.key == undefined &&\r\n                UNIDENTIFIED_CODE.indexOf(event.rawEvent.charCode) > -1)\r\n        );\r\n    }\r\n}\r\n","export * from './plugins/TableResize/index';\r\n","export { default as TableResize } from './TableResize';\r\n","import { fromHtml, normalizeRect, VTable } from 'roosterjs-editor-dom';\r\nimport {\r\n    EditorPlugin,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    Rect,\r\n    ChangeSource,\r\n    TableOperation,\r\n    ContentPosition,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst INSERTER_COLOR = '#4A4A4A';\r\nconst INSERTER_SIDE_LENGTH = 12;\r\nconst INSERTER_BORDER_SIZE = 1;\r\n\r\nconst CELL_RESIZER_WIDTH = 4;\r\nconst HORIZONTAL_RESIZER_HTML =\r\n    '<div style=\"position: fixed; cursor: row-resize; user-select: none\"></div>';\r\nconst VERTICAL_RESIZER_HTML =\r\n    '<div style=\"position: fixed; cursor: col-resize; user-select: none\"></div>';\r\n\r\nconst enum ResizeState {\r\n    None,\r\n    Horizontal,\r\n    Vertical,\r\n}\r\n\r\n/**\r\n * TableResize plugin, provides the ability to resize a table by drag-and-drop\r\n */\r\nexport default class TableResize implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private onMouseMoveDisposer: () => void;\r\n    private tableRectMap: { table: HTMLTableElement; rect: Rect }[] = null;\r\n    private resizerContainer: HTMLDivElement;\r\n    private currentTable: HTMLTableElement;\r\n    private currentTd: HTMLTableCellElement;\r\n    private horizontalResizer: HTMLDivElement;\r\n    private verticalResizer: HTMLDivElement;\r\n    private resizingState: ResizeState = ResizeState.None;\r\n\r\n    private currentInsertTd: HTMLTableCellElement;\r\n    private insertingState: ResizeState = ResizeState.None;\r\n    private inserter: HTMLDivElement;\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'TableResize';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.setupResizerContainer();\r\n        this.onMouseMoveDisposer = this.editor.addDomEventHandler('mousemove', this.onMouseMove);\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.onMouseMoveDisposer();\r\n        this.destoryRectMap();\r\n        this.removeResizerContainer();\r\n\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(e: PluginEvent) {\r\n        switch (e.eventType) {\r\n            case PluginEventType.Input:\r\n            case PluginEventType.ContentChanged:\r\n            case PluginEventType.Scroll:\r\n                this.destoryRectMap();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private setupResizerContainer() {\r\n        this.resizerContainer = this.editor.getDocument().createElement('div');\r\n        this.editor.insertNode(this.resizerContainer, {\r\n            updateCursor: false,\r\n            insertOnNewLine: false,\r\n            replaceSelection: false,\r\n            position: ContentPosition.Outside,\r\n        });\r\n    }\r\n\r\n    private removeResizerContainer() {\r\n        this.resizerContainer.parentNode.removeChild(this.resizerContainer);\r\n        this.resizerContainer = null;\r\n    }\r\n\r\n    private onMouseMove = (e: MouseEvent) => {\r\n        if (this.resizingState != ResizeState.None) {\r\n            return;\r\n        }\r\n\r\n        if (!this.tableRectMap) {\r\n            this.cacheRects();\r\n        }\r\n\r\n        if (this.tableRectMap) {\r\n            let i = this.tableRectMap.length - 1;\r\n            for (; i >= 0; i--) {\r\n                const { table, rect } = this.tableRectMap[i];\r\n                if (\r\n                    e.pageX >= rect.left - INSERTER_SIDE_LENGTH &&\r\n                    e.pageX <= rect.right &&\r\n                    e.pageY >= rect.top - INSERTER_SIDE_LENGTH &&\r\n                    e.pageY <= rect.bottom\r\n                ) {\r\n                    this.setCurrentTable(table, rect);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (i < 0) {\r\n                this.setCurrentTable(null);\r\n            }\r\n\r\n            if (this.currentTable) {\r\n                const map = this.tableRectMap.filter(map => map.table == this.currentTable)[0];\r\n\r\n                for (let i = 0; i < this.currentTable.rows.length; i++) {\r\n                    const tr = this.currentTable.rows[i];\r\n\r\n                    let j = 0;\r\n                    for (; j < tr.cells.length; j++) {\r\n                        const td = tr.cells[Math.max(0, j)];\r\n                        const tdRect = normalizeRect(td.getBoundingClientRect());\r\n\r\n                        if (tdRect && e.pageX <= tdRect.right && e.pageY < tdRect.bottom) {\r\n                            if (i == 0 && e.pageY < tdRect.top) {\r\n                                this.setCurrentTd(null);\r\n                                this.setCurrentInsertTd(ResizeState.Vertical, td, map.rect);\r\n                                break;\r\n                            } else if (j == 0 && e.pageX < tdRect.left) {\r\n                                this.setCurrentTd(null);\r\n                                this.setCurrentInsertTd(ResizeState.Horizontal, td, map.rect);\r\n                                break;\r\n                            } else {\r\n                                this.setCurrentTd(td, map.rect, tdRect.right, tdRect.bottom);\r\n                                this.setCurrentInsertTd(ResizeState.None);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (j < tr.cells.length) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private setCurrentInsertTd(insertingState: ResizeState.None): void;\r\n    private setCurrentInsertTd(\r\n        insertingState: ResizeState,\r\n        td: HTMLTableCellElement,\r\n        tableRect: Rect\r\n    ): void;\r\n    private setCurrentInsertTd(\r\n        insertingState: ResizeState,\r\n        td?: HTMLTableCellElement,\r\n        tableRect?: Rect\r\n    ) {\r\n        if (td != this.currentInsertTd || insertingState != this.insertingState) {\r\n            if (this.currentInsertTd) {\r\n                this.resizerContainer.removeChild(this.inserter);\r\n                this.inserter = null;\r\n            }\r\n            this.insertingState = insertingState;\r\n            this.currentInsertTd = td;\r\n            if (this.currentInsertTd) {\r\n                this.inserter = this.createInserter(tableRect);\r\n                this.resizerContainer.appendChild(this.inserter);\r\n            }\r\n        }\r\n    }\r\n\r\n    private createInserter(tableRect: Rect) {\r\n        const rect = normalizeRect(this.currentInsertTd.getBoundingClientRect());\r\n        const editorBackgroundColor = this.editor.getDefaultFormat().backgroundColor;\r\n        const inserterBackgroundColor = editorBackgroundColor || 'white';\r\n        const HORIZONTAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${INSERTER_COLOR}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${INSERTER_COLOR}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 12px; top: 5px; height: 3px; border-top: 1px solid ${INSERTER_COLOR}; border-bottom: 1px solid ${INSERTER_COLOR}; border-right: 1px solid ${INSERTER_COLOR}; border-left: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\r\n        const VERTICAL_INSERTER_HTML = `<div style=\"position: fixed; width: ${INSERTER_SIDE_LENGTH}px; height: ${INSERTER_SIDE_LENGTH}px; font-size: 16px; color: ${INSERTER_COLOR}; line-height: 10px; vertical-align: middle; text-align: center; cursor: pointer; border: solid ${INSERTER_BORDER_SIZE}px ${INSERTER_COLOR}; border-radius: 50%; background-color: ${inserterBackgroundColor}\"><div style=\"position: absolute; left: 5px; top: 12px; width: 3px; border-left: 1px solid ${INSERTER_COLOR}; border-right: 1px solid ${INSERTER_COLOR}; border-bottom: 1px solid ${INSERTER_COLOR}; border-top: 0px; box-sizing: border-box; background-color: ${inserterBackgroundColor};\"></div>+</div>`;\r\n\r\n        const inserter = fromHtml(\r\n            this.insertingState == ResizeState.Horizontal\r\n                ? HORIZONTAL_INSERTER_HTML\r\n                : VERTICAL_INSERTER_HTML,\r\n            this.editor.getDocument()\r\n        )[0] as HTMLDivElement;\r\n\r\n        if (rect) {\r\n            if (this.insertingState == ResizeState.Horizontal) {\r\n                inserter.style.left = `${\r\n                    rect.left - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\r\n                }px`;\r\n                inserter.style.top = `${rect.bottom - 8}px`;\r\n                (inserter.firstChild as HTMLElement).style.width = `${\r\n                    tableRect.right - tableRect.left\r\n                }px`;\r\n            } else {\r\n                inserter.style.left = `${rect.right - 8}px`;\r\n                inserter.style.top = `${\r\n                    rect.top - (INSERTER_SIDE_LENGTH - 1 + 2 * INSERTER_BORDER_SIZE)\r\n                }px`;\r\n                (inserter.firstChild as HTMLElement).style.height = `${\r\n                    tableRect.bottom - tableRect.top\r\n                }px`;\r\n            }\r\n        }\r\n\r\n        inserter.addEventListener('click', this.insertTd);\r\n\r\n        return inserter;\r\n    }\r\n\r\n    private insertTd = () => {\r\n        this.editor.addUndoSnapshot((start, end) => {\r\n            const vtable = new VTable(this.currentInsertTd);\r\n            vtable.edit(\r\n                this.insertingState == ResizeState.Horizontal\r\n                    ? TableOperation.InsertBelow\r\n                    : TableOperation.InsertRight\r\n            );\r\n            vtable.writeBack();\r\n            this.editor.select(start, end);\r\n            this.setCurrentInsertTd(ResizeState.None);\r\n        }, ChangeSource.Format);\r\n    };\r\n\r\n    private setCurrentTable(table: HTMLTableElement, rect: Rect): void;\r\n    private setCurrentTable(table: null): void;\r\n    private setCurrentTable(table: HTMLTableElement, rect?: Rect) {\r\n        if (this.currentTable != table) {\r\n            this.setCurrentTd(null);\r\n            this.setCurrentInsertTd(ResizeState.None);\r\n            this.currentTable = table;\r\n        }\r\n    }\r\n\r\n    private setCurrentTd(td: null): void;\r\n    private setCurrentTd(\r\n        td: HTMLTableCellElement,\r\n        tableRect: Rect,\r\n        right: number,\r\n        bottom: number\r\n    ): void;\r\n    private setCurrentTd(\r\n        td: HTMLTableCellElement,\r\n        tableRect?: Rect,\r\n        right?: number,\r\n        bottom?: number\r\n    ) {\r\n        if (this.currentTd != td) {\r\n            if (this.currentTd) {\r\n                this.resizerContainer.removeChild(this.horizontalResizer);\r\n                this.resizerContainer.removeChild(this.verticalResizer);\r\n                this.horizontalResizer = null;\r\n                this.verticalResizer = null;\r\n            }\r\n\r\n            this.currentTd = td;\r\n\r\n            if (this.currentTd) {\r\n                this.horizontalResizer = this.createResizer(\r\n                    true /*horizontal*/,\r\n                    tableRect.left,\r\n                    bottom - CELL_RESIZER_WIDTH + 1,\r\n                    tableRect.right - tableRect.left,\r\n                    CELL_RESIZER_WIDTH\r\n                );\r\n                this.verticalResizer = this.createResizer(\r\n                    false /*horizontal*/,\r\n                    right - CELL_RESIZER_WIDTH + 1,\r\n                    tableRect.top,\r\n                    CELL_RESIZER_WIDTH,\r\n                    tableRect.bottom - tableRect.top\r\n                );\r\n\r\n                this.resizerContainer.appendChild(this.horizontalResizer);\r\n                this.resizerContainer.appendChild(this.verticalResizer);\r\n            }\r\n        }\r\n    }\r\n\r\n    private createResizer(\r\n        horizontal: boolean,\r\n        left: number,\r\n        top: number,\r\n        width: number,\r\n        height: number\r\n    ) {\r\n        const div = fromHtml(\r\n            horizontal ? HORIZONTAL_RESIZER_HTML : VERTICAL_RESIZER_HTML,\r\n            this.editor.getDocument()\r\n        )[0] as HTMLDivElement;\r\n        div.style.top = `${top}px`;\r\n        div.style.left = `${left}px`;\r\n        div.style.width = `${width}px`;\r\n        div.style.height = `${height}px`;\r\n\r\n        div.addEventListener(\r\n            'mousedown',\r\n            horizontal ? this.startHorizontalResizeTable : this.startVerticalResizeTable\r\n        );\r\n\r\n        return div;\r\n    }\r\n\r\n    private startHorizontalResizeTable = (e: MouseEvent) => {\r\n        this.resizingState = ResizeState.Horizontal;\r\n        this.startResizeTable(e);\r\n    };\r\n\r\n    private startVerticalResizeTable = (e: MouseEvent) => {\r\n        this.resizingState = ResizeState.Vertical;\r\n        this.startResizeTable(e);\r\n    };\r\n\r\n    private startResizeTable(e: MouseEvent) {\r\n        const doc = this.editor.getDocument();\r\n        doc.addEventListener('mousemove', this.frameAnimateResizeTable, true);\r\n        doc.addEventListener('mouseup', this.endResizeTable, true);\r\n    }\r\n\r\n    private frameAnimateResizeTable = (e: MouseEvent) => {\r\n        this.editor.runAsync(() => this.resizeTable(e));\r\n    };\r\n\r\n    private resizeTable = (e: MouseEvent) => {\r\n        if (this.currentTd) {\r\n            const rect = normalizeRect(this.currentTd.getBoundingClientRect());\r\n\r\n            if (rect) {\r\n                const newPos = this.resizingState == ResizeState.Horizontal ? e.pageY : e.pageX;\r\n\r\n                let vtable = new VTable(this.currentTd);\r\n\r\n                if (this.resizingState == ResizeState.Horizontal) {\r\n                    vtable.table.style.height = null;\r\n                    vtable.forEachCellOfCurrentRow(cell => {\r\n                        if (cell.td) {\r\n                            cell.td.style.height =\r\n                                cell.td == this.currentTd ? `${newPos - rect.top}px` : null;\r\n                        }\r\n                    });\r\n                } else {\r\n                    vtable.table.style.width = '';\r\n                    vtable.table.width = '';\r\n                    vtable.forEachCellOfCurrentColumn(cell => {\r\n                        if (cell.td) {\r\n                            cell.td.style.width =\r\n                                cell.td == this.currentTd ? `${newPos - rect.left}px` : null;\r\n                        }\r\n                    });\r\n                }\r\n                vtable.writeBack();\r\n            }\r\n        }\r\n    };\r\n\r\n    private endResizeTable = (e: MouseEvent) => {\r\n        const doc = this.editor.getDocument();\r\n        doc.removeEventListener('mousemove', this.frameAnimateResizeTable, true);\r\n        doc.removeEventListener('mouseup', this.endResizeTable, true);\r\n\r\n        this.editor.addUndoSnapshot((start, end) => {\r\n            this.frameAnimateResizeTable(e);\r\n            this.editor.select(start, end);\r\n        }, ChangeSource.Format);\r\n\r\n        this.setCurrentTd(null);\r\n        this.resizingState = ResizeState.None;\r\n    };\r\n\r\n    private destoryRectMap() {\r\n        this.setCurrentTable(null);\r\n        this.tableRectMap = null;\r\n    }\r\n\r\n    private cacheRects() {\r\n        this.destoryRectMap();\r\n        this.tableRectMap = [];\r\n        this.editor.queryElements('table', table => {\r\n            const rect = normalizeRect(table.getBoundingClientRect());\r\n            if (rect) {\r\n                this.tableRectMap.push({\r\n                    table,\r\n                    rect,\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n","export * from './plugins/Watermark/index';\r\n","export { default as Watermark } from './Watermark';\r\n","import { applyFormat, getEntitySelector, getTagOfNode } from 'roosterjs-editor-dom';\r\nimport { insertEntity } from 'roosterjs-editor-api';\r\nimport {\r\n    DefaultFormat,\r\n    EditorPlugin,\r\n    Entity,\r\n    EntityOperation,\r\n    IEditor,\r\n    PluginEvent,\r\n    PluginEventType,\r\n    ContentPosition,\r\n} from 'roosterjs-editor-types';\r\n\r\nconst ENTITY_TYPE = 'WATERMARK_WRAPPER';\r\n\r\n/**\r\n * A watermark plugin to manage watermark string for roosterjs\r\n */\r\nexport default class Watermark implements EditorPlugin {\r\n    private editor: IEditor;\r\n    private disposer: () => void;\r\n\r\n    /**\r\n     * Create an instance of Watermark plugin\r\n     * @param watermark The watermark string\r\n     */\r\n    constructor(private watermark: string, private format?: DefaultFormat) {\r\n        this.format = this.format || {\r\n            fontSize: '14px',\r\n            textColor: '#aaa',\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get a friendly name of  this plugin\r\n     */\r\n    getName() {\r\n        return 'Watermark';\r\n    }\r\n\r\n    /**\r\n     * Initialize this plugin. This should only be called from Editor\r\n     * @param editor Editor instance\r\n     */\r\n    initialize(editor: IEditor) {\r\n        this.editor = editor;\r\n        this.disposer = this.editor.addDomEventHandler({\r\n            focus: this.showHideWatermark,\r\n            blur: this.showHideWatermark,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose this plugin\r\n     */\r\n    dispose() {\r\n        this.disposer();\r\n        this.disposer = null;\r\n        this.editor = null;\r\n    }\r\n\r\n    /**\r\n     * Handle events triggered from editor\r\n     * @param event PluginEvent object\r\n     */\r\n    onPluginEvent(event: PluginEvent) {\r\n        if (\r\n            event.eventType == PluginEventType.EditorReady ||\r\n            (event.eventType == PluginEventType.ContentChanged &&\r\n                (<Entity>event.data)?.type != ENTITY_TYPE)\r\n        ) {\r\n            this.showHideWatermark();\r\n        } else if (\r\n            event.eventType == PluginEventType.EntityOperation &&\r\n            event.entity.type == ENTITY_TYPE\r\n        ) {\r\n            const {\r\n                operation,\r\n                entity: { wrapper },\r\n            } = event;\r\n            if (operation == EntityOperation.ReplaceTemporaryContent) {\r\n                this.removeWatermark(wrapper);\r\n            } else if (event.operation == EntityOperation.NewEntity) {\r\n                applyFormat(wrapper, this.format, this.editor.isDarkMode());\r\n                wrapper.spellcheck = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private showHideWatermark = () => {\r\n        const hasFocus = this.editor.hasFocus();\r\n        const watermarks = this.editor.queryElements(getEntitySelector(ENTITY_TYPE));\r\n        const isShowing = watermarks.length > 0;\r\n\r\n        if (hasFocus && isShowing) {\r\n            watermarks.forEach(this.removeWatermark);\r\n            this.editor.focus();\r\n        } else if (!hasFocus && !isShowing && this.editor.isEmpty()) {\r\n            insertEntity(\r\n                this.editor,\r\n                ENTITY_TYPE,\r\n                this.editor.getDocument().createTextNode(this.watermark),\r\n                false /*isBlock*/,\r\n                false /*isReadonly*/,\r\n                ContentPosition.Begin\r\n            );\r\n        }\r\n    };\r\n\r\n    private removeWatermark = (wrapper: HTMLElement) => {\r\n        const parentNode = wrapper.parentNode;\r\n        parentNode?.removeChild(wrapper);\r\n\r\n        // After remove watermark node, if it leaves an empty DIV, append a BR node into it to make it a regular empty line\r\n        if (\r\n            this.editor.contains(parentNode) &&\r\n            getTagOfNode(parentNode) == 'DIV' &&\r\n            !parentNode.firstChild\r\n        ) {\r\n            parentNode.appendChild(this.editor.getDocument().createElement('BR'));\r\n        }\r\n    };\r\n}\r\n"],"sourceRoot":""}